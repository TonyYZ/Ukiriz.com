<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag and Connect Symbols</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f4f4f9;
            /* background-color: #262626; */
            /* background-color: #eef7f2; */
            /* background-color: #f9f1db; */
            font-family: Consolas;
            display: flex;
            height: 100vh; /* Full viewport height */
        }
        .symbol {
            position: absolute;
            width: 117px; /* Full width = 156 */
            height: 50.25px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
        }
        .symbol img {
            width: 100%;
            height: 100%;
        }

        .dot {
            position: absolute;
            width: 5px; /* Full width = 156 */
            height: 5px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
        }

        /* Highlight connections */
        .framed {
            outline: 2px solid #00B0F0;
        }

        /* Basic styles for the button */
        .button {
            position: fixed; /* Enables top and left positioning */
            background-size: contain; /* Ensure the image covers the entire button */
            background-repeat: no-repeat;
            background-position: center;
            border: none;
            border-radius: 5px; /* Optional: Makes the button rounded */
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.2s;
        }

        /* Add hover effect */
        .button:hover {
            opacity: 0.5;
        }

        .logo {
            position: fixed; /* Allows precise positioning using top and left */
            width: 250px; /* Adjust size as needed */
            height: auto; /* Maintain aspect ratio */
            margin-bottom: 20px;
        }

        .wheel {
            position: fixed;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
        }

        /* Vertical bar styles */
        .vertical-bar {
            position: fixed;
            top: 0;
            right: 0;
            width: 280px;
            height: 100%;
            background-color: #00B0F0; /* Blue background */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 200px;
        }

        /* Tab styles */
        .tab {
            color: white;
            text-align: center;
            line-height: 100px;
            font-size: 40px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            width: 280px;
            height: 100px; /* Make taller for rectangular shape */
            padding: 0; /* No extra padding */
            cursor: pointer;
            margin: 0px 0; /* Spacing between buttons */
            border-radius: 0; /* Remove rounded corners */
            transition: background-color 1s ease-in-out, opacity 1s ease-in-out;
            opacity: 0.5; /* Start at a slightly faded state */
        }

        .tab:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transition: background-color 0.3s;
        }

        .tab-active {
            background-color: rgba(255, 255, 255, 0.6);
            opacity: 1; /* Fully visible */
        }

        /* Content container */
        .content {
            margin-left: auto; /* Push content to the left of the vertical bar */
            margin-right: 100px; /* Leave space for the vertical bar */
            flex: 1;
            padding: 20px;
            overflow-y: auto; /* Allows vertical scrolling */
            height: 100vh;
        }

        /* Content sections */
        .tab-content {
            display: none; /* Hide all content by default */
        }

        .tab-content.active {
            display: block; /* Show active tab content */
        }

        /* Color palette styles */
        .palette {
            position: fixed;
            display: flex;
            justify-content: center;
            margin: 20px auto;
            gap: 10px;
        }

        .color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ccc;
        }

        .color:hover {
            border: 2px solid black;
        }


        .progress-ring {
            position: absolute;
            width: 50px; /* Ensure this matches the SVG width */
            height: 50px; /* Ensure this matches the SVG height */
            transform: rotate(-90deg);
            visibility: hidden;
        }
  
        .progress-ring circle {
            fill: none;
            stroke: transparent;
            stroke-width: 5;
            stroke-dasharray: 157; /* Full circle length */
            stroke-dashoffset: 157; /* Start fully hidden */
            transition: stroke-dashoffset 0s, stroke 0s;
        }

        /* Style for the label */
        .symbol-label {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            cursor: pointer;
        }

        .symbol-label.active {
            border-width: 3px; /* Thicker border when clicked */
        }

        /* Style for the input box */
        .label-input {
            position: absolute;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            border-radius: 5px;
        }

        /* Auto-resizing textarea */
        .label-textarea {
            position: absolute;
            width: 167px;
            min-height: 40px;
            max-width: 200px;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            border-radius: 5px;
            resize: none;
            overflow: hidden;
        }

        /* Style the submit button */
        .submit-button {
            position: absolute;
            background-color: white; /* Green */
            color: black;
            border: 1px solid black;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            width: 27px;
            height: 27px;
            line-height: 27px;
            text-align: center;
        }

        /* Hover effect */
        .submit-button:hover {
            opacity: 0.5;
        }


        .typing-effect p {
            position: absolute;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            display: inline-block;
            white-space: pre-line;
            line-height: 1.5; /* Adjusts spacing for smooth movement */
            overflow: hidden;
        }
        
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #message-input {
            position: absolute;
            bottom: 80px;
            left: 400px;
            padding: 10px;
            width: 300px;
            font-size: 30px; /* Larger font size */
            background-color: transparent; /* Transparent background */
            border: none; /* No border */
            color: black; /* Text color */
        }

        /* Style the placeholder text (prompt) */
        #message-input::placeholder {
            font-style: italic; /* Italicize the placeholder text */
            color: gray; /* Gray color for the placeholder */
        }

        #cursor {
            display: inline-block;
            margin-left: 1px;
            animation: blink 0.8s infinite;
            font-weight: bold;
            animation: blink 0.8s infinite;
        }


        .image-container {
            display: flex;
            justify-content: center;
        }
        .image-container img {
            width: 10%; /* 50% of the parent container */
            height: auto; /* Maintain aspect ratio */
        }

        .image-row {
            display: flex;         /* Align images in a row */
            justify-content: center; /* Center images horizontally */
            align-items: center;    /* Align images vertically */
            gap: 10px;             /* Space between images */
        }

        .image-row img {
            width: 20%;   /* Set a uniform width */
            height: auto;  /* Set a uniform height */
            object-fit: cover; /* Crop images to fit without stretching */
        }

        #network {
            width: 82vw;
            height: 100vh;
            border: none;
            background: transparent;
            box-shadow: none;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
    <div class="vertical-bar">
        <img src="./icons/iti.svg" alt="Logo" class="logo" id="logo">
        <div class="tab" id="tab-header0" onclick="showTab(0)">Home</div>
        <div class="tab" id="tab-header1" onclick="showTab(1)">Craft</div>
        <div class="tab" id="tab-header2" onclick="showTab(2)">Library</div>
        <div class="tab" id="tab-header3" onclick="showTab(3)">Share</div>
        <div class="tab" id="tab-header4" onclick="showTab(4)">Share!</div>
    </div>

    <div class="content">
        <div class="tab-content" id="tab0">
            <p style="text-align: center"><h1>Divinatory Conlang on Canvas</h1></p>
            Welcome here! <br>
            Ever wondered how divination works? <br>
            The fortune tellers somehow comprehend the meaning behind random patterns, from Tarot suits to teacup dregs...<br> Maybe it is because they learned the meaning of these symbols and knew how to tell a story out of them. Anyway, it is about intuition and imagination. <br><br>
            This online platform plays with this idea, trying to make YOU the fortune teller, but in a more general sense: you communicate with others by <br> producing and interpreting abstract symbols. <br>Instead of teaching you an entire symbolic language, I will help you build a language by yourself. <br>
            However, note that your system's set of "atoms" is fixed, but how the "molecules" are structured is up to you.  <br><br>

            Here are the possible ways of combining the symbols:<br>

            <div class="image-row">
                <img src="./icons/sp.png"/>
            </div>
            <br>
            The symbols connected in "series" represent spatially <b>contiguous</b> relationships: above, below, adjacent to, outside, etc.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a traffic light = three lights lined in a row.<br>
                (2) a barn = a roof on top of a pile of grains.<br>
            </p>
            The symbols connected in "parallel" represent <b>composite</b> concepts.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a white rock = the composite of whiteness and hardness.<br>
                (2) a bullet = the composite of smallness and advancing.<br>
            </p>

            <br>
            <div class="image-row">
                <img src="./icons/granary.png"/> <img src="./icons/bullet.png"/>
            </div>
            <br>
            As you can see, as long as it makes sense to you, it should work because it is all about <b>intuitiveness!</b><br><br>

            When you are making words, make sure the magnets connect the symbols. Only symbols connected count as a word. Treat them as "islands."<br>
            To check this, you can long-click on a symbol, and the entire connected island it belongs to will be highlighted.<br><br>
            Then, click on the <b>insight</b> button that looks like an eye, and it will propose some meanings from what it sees.<br>
            You can understand what each basic symbol means by repetitively clicking on the <b>insight</b> button and reading different meaningful aspects of the symbols.<br>
            While we only have the nine basic symbols from the start, the eye will see what you teach it to see over time.<br>
            Two windows will pop up that ask you to assign the word for your symbols and the reason behind this, though I haven't implemented the validation part yet.<br><br>
           
            In the next tab, poke around the interface and see if you can piece together your own expression for the words <b>"sky," "rain," "flower," and "computer."</b><br>
            Remember, when you are making the expressions, try to attend to the symbols' meaning (by clicking the <b>insight</b> button) <br>
            rather than purely by their visual resemblance to the concepts!
            <br><br><br><br>
            
        </div>
        <div class="tab-content" id="tab1">

            <!-- Color palette -->
            
            <div class="palette" id="palette">
                <div class="color" style="background-color: #5cb3cc;"></div>
                <div class="color" style="background-color: #D00000;"></div>
                <div class="color" style="background-color: #d6a01d;"></div>
                <div class="color" style="background-color: white;"></div>
                <div class="color" style="background-color: #3B3838;"></div>
            </div>
          <p></p>
        </div>
        <div class="tab-content" id="tab2">
          <div id="network"></div>
        </div>
        <div class="tab-content" id="tab3">
          <h1>Welcome to Tab 3</h1>
          <p>This is the content for Tab 3.</p>
        </div>
        <div class="tab-content" id="tab4">
              <!-- Input box at the bottom of the page -->
                <input type="text" id="message-input" placeholder="Say something..." />
          <p></p>
        </div>
    </div>

    <script type="module">
        const tabHeaders = [document.getElementById("tab-header0"), document.getElementById("tab-header1"), document.getElementById("tab-header2"), document.getElementById("tab-header3"), document.getElementById("tab-header4")];
        let tabHeadersActivated = [false, false, false, false, false];
        let activeTabInterval = null;
        // Switching between tabs
        window.showTab = function(tabIndex) {
            // Clear alpha animation
            clearInterval(activeTabInterval);
            tabHeaders[2].classList.remove('tab-active');

            // Hide all tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Show the selected tab content
            const activeContent = document.getElementById(`tab${tabIndex}`);
            activeContent.classList.add('active');

            for (let i = 0; i < 5; i++) {
                if (i === tabIndex) {
                    tabHeaders[i].style.opacity = 1;
                    tabHeadersActivated[i] = true;
                } else {
                    tabHeaders[i].style.opacity = 0.5;
                    tabHeadersActivated[i] = false;
                }
            }
        }

        // Initialize the first tab as active
        showTab(0);
        const tab0 = document.getElementById("tab0");
        const tab1 = document.getElementById("tab1");
        const tab2 = document.getElementById("tab2");
        const tab3 = document.getElementById("tab3");
        const tab4 = document.getElementById("tab4");

        let activeSymbol = null;
        let activeEmoji = null;
        let selectedSymbols = new Set();
        let selectedEmoji = null;
        let isGenerating = false;
        let readyActive = null;
        let readyActiveSide = null;
        let readyTarget = null;
        let readyTargetSide = null;

        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setDoc, getDoc, updateDoc, doc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        

        const firebaseConfig = {
            apiKey: "AIzaSyDcnYVyHx8ZgE_kKquLctcA3Q5LuSagZUE",
            authDomain: "divinatoryconlang.firebaseapp.com",
            projectId: "divinatoryconlang",
            storageBucket: "divinatoryconlang.firebasestorage.app",
            messagingSenderId: "939674998709",
            appId: "1:939674998709:web:bbf228a108e046c8006bfc",
            measurementId: "G-GLFVN6M297"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        let currentCollection = "col1";
        // Reference to Firestore collection
        const objCollection = collection(db, currentCollection);

        // Function to Save Emoji
        async function saveObj(type, content, x, y) {
            const docRef = await addDoc(objCollection, {type, content, x, y});
            return docRef.id;
        }

        async function updateObjPosition(id, x, y) {
            const objDoc = doc(db, currentCollection, id);
            await updateDoc(objDoc, { x, y });
        }

        // Load emojis on page load
        window.onload = loadObj;

        function generateColor(uid) {
            let hash = 0;
            for (let i = 0; i < uid.length; i++) {
                hash = uid.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = `hsl(${hash % 360}, 70%, 60%)`; // Hue varies, but saturation & lightness are fixed
            return color;
        }

        // Initialize Firebase Authentication
        const auth = getAuth();
        let currentUser = null;

        // Function to sign in anonymously & store user ID
        async function signInAnonymouslyPersistent() {
            try {
                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;
                
                // Store user ID in local storage
                localStorage.setItem("anonymousUID", currentUser .uid);

                console.log("Signed in as a guest:", currentUser .uid);
            } catch (error) {
                console.error("Error with anonymous sign-in:", error);
            }
        }

        // Function to restore previous session or sign in a new user
        async function restoreAnonymousSession() {
            const savedUID = localStorage.getItem("anonymousUID");

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    console.log("User is signed in:", user.uid);
                } else {
                    if (savedUID) {
                        console.log("Restoring previous session with UID:", savedUID);
                    } else {
                        signInAnonymouslyPersistent();
                    }
                }
            });
        }

        // 🔹 Call this function when the page loads
        restoreAnonymousSession();


        // Function to assign and store color if not already assigned
        async function assignUserColor() {
            const userRef = doc(db, "users", currentUser.uid); // Reference to user's Firestore document
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
                return userSnap.data().color; // Return existing color
            } else {
                const newColor = generateColor(currentUser.uid);
                await setDoc(userRef, { color: newColor });
                return newColor;
            }
        }

        // Function to Load Emojis
        async function loadObj() {
            const querySnapshot = await getDocs(objCollection);
            
            // Use a for...of loop to handle async/await properly
            for (const doc of querySnapshot.docs) {
                if (doc.data().type === "emoji") {
                    await createEmoji(doc.data().content, doc.data().x, doc.data().y, doc.id);
                }
                if (doc.data().type === "symbol") {
                    const symbol = await createSymbolCopy(null, null, doc.data().content.id, doc.data().x, doc.data().y, doc.data().content.color, doc.data().content.angle, doc.id);
                    if (doc.data().content.dotX !== null) {
                        symbol.isDynamic = true;
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        symbol.dot = dot;
                        dot.parent = symbol;
                        dot.style.left = `${doc.data().content.dotX}px`;
                        dot.style.top = `${doc.data().content.dotY}px`;
                        tab4.appendChild(dot);
                    }
                }
            }
        }

        // Function to delete a document
        async function deleteObj(collectionName, docId) {
            try {
                const docRef = doc(db, collectionName, docId);
                await deleteDoc(docRef);
                console.log(`Document with ID ${docId} deleted successfully.`);
            } catch (error) {
                console.error("Error deleting document:", error);
            }
        }

        class SymbolGraph {
            constructor() {
                this.map = new Map(); // Maps symbol to its adjacency list
            }

            addSymbol(symbol, connections) {
                this.map.set(symbol, connections); // connections = [[], [], (n, j), [], [], []]
            }

            getSymbolConnections(symbol) {
                return this.map.get(symbol) || null; // Return connections or null if not found
            }

            getSymbols() {
                return Array.from(this.map.keys()); // Return all symbols in the graph
            }

            matchSubgraph(storedGraph) {
                for (let [currSymbol] of this.map.entries()) {
                    let matchedSymbols = new Map();
                    if (this.doesMatch(storedGraph, currSymbol, matchedSymbols)) {
                        console.log("Match Found:", Array.from(matchedSymbols.values()));
                        return new Set(matchedSymbols.values());
                    }
                }
                console.log("No Match Found");
                return null;
            }

            doesMatch(storedGraph, currSymbol, matchedSymbols) {
                if (matchedSymbols.size === storedGraph.map.size) return true; // Full match found

                for (let [storedSymbol] of storedGraph.map.entries()) {
                    if (matchedSymbols.has(storedSymbol)) continue; // Already matched

                    if (this.isSymbolMatch(currSymbol, storedSymbol)) {
                        console.log(`Matching: ${currSymbol.elemIdTrue} ↔ ${storedSymbol.elemIdTrue}`);
                        matchedSymbols.set(storedSymbol, currSymbol);

                        let isValid = true;

                        // Check all six sides
                        for (let i = 0; i < 6; i++) {
                            let storedNeighbors = storedGraph.map.get(storedSymbol)[i] || [];
                            let currNeighbors = this.map.get(currSymbol)?.[i] || [];

                            if (storedNeighbors.length > currNeighbors.length) {
                                console.log(`Mismatch at side ${i}: Not enough neighbors`);
                                isValid = false;
                                break;
                            }

                            let foundAll = true;
                            for (let [storedNeighbor, storedSide] of storedNeighbors) {
                                let foundMatch = false;

                                for (let [currNeighbor, currSide] of currNeighbors) {
                                    if (
                                        currSide === storedSide &&
                                        this.isSymbolMatch(currNeighbor, storedNeighbor)
                                    ) {
                                        if (matchedSymbols.has(currNeighbor) || this.doesMatch(storedGraph, currNeighbor, matchedSymbols)) {
                                            foundMatch = true;
                                            break;
                                        }
                                    }
                                }

                                if (!foundMatch) {
                                    console.log(`Neighbor mismatch: ${storedNeighbor.elemIdTrue} not found`);
                                    foundAll = false;
                                    break;
                                }
                            }

                            if (!foundAll) {
                                isValid = false;
                                break;
                            }
                        }

                        if (isValid) return true;
                        matchedSymbols.delete(storedSymbol); // Backtrack
                    }
                }
                return false;
            }

            isSymbolMatch(currSymbol, storedSymbol) {
                return (
                    currSymbol &&
                    storedSymbol &&
                    currSymbol.elemIdTrue === storedSymbol.elemIdTrue &&
                    currSymbol.isDynamic === storedSymbol.isDynamic &&
                    currSymbol.angle === storedSymbol.angle
                );
            }
        }

        const currentGraph = new SymbolGraph();
        const library = new Map();
        const scale = 0.75;
        const SNAP_DISTANCE = 30 * scale; // Pixel distance for snapping

        let moleculeString = "";
        let selectedColor = null;
        const positions = [2, 1, 0, 7, 3, 4, 5, 6]; // Angle 0 = to the right
        // Circle layout parameters
        const radius = 150; // Radius of the circle
        const centerX = 450; // Center of the canvas (half of canvas width)
        const centerY = 200; // Center of the canvas (half of canvas height)

        const symbolScale = 0.75;
        const symbolWidth = 156;
        const symbolHeight = 67;

        const calX = 1;
        const calY = 6.7 * symbolScale;
        const calInvY = 7 * symbolScale;
        const calCan1 = 4 * symbolScale;
        const calCan2 = 3.5 * symbolScale;


        // Long press variables
        let progress = 0;
        let interval;
        let ring = null;
        let circle = null;
        const pressDuration = 1000; // 1 second to complete the bar
        const totalSteps = pressDuration / 10;

        // Set the x and y coordinates dynamically using JavaScript
        const logo = document.getElementById('logo');
        logo.style.right = `10px`; // Set the x position
        logo.style.top = `30px`; // Set the y position

        const palette = document.getElementById('palette');
        palette.style.left = `685px`;
        palette.style.top = `55px`;

        const apiKey = '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';  // Add your OpenAI API key here

        // Symbol labels
        const symbolLabels = [[['empty', 'medium', 'place'], ['still', 'calm', 'fixed']],
            [['protect', 'constrain'], ['come', 'pull', 'retreat']],
            [['center', 'middle', 'inner', 'occupy', 'point', 'individual', 'barrier', 'obstacle', 'unit'], ['separate', 'source', 'spread', 'explode', 'radiate']],
            [['latent', 'hidden', 'unsupported', 'supple', 'bloated'], ['decay', 'leak', 'discard', 'shed', 'loosen', 'let go']],
            [['base', 'carry', 'load', 'deep'], ['go', 'push', 'advance']],
            [['gap', 'contain', 'enclosure', 'shell', 'surround'], ['join', 'combine', 'close', 'squeeze', 'attach']],
            [['heap', 'pile', 'hill', 'stub', 'incomplete', 'recess', 'cavity', 'blade', 'sharp', 'shallow', 'exposed'], ['depart', 'give', 'express']],
            [['full', 'substance', 'complete', 'large'], ['chaotic', 'turmoil', 'unrest', 'hustle', 'activity', 'bustle', 'dynamic', 'vibrancy']],
            [['monotonous', 'homogeneous', 'same', 'normal', 'substance'], ['complex', 'system', 'order', 'organic', 'intricate', 'variegated']]];

        const symbolTitles = ['Based on Trigram Kun ☷. Empty and still.',
                        'Based on Trigram Gen ☶. Constrain and fall.',
                        'Based on Trigram Kan ☵. Occupy and radiate.',
                        'Based on Trigram Xun ☴. Latent and leak.',
                        'Based on Trigram Zhen ☳. Load and rise.',
                        'Based on Trigram Li ☲. Contain and attach.',
                        'Based on Trigram Dui ☱. Express and expose.',
                        'Based on Trigram Qian ☰. Full and vibrant.',
                        'A uniquely Ítí symbol. It is always balancing all elements, so it can be either monotonous or filled with variegated order.']
        // Symbol data (position on circle)
        const symbolData = [
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000;stroke-width:1.02897" d="M15.362 16.96v-1.28H49.92v2.56H15.362Z"></path><path d="M0 5.371v-1.28h34.56v2.56H0z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h38.08V4.48h2.56v13.76H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h23.68V4.48h2.56v11.2h23.68v2.56H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><a transform="translate(0 -12)"><path style="fill:#000" d="M0 31.52c0-1.28 0-1.28 16.31-1.28 8.438 0 12.956-.003 14.768.024 1.676.024.91-.928.319-1.77-6.312-9.011 4.424-20.08 13.641-14.065 5.795 3.782 5.914 12.549.223 16.464-2.752 1.894-2.823 1.899-25.021 1.903C0 32.8 0 32.8 0 31.52m43.461-2.46c6.384-3.947 3.578-13.7-3.941-13.7-8.426 0-10.362 11.492-2.437 14.458 1.796.672 4.604.338 6.378-.759"></path><path d="M-.007 31.517v-1.28h16.31s20.052 2.554 3.93 2.557l-20.24.003z" style="fill:#000"></path></a></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h38.08v2.56H9.28Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h26.24V4.48h2.56v13.76H9.28z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M49.915 19.513c0-1.28 0-1.28-16.31-1.28-8.438 0-12.955-.003-14.768.023-1.675.025-.909-.927-.318-1.77 6.312-9.01-4.424-20.08-13.642-14.065-5.795 3.782-5.913 12.55-.223 16.465 2.752 1.893 2.824 1.899 25.021 1.903 20.24.004 20.24.004 20.24-1.276M6.454 17.052c-6.384-3.947-3.578-13.7 3.941-13.7 8.426 0 10.363 11.493 2.437 14.459-1.796.672-4.604.338-6.378-.76"></path><path d="M49.922 19.51v-1.28h-16.31s-20.052 2.553-3.93 2.556l20.24.004z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M21.856 20.468c-3.226-1.115-6.05-3.957-6.641-6.684-.226-1.04-.226-1.04-7.72-1.04-7.495 0-7.495 0-7.495-1.28s0-1.28 7.348-1.28c4.823 0 6.48 0 7.148-.385.35-.201.427-.508.547-.975 2.649-10.367 17.185-10.367 19.834 0 .348 1.36.348 1.36 7.695 1.36s7.348 0 7.348 1.28 0 1.28-7.495 1.28c-7.494 0-7.494 0-7.72 1.04-1.093 5.04-7.683 8.47-12.85 6.684m5.74-2.465c6.55-2.232 6.55-11.806 0-14.039-7.822-2.664-13.768 6.713-7.883 12.43 2.026 1.966 5.032 2.58 7.882 1.61"></path><path d="M35.224 10.185H49.92v2.56h-7.494m-34.928.003H.003v-2.56h14.695" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h49.92v2.56H0Zm8-11.2V4.48h33.92v2.56H8Z"></path></svg>`
        ];


        const dotData = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="5" fill="red"/></svg>`;
        const dotDataMini = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="2" cy="2" r="2" fill="red"/></svg>`;
        const dotOffsetXData = [0, 45, 0, 46, -45, 0, -46, 0, 0];
        const dotOffsetYData = [0, 0, 0, -8, 0, 0, -8, -8, 0];
        async function rotateSymbol(symbol, addAngle) {
            selectedSymbol.angle = (selectedSymbol.angle + addAngle) % 360;
            if (selectedSymbol.elemId === 1) {
                if (selectedSymbol.angle === 90) {
                    selectedSymbol.elemId = 4;
                    selectedSymbol.innerHTML = symbolData[4];
                }
                if (selectedSymbol.angle === 270) {
                    selectedSymbol.elemId = 4;
                    selectedSymbol.innerHTML = symbolData[4];
                }
            } else if (selectedSymbol.elemId === 3) {
                if (selectedSymbol.angle === 90) {
                    selectedSymbol.elemId = 6;
                    selectedSymbol.innerHTML = symbolData[6];
                }
                if (selectedSymbol.angle === 270) {
                    selectedSymbol.elemId = 6;
                    selectedSymbol.innerHTML = symbolData[6];
                }
            } else if (selectedSymbol.elemId === 4) {
                if (selectedSymbol.angle === 90) {
                    selectedSymbol.elemId = 1;
                    selectedSymbol.innerHTML = symbolData[1];
                }
                if (selectedSymbol.angle === 270) {
                    selectedSymbol.elemId = 1;
                    selectedSymbol.innerHTML = symbolData[1];
                }
            }else if (selectedSymbol.elemId === 6) {
                if (selectedSymbol.angle === 90) {
                    selectedSymbol.elemId = 3;
                    selectedSymbol.innerHTML = symbolData[3];
                }
                if (selectedSymbol.angle === 270) {
                    selectedSymbol.elemId = 3;
                    selectedSymbol.innerHTML = symbolData[3];
                }
            }
            // selectedSymbol.querySelector('svg').setAttribute('width', '100%');
            // selectedSymbol.querySelector('svg').setAttribute('height', '100%');
            selectedSymbol.style.transform = `rotate(${selectedSymbol.angle}deg)`;
            if(selectedSymbol.isDynamic) await updateDotPosition(selectedSymbol.dot);
        }

        const turnButton = document.createElement("div");
        turnButton.classList.add("button");
        turnButton.style.width = `149px`;
        turnButton.style.height = `142px`;
        turnButton.style.backgroundImage = "url('./icons/turn.png')";
        turnButton.style.left = `40px`;
        turnButton.style.top = `30px`;
        turnButton.addEventListener("click", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    await rotateSymbol(selectedSymbol, 90);
                }
            }
            
            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
            
        });
        tab1.appendChild(turnButton);

        const turnButton2 = turnButton.cloneNode(true);
        turnButton2.addEventListener("click", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.angle = (selectedSymbol.angle + 90) % 360;
                    console.log(selectedSymbol.angle);
                    if (selectedSymbol.elemId === 1) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 4;
                            selectedSymbol.innerHTML = symbolData[4];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 4;
                            selectedSymbol.innerHTML = symbolData[4];
                        }
                    } else if (selectedSymbol.elemId === 3) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 6;
                            selectedSymbol.innerHTML = symbolData[6];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 6;
                            selectedSymbol.innerHTML = symbolData[6];
                        }
                    } else if (selectedSymbol.elemId === 4) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 1;
                            selectedSymbol.innerHTML = symbolData[1];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 1;
                            selectedSymbol.innerHTML = symbolData[1];
                        }
                    }else if (selectedSymbol.elemId === 6) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 3;
                            selectedSymbol.innerHTML = symbolData[3];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 3;
                            selectedSymbol.innerHTML = symbolData[3];
                        }
                    }
                    // selectedSymbol.querySelector('svg').setAttribute('width', '100%');
                    // selectedSymbol.querySelector('svg').setAttribute('height', '100%');
                    selectedSymbol.style.transform = `rotate(${selectedSymbol.angle}deg)`;
                    if(selectedSymbol.isDynamic) await updateDotPosition(selectedSymbol.dot);
                }
            }
            
            if (eyeButton2.isActivated) {
                eyeButton2.isActivated = false;
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        tab4.appendChild(turnButton2);

        const dotButton = document.createElement("div");
        dotButton.classList.add("button");
        dotButton.style.width = `143px`;
        dotButton.style.height = `94px`;
        dotButton.style.backgroundImage = "url('./icons/dot.png')";
        dotButton.style.left = `200px`;
        dotButton.style.top = `55px`;

        dotButton.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;
                        await updateDotPosition(dot);
                        tab1.appendChild(dot);

                    } else {

                        selectedSymbol.dot.remove();
                        selectedSymbol.dot = null;
                    }
                    
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });

        tab1.appendChild(dotButton);

        const dotButton2 = dotButton.cloneNode(true);
        dotButton2.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;
                        await updateDotPosition(dot);
                        tab4.appendChild(dot);
                    } else {
                        if (tabHeadersActivated[4]) {
                            const objDoc = doc(db, currentCollection, selectedSymbol.dataset.id);
                            
                            await updateDoc(objDoc, {
                                "content.dotX": null,
                                "content.dotY": null
                            });
                        }
                        selectedSymbol.dot.remove();
                        selectedSymbol.dot = null;
                    }
                    
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });
        tab4.appendChild(dotButton2);

        async function updateDotPosition(dot) {
            const symbol = dot.parent;
            const rect = symbol.getBoundingClientRect();
            switch (symbol.angle) {
                case 0: 
                    dot.style.left = `${parseFloat(rect.left) + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5}px`;
                    dot.style.top = `${parseFloat(rect.top) + dotOffsetYData[symbol.elemId] * symbolScale - 12}px`;
                    break;
                case 90:
                    dot.style.left = `${parseFloat(rect.right) - dotOffsetYData[symbol.elemId] * symbolScale}px`;
                    dot.style.top = `${parseFloat(rect.top) + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 10}px`;
                    break;
                case 180: 
                    dot.style.left = `${parseFloat(rect.right) - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5}px`;
                    dot.style.top = `${parseFloat(rect.bottom) - dotOffsetYData[symbol.elemId] * symbolScale - 7}px`;
                    break;
                case 270:
                    dot.style.left = `${parseFloat(rect.left) + dotOffsetYData[symbol.elemId] * symbolScale - 10}px`;
                    dot.style.top = `${parseFloat(rect.bottom) - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 7}px`;
                    break;
            }
            if (tabHeadersActivated[4]) {
                const objDoc = doc(db, currentCollection, symbol.dataset.id);
                
                await updateDoc(objDoc, {
                    "content.dotX": parseFloat(dot.style.left),
                    "content.dotY": parseFloat(dot.style.top)
                });
            }
        }
        const eyeButton = document.createElement("div");
        eyeButton.isActivated = false;
        eyeButton.classList.add("button");
        eyeButton.style.width = `150px`;
        eyeButton.style.height = `106px`;
        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
        eyeButton.style.left = `510px`;
        eyeButton.style.top = `40px`;

        eyeButton.addEventListener("mouseup", (e) => {
            eyeButton.isActivated = !eyeButton.isActivated;
            if (eyeButton.isActivated) {
                eyeButton.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();
                    showInput(foundIds, elimBasic, representatives, hasDuplicateExpression);
                }
            } else {
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab1.appendChild(eyeButton);

        const eyeButton2 = eyeButton.cloneNode(true);

        eyeButton2.addEventListener("mouseup", (e) => {
            eyeButton2.isActivated = !eyeButton2.isActivated;
            if (eyeButton2.isActivated) {
                eyeButton2.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();
                }
            } else {
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        tab4.appendChild(eyeButton2);

        const removeButton = document.createElement("div");
        removeButton.isActivated = false;
        removeButton.classList.add("button");
        removeButton.style.width = `168.75px`;
        removeButton.style.height = `119.25px`;
        removeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeButton.style.left = `340px`;
        removeButton.style.top = `40px`;

        removeButton.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                for (const selectedSymbol of selectedSymbols) {
                    if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                    await deleteObj(currentCollection, selectedSymbol.dataset.id);
                    selectedSymbol.remove();
                }
            }
            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab1.appendChild(removeButton);

        const removeButton2 = removeButton.cloneNode(true);

        removeButton2.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                    selectedSymbol.remove();
                });
            }
            console.log(selectedEmoji);
            if (selectedEmoji) {
                await deleteObj(currentCollection, selectedEmoji.dataset.id);
                selectedEmoji.remove();
                console.log(selectedEmoji);
            }
            if (eyeButton2.isActivated) {
                eyeButton2.isActivated = false;
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab4.appendChild(removeButton2);
        
        const removeNodeButton = document.createElement("div");
        removeNodeButton.isActivated = false;
        removeNodeButton.classList.add("button");
        removeNodeButton.style.width = `168.75px`;
        removeNodeButton.style.height = `119.25px`;
        removeNodeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeNodeButton.style.left = `40px`;
        removeNodeButton.style.top = `30px`;
        tab2.appendChild(removeNodeButton);
        removeNodeButton.addEventListener("mouseup", (e) => {
            let selectedNodes = network.getSelectedNodes(); // Get selected node ID(s)

            if (selectedNodes.length === 0) {
                alert("No node selected!");
                return;
            }

            let nodeId = selectedNodes[0]; // Get the first selected node

            if (basicNodes.has(nodes.get(nodeId))) {
                return;
            }
            // Remove the node
            nodes.remove(nodeId);

            // Remove edges connected to the node
            let connectedEdges = edges.get({
                filter: (edge) => edge.from === nodeId || edge.to === nodeId
            });
            edges.remove(connectedEdges);
        });


        function dyeColor(symbol, color) {
            const svgElement = symbol.querySelector("svg");
            const paths = svgElement.querySelectorAll("path"); // Get the first shape inside the SVG
            paths.forEach((path) => {
                path.setAttribute("style", "fill:" + color); // Change the fill attribute
            });
        }

        // Handle color selection
        palette.addEventListener("click", (e) => {
        if (e.target.classList.contains("color")) {
            selectedColor = e.target.style.backgroundColor; // Set the selected color
            if (selectedSymbols.size != 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    dyeColor(selectedSymbol, selectedColor);
                });
            }
            console.log(`Selected color: ${selectedColor}`);
        }
        });

        const wheel = document.createElement("div"); // Your wheel sprite
        wheel.classList.add("wheel");
        wheel.style.left = `50px`; // Set the x position
        wheel.style.bottom = `40px`; // Set the y position
        wheel.style.width = `290.67px`;
        wheel.style.height = `292.33px`;
        wheel.style.backgroundImage = "url('./icons/wheel/wheel.png')";
        let wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
        let wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
        console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY} ${window.innerHeight} ${parseFloat(wheel.style.bottom)}`);
        const centerRadius = 36; // Define center circle radius

        wheel.addEventListener("mousedown", async (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                console.log("Clicked center!");
                wheel.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            } 

            // Calculate the angle in degrees (0° at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45°)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel.addEventListener("mouseup", (event) => {
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });

        tab1.appendChild(wheel);

        const wheel2 = wheel.cloneNode(true);
        wheel2.addEventListener("mousedown", async (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                console.log("Clicked center!");
                wheel2.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            } 

            // Calculate the angle in degrees (0° at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45°)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel2.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel2.addEventListener("mouseup", (event) => {
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });
        tab4.appendChild(wheel2);

        // Function to handle the message when Enter is pressed
        async function handleMessage() {
            const messageBox = document.getElementById('message-input');
            const userInput = messageBox.value;
            console.log('User said:', userInput);
            // You can process the input here as needed
            // For now, let's just clear the input box
            messageBox.value = '';

            const backgroundKnowledge = `You are a helpful assistant who translates the user's message into a sequence of emojis. Try your best and be concise! Do not say anything extra except for the emojis.`;

            try {
                // Send request to OpenAI's chat API endpoint
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',  // You can use gpt-4 or gpt-3.5-turbo depending on your plan
                        messages: [
                            { role: 'system', content: backgroundKnowledge },
                            { role: 'user', content: userInput }
                        ],
                        max_tokens: 150,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const emojiResponse = data.choices[0].message.content.trim();

                // Display the response from the model
                const emoji = await createEmoji(emojiResponse);

            } catch (error) {
                console.error('Error:', error);
                alert('There was an error processing your request.');
            }
        }

        // Add event listener to the input box for the Enter key
        document.getElementById('message-input').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                handleMessage();
            }
        });

        function floatLabel(label) {
            const maxDistance = 20; // Maximum distance from the original position
            const originX = 0, originY = 0; // Store original position
            let x = 0, y = 0;

            setInterval(() => {
                let xDelta = getRandomFloat(-2, 2);
                let yDelta = getRandomFloat(-2, 2);

                // Calculate new position
                let newX = x + xDelta;
                let newY = y + yDelta;

                // Check if the new position is within the allowed distance
                let distance = Math.sqrt(newX ** 2 + newY ** 2);
                if (distance <= maxDistance) {
                    x = newX;
                    y = newY;
                    label.style.transform = `translate(${x}px, ${y}px)`;
                }
            }, 100);
        }


        async function createEmoji(emojiResponse, emojiX=null, emojiY=null, emojiId=null) {
            const emoji = document.createElement('div');
            emoji.classList.add('symbol-label');
            // Position the label near the symbol
            if (emojiX) {
                emoji.x = emojiX;
                emoji.y = emojiY;
            } else {
                emoji.x = getRandomFloat(window.innerWidth / 5, window.innerWidth * 4 / 5);
                emoji.y = getRandomFloat(window.innerHeight / 5, window.innerHeight * 4 / 5);
            }

            emoji.style.left = `${emoji.x}px`;
            emoji.style.top = `${emoji.y}px`;
            emoji.selected = false;
            
            // Add pressing event listener to the symbol
            emoji.addEventListener("mousedown", (e) => {
                if (selectedEmoji) {
                    selectedEmoji.style.cursor = "grab";
                    selectedEmoji.classList.remove("active");
                    selectedEmoji = null;
                }

                activeEmoji = emoji; // becomes active when being clicked on
                emoji.offsetX = e.clientX - emoji.offsetLeft;
                emoji.offsetY = e.clientY - emoji.offsetTop;
                emoji.selected = !emoji.selected;
                emoji.style.cursor = "grabbing";

                if (!activeEmoji.classList.contains("active")) {
                    activeEmoji.classList.add("active");
                }

            });

            tab4.appendChild(emoji);
            emoji.textContent = emojiResponse; // Default text
            floatLabel(emoji);

            if (emojiId !== null) {
                emoji.dataset.id = emojiId;
            } else {
                emoji.dataset.id = await saveObj("emoji", emojiResponse, emoji.x, emoji.y);
            }

            return emoji;
        }

        window.addEventListener("resize", () => {
            wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
            wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
            console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY}`);
        });

        function removeLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label.removable');
            labels.forEach(label => label.remove());
            const inputs = document.querySelectorAll('.label-input.removable');
            inputs.forEach(input => input.remove());
            const textareas = document.querySelectorAll('.label-textarea.removable');
            textareas.forEach(textarea => textarea.remove());
            const buttons = document.querySelectorAll('.submit-button.removable');
            buttons.forEach(button => button.remove());
            const outputBoxes = document.querySelectorAll('.typing-effect.removable');
            outputBoxes.forEach(outputBox => outputBox.remove());
        }

        function hideLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.remove('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.remove('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.classList.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.remove('active'));
        }

        function showLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.add('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.add('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.add.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.add('active'));
        }        


        document.addEventListener("mousemove", async (e) => {
            if (activeEmoji) {
                let x = e.clientX - activeEmoji.offsetX;
                let y = e.clientY - activeEmoji.offsetY;
                activeEmoji.style.left = `${x}px`;
                activeEmoji.style.top = `${y}px`;
                activeEmoji.selected = true;
            }

            if (activeSymbol && !activeSymbol.stopped) {
                let x = e.clientX - activeSymbol.offsetX;
                let y = e.clientY - activeSymbol.offsetY;
                activeSymbol.style.left = `${x}px`;
                activeSymbol.style.top = `${y}px`;
                activeSymbol.selected = true;
                endLongPress();
                // hideLabelInputs();
                if (activeSymbol.labels) {
                    activeSymbol.labels.forEach(label => {
                        label.style.left = `${x + label.offsetX}px`;
                        label.style.top = `${y + label.offsetY}px`;
                    });
                }
                if (activeSymbol.input) {
                    activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
                    activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
                }
                if (activeSymbol.textarea) {
                    activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
                    activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
                }
                if (activeSymbol.submitButton) {
                    activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
                    activeSymbol.submitButton.style.top = `${parseFloat(activeSymbol.textarea.style.top) + 8 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.pElement) {
                    activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
                    activeSymbol.pElement.style.top = `${parseFloat(activeSymbol.textarea.style.top) - 10 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.doneButton) {
                    activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
                    activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
                }

                if (!activeSymbol.moving) {
                    // Cut connections
                    for (let i = 0; i < currentGraph.getSymbolConnections(activeSymbol).length; i++) {
                        const entryLst = currentGraph.getSymbolConnections(activeSymbol)[i];
                        if (entryLst.length !== 0) {
                            // for (const entry in entryLst) {
                            for (let j = 0; j < entryLst.length; j++) {
                                const entry = entryLst[j];
                                const targetEntry = currentGraph.getSymbolConnections(entry[0])[entry[1]];
                                console.log(`targetEntry ${j}`);
                                console.log(targetEntry);
                                // Cut off from the other side
                                currentGraph.getSymbolConnections(entry[0])[entry[1]] = targetEntry.filter(sublist => sublist[0] !== activeSymbol);
                            }
                            currentGraph.getSymbolConnections(activeSymbol)[i] = [];
                        }
                    }
                    activeSymbol.moving = true;
                }
                if (!activeSymbol.classList.contains("framed")) {
                    activeSymbol.classList.add("framed");
                }

                checkConnections(activeSymbol);
                if (activeSymbol.isDynamic) await updateDotPosition(activeSymbol.dot);
                // console.log("mouse move " + activeSymbol.elemId);
            }
        });

        document.addEventListener("mouseup", async (e) => {
            endLongPress();
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";
            const clickedElemClass = e.target.className;
            console.log(`selected symbols ${selectedSymbols.size} clickedelemtype ${clickedElemClass}`);

            if (selectedSymbols.size !== 0 && clickedElemClass == 'content') {
                selectedSymbols.forEach(selectedSymbol => {
                    const rect = selectedSymbol.getBoundingClientRect();
                    // console.log('x1:' + rect.left + ' y1:' + rect.top + ' x2:' + rect.right + ' y2:' + rect.bottom + ' mousex:' + e.clientX + ' mousey:' + e.clientY)
                    if (! (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom)) {
                        selectedSymbol.classList.remove("framed");
                        selectedSymbols.delete(selectedSymbol);
                        selectedSymbol.selected = false;
                        selectedSymbol = null;
                    }
                });
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
            }
            if (activeSymbol) {
                activeSymbol.stopped = true;
                activeSymbol.style.cursor = "grab";
                if (activeSymbol.selected) {  // released after moving or released without moving for selection
                    if (!activeSymbol.classList.contains("framed")) {
                        activeSymbol.classList.add("framed");
                    }
                    selectedSymbols.add(activeSymbol);
                    console.log(`moving ${activeSymbol.moving} readyActive ${readyActive}`)
                    if (readyActive !== null && activeSymbol.moving) {
                        console.log('load the link into graph');
                        currentGraph.getSymbolConnections(readyTarget)[readyTargetSide].push([readyActive, readyActiveSide]);
                        currentGraph.getSymbolConnections(readyActive)[readyActiveSide].push([readyTarget, readyTargetSide]);
                    }
                    // console.log("frame add " + activeSymbol.elemId);
                } else {  // released without moving for cancelling selection
                    console.log("frame remove " + activeSymbol.elemId);
                    if (eyeButton.isActivated) {
                        eyeButton.isActivated = false;
                        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                    activeSymbol.classList.remove("framed");
                    selectedSymbols.delete(activeSymbol);
                }
                activeSymbol.moving = false;
                
                if (tabHeadersActivated[4]) await updateObjPosition(activeSymbol.dataset.id, parseFloat(activeSymbol.style.left), parseFloat(activeSymbol.style.top));
                if (activeSymbol) activeSymbol.stopped = false;
                
                activeSymbol = null;
                isGenerating = false;
            }

            if (activeEmoji) {
                activeEmoji.style.cursor = "grab";
                if (activeEmoji.selected) {
                    if (!activeEmoji.classList.contains("active")) {
                        activeEmoji.classList.add("active");
                    }
                    selectedEmoji = activeEmoji;
                } else {
                    activeEmoji.classList.remove("active");
                    selectedEmoji = null;
                }
                const emojiId = await activeEmoji.dataset.id;
                console.log(`emoji id ${emojiId}`);
                await updateObjPosition(emojiId, parseFloat(activeEmoji.style.left), parseFloat(activeEmoji.style.top));
                activeEmoji = null;
            }

            // Throw away the symbol into the swirl
            const rect = removeButton.getBoundingClientRect();
            if (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom) {
                if (selectedSymbols.size != 0) {
                    selectedSymbols.forEach(selectedSymbol => {
                        if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                        selectedSymbol.remove();
                    });
                }
            }
        });

        function getRandomSubset(words, count) {
            return words.sort(() => Math.random() - 0.5).slice(0, count);
        }
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function areSetsEqual(set1, set2) {
            if (set1.size !== set2.size) return false; // Different sizes → not equal
            for (let elem of set1) {
                if (!set2.has(elem)) return false; // If set2 is missing an element → not equal
            }
            return true;
        }

        // Function to create labels for selected symbols
        function showSimpleLabel() {
            let labelData = [];
            const foundIds = new Set();
            const elimBasic = new Set();  // we don't want basic-level symbols to connect to symbols that are much advanced than them
            const representatives = new Map();
            let hasDuplicateExpression = false;
            for (const [storedWord, [storedId, storedGraph]] of library) {
                let foundMatching = currentGraph.matchSubgraph(storedGraph);
                hasDuplicateExpression = areSetsEqual(foundMatching, selectedSymbols);
                if (foundMatching != null) {
                    let avgX = 0, avgY = 0;
                    var lastSymbol;
                    for (const symbol of foundMatching) {
                        let rect = symbol.getBoundingClientRect();
                        avgX += rect.left + rect.width / 2;6
                        avgY += rect.top + rect.height / 2;
                        lastSymbol = symbol;
                    }
                    representatives.set(lastSymbol, storedWord);
                    avgX /= foundMatching.size;
                    avgY /= foundMatching.size;
                    labelData.push([storedWord, avgX, avgY, lastSymbol]);
                    foundIds.add(storedId);
                    for (const symbol of foundMatching) {
                        elimBasic.add(symbol);
                    }
                }
            }

            selectedSymbols.forEach(selectedSymbol => {
                // Check if label already exists
                if (!selectedSymbol.querySelector('.symbol-label')) {
                    const words = symbolLabels[selectedSymbol.elemIdTrue][Number(selectedSymbol.isDynamic)].slice();
                    if (getDir(selectedSymbol) === 0 && !selectedSymbol.isDynamic) {
                        if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 3) words.push(...["right"]);
                        if (selectedSymbol.elemIdTrue === 4 || selectedSymbol.elemIdTrue === 6) words.push(...["left"]);
                        if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 4) words.push(...["barrier"]);
                    }
                    if (getDir(selectedSymbol) === 1) {
                        if (selectedSymbol.elemIdTrue === 1) {
                            if (selectedSymbol.isDynamic) {
                                words.push(...['gravity', 'fall', 'descend']);
                            } else {
                                words.push(...['top', 'roof', 'high', 'aloft']);
                            }
                        }
                        if (selectedSymbol.elemIdTrue === 3) {
                            if (!selectedSymbol.isDynamic) {
                                words.push(...['aerial', 'suspend', 'tall', 'float']);
                            }
                        }
                        if (selectedSymbol.elemIdTrue === 4) {
                            if (selectedSymbol.isDynamic) {
                                console.log('fly highhhhh');
                                words.push(...['ascend', 'rise', 'climb']);
                            } else {
                                words.push(...['low', 'ground', 'platform']);
                            }
                        }
                    }
                    let subset = getRandomSubset(words, 2);
                    let rect = selectedSymbol.getBoundingClientRect();
                    for (const word of subset) {
                        labelData.push([word, rect.left + rect.width / 2, rect.top + rect.height / 2, selectedSymbol]);
                    }
                }
            });


            labelData.forEach(labelDataSub => {
                const label = document.createElement('div');
                label.classList.add('symbol-label', 'removable');
                // Position the label near the symbol
                label.x = labelDataSub[1] + getRandomFloat(-100, 20);
                label.y = labelDataSub[2] + getRandomFloat(-30, 0);

                if (labelDataSub[3].labels === undefined) {
                    labelDataSub[3].labels = new Set([label]);
                } else {
                    labelDataSub[3].labels.add(label);
                }
                label.offsetX = label.x - parseFloat(labelDataSub[3].style.left);
                label.offsetY = label.y - parseFloat(labelDataSub[3].style.top);
                label.style.left = `${label.x}px`;
                label.style.top = `${label.y}px`;

                // Add event listener to remove label on click
                label.addEventListener('click', function () {
                    label.remove();
                });

                if (tabHeadersActivated[1]) tab1.appendChild(label);
                if (tabHeadersActivated[4]) tab4.appendChild(label);
                label.textContent = labelDataSub[0]; // Default text
                floatLabel(label);
            });
            return [foundIds, elimBasic, representatives, hasDuplicateExpression];
        }

        let rightMost;
        let topMost;

        // Function to create a text input near the symbol
        function showInput(foundIds, elimBasic, representatives, hasDuplicateExpression) {
            console.log(`foundIds starttt ${foundIds}`);
            rightMost = -document.documentElement.scrollWidth;
            topMost = 2 * document.documentElement.scrollHeight;
            const inputParent = selectedSymbols.values().next().value;
            selectedSymbols.forEach(selectedSymbol => {
                let rect = selectedSymbol.getBoundingClientRect();
                if (rect.right > rightMost) rightMost = rect.right;
                if (rect.top < topMost) topMost = rect.top;
            });

            const input = document.createElement('input');
            input.classList.add('label-input', 'removable');
            input.type = 'text';
            input.placeholder = "What word is this?";

            // Position the input near the symbol
            input.x = rightMost + 5;
            input.y = topMost - 2;
            input.offsetX = input.x - parseFloat(inputParent.style.left);
            input.offsetY = input.y - parseFloat(inputParent.style.top);
            input.style.left = `${input.x}px`;
            input.style.top = `${input.y}px`;

            inputParent.input = input;

            if (tabHeadersActivated[1]) tab1.appendChild(input);
            if (tabHeadersActivated[4]) tab4.appendChild(input);
            input.focus();

            const textarea = document.createElement('textarea');
            textarea.classList.add('label-textarea', 'removable');
            textarea.placeholder = 'Why?';
            
            // Position the textarea near the symbol
            textarea.x = rightMost + 5;
            textarea.y = topMost + 35;
            textarea.offsetX = textarea.x - parseFloat(inputParent.style.left);
            textarea.offsetY = textarea.y - parseFloat(inputParent.style.top);
            textarea.style.left = `${textarea.x}px`;
            textarea.style.top = `${textarea.y}px`;

            inputParent.textarea = textarea;

            if (tabHeadersActivated[1]) tab1.appendChild(textarea);
            if (tabHeadersActivated[4]) tab4.appendChild(textarea);
            textarea.focus();

            // Adjust height dynamically as user types
            textarea.addEventListener('input', function () {
                textarea.style.height = 'auto'; // Reset height first
                textarea.style.height = `${textarea.scrollHeight}px`; // Set new height based on content
                submitButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
            });

            // Create the submit button
            const submitButton = document.createElement("button");
            submitButton.classList.add("submit-button", 'removable');
            submitButton.innerHTML = "✔"; // Checkmark icon
            
            submitButton.x = rightMost + 5;
            submitButton.y = topMost + 43 + textarea.scrollHeight;
            submitButton.offsetX = submitButton.x - parseFloat(inputParent.style.left);
            submitButton.offsetY = submitButton.y - parseFloat(inputParent.style.top);
            submitButton.style.left = `${submitButton.x}px`; // Position to the right of the textbox
            submitButton.style.top = `${submitButton.y}px`;

            inputParent.submitButton = submitButton;

            if (tabHeadersActivated[1]) {
                // Append elements to the document
                tab1.appendChild(input);
                tab1.appendChild(textarea);
                tab1.appendChild(submitButton);
            }
            if (tabHeadersActivated[4]) {
                // Append elements to the document
                tab4.appendChild(input);
                tab4.appendChild(textarea);
                tab4.appendChild(submitButton);
            }

            let word;
            let definition;
            let justification;

            // Handle button click event
            submitButton.onclick = async function () {
                word = input.value;

                // Recalculate the molecule to incorporate the advanced vocabulary
                triggerLongPress(selectedSymbols.values().next().value, representatives);

                definition = moleculeString;
                justification = textarea.value;

                console.log(`word ${word} definition ${definition} justification ${justification}`); // Handle submission logic here
                //input.remove();
                //textarea.remove();

                submitButton.remove();
                input.readOnly = true;
                textarea.readOnly = true;

                if (!word || !definition || !justification) {
                    showFeedback('Please fill in all fields!', true);
                    return;
                }

                if (library.has(word)) {
                    showFeedback('You have already defined the word!', true);
                    return;
                }

                if (hasDuplicateExpression) {
                    showFeedback('You have already used this expression for defining another word!', true);
                    return;
                }

                const backgroundKnowledge = `You are a helpful assistant who validates expressions created by the user in a conlang. Don't have to be very strict as long as the expression makes sense intuitively. Answer Yes or No and explain why or why not. Make your answer concise.
While the user may use custom vocabulary, the basic symbols in this conlang are:
- ġ means empty, medium, place
- ċ means still, calm, fixed
- g horizontal means protect, constrain, right, barrier
- g vertical means protect, constrain, top, roof, high, aloft
- c horizontal means come, pull, retreat
- c vertical means come, pull, retreat, gravity, fall, ascend
- r means center, middle, inner, occupy, point, individual, barrier, obstacle, unit
- l means separate, source, spread, explode, radiate
- v horizontal means latent, hidden, unsupported, supple, bloated, right
- v vertical means latent, hidden, unsupported, supple, bloated, aerial, suspend, tall, float
- f means decay, leak, discard, shed, loosen, let go
- d horizontal means base, carry, load, deep, left, barrier
- d vertical means low, ground, platform, deep, base, carry, load
- t horizontal means go, push, advance
- t vertical means go, push, ascend, rise, climb
- b means gap, contain, enclosure, shell, surround
- p means join, combine, close, squeeze, attach
- s horizontal means heap, pile, hill, stub, incomplete, recess, cavity, blade, sharp, shallow, exposed, left
- s vertical means heap, pile, hill, stub, incomplete, recess, cavity, blade, sharp, shallow, exposed
- z means depart, give, express
- ṡ means full, substance, complete, large
- ż means chaotic, turmoil, unrest, hustle, activity, bustle, dynamic, vibrancy
- n means monotonous, homogeneous, same, normal, substance
- m means complex, system, order, organic, intricate, variegated`;

                const prompt = `
                    Word: ${word}
                    Definition: ${definition}
                    Justification: ${justification}

                    Based on the provided background knowledge, is this definition intuitive? Yes or No. Explain why or why not.
                `;

                try {
                    // Send request to OpenAI's chat API endpoint
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',  // You can use gpt-4 or gpt-3.5-turbo depending on your plan
                            messages: [
                                { role: 'system', content: backgroundKnowledge },
                                { role: 'user', content: prompt }
                            ],
                            max_tokens: 150,
                            temperature: 0.7
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const validationResponse = data.choices[0].message.content.trim();

                    // Display the response from the model
                    showFeedback(validationResponse, false);
    
                } catch (error) {
                    console.error('Error:', error);
                    alert('There was an error processing your request.');
                }
            };


            function showFeedback(feedback, manualFailed=false){
                console.log(`foundIds init ${foundIds}`);
                // Create the div element
                const outputBox = document.createElement("div");
                outputBox.classList.add("typing-effect", 'removable');

                // Create the p element
                const pElement = document.createElement("p");
                pElement.x = rightMost + 5;
                pElement.y = parseFloat(textarea.style.top) - 10 + textarea.scrollHeight;
                console.log(`scroll ${textarea.scrollHeight}`);

                pElement.offsetX = pElement.x - parseFloat(inputParent.style.left);
                pElement.offsetY = pElement.y - parseFloat(inputParent.style.top);
                pElement.style.left = `${pElement.x}px`; // Position to the right of the textbox
                pElement.style.top = `${pElement.y}px`;

                inputParent.pElement = pElement;

                // Create a span element to hold the text (so the cursor stays at the end)
                const textSpan = document.createElement("span");
                textSpan.id = "typingText";
                pElement.appendChild(textSpan);

                // Create a cursor span element
                const cursorSpan = document.createElement("span");
                cursorSpan.id = "cursor";
                cursorSpan.textContent = "|"; // Cursor symbol
                pElement.appendChild(cursorSpan);

                // Append the p element to the div element
                outputBox.appendChild(pElement);

                // Append the div element to the body of the document
                if (tabHeadersActivated[1]) tab1.appendChild(outputBox);
                if (tabHeadersActivated[4]) tab4.appendChild(outputBox);

                const text = feedback;
                let index = 0;
                const speed = 10; // Speed of typing in milliseconds
                const maxLineLen = 20;
                let lineIndex = 0;
                let passed;

                function type(onComplete) {
                    if (document.getElementById("typingText") !== null) {
                        if (index < text.length) {
                            if (lineIndex < Math.floor(document.getElementById("typingText").innerHTML.length / maxLineLen) && text.charAt(index) === ' ') {
                                document.getElementById("typingText").innerHTML += '\n';
                                console.log('erer')
                                console.log(Math.floor(document.getElementById("typingText").innerHTML.length / maxLineLen));
                                lineIndex++;
                            }
                            document.getElementById("typingText").innerHTML += text.charAt(index);
                            index++;
                            setTimeout(() => type(onComplete), speed);
                        } else {
                            if (text.includes("Yes")) {
                                passed = true;
                            } else {
                                passed = false;
                            }
                            if (onComplete) onComplete(passed);
                        }
                    }
                }

                function showDoneButton(passed) {
                    console.log(`foundIds ${foundIds}`);

                    const doneButton = document.createElement("button");
                    doneButton.classList.add("submit-button", "removable");
                    if (passed) {
                        doneButton.innerHTML = "✔"; // Checkmark icon
                    } else {
                        doneButton.innerHTML = "✘"; // Checkmark icon
                    }
                    
                    doneButton.x = rightMost + 5; // Position to the right of the textbox
                    doneButton.answerHeight = (lineIndex + 2) * 24;
                    doneButton.y = parseFloat(pElement.style.top) + doneButton.answerHeight;

                    doneButton.offsetX = doneButton.x - parseFloat(inputParent.style.left);
                    doneButton.offsetY = doneButton.y - parseFloat(inputParent.style.top);
                    doneButton.style.left = `${doneButton.x}px`; // Position to the right of the textbox
                    doneButton.style.top = `${doneButton.y}px`;

                    inputParent.doneButton = doneButton;
                    console.log(doneButton.style.left);
                    console.log(doneButton.style.top);

                    if (tabHeadersActivated[1]) tab1.appendChild(doneButton);
                    if (tabHeadersActivated[4]) tab4.appendChild(doneButton);

                    doneButton.onclick = async function () {
                        if (passed && !manualFailed) {
                            clearInterval(activeTabInterval);

                            tabHeaders[2].classList.add('tab-active');

                            activeTabInterval = setInterval(() => {
                                tabHeaders[2].classList.toggle('tab-active');
                            }, 1000); // Adjust timing as needed (1s cycle: 0.5s fade in, 0.5s fade out)

                            let storedGraph = new SymbolGraph();
                            for (const symbol of selectedSymbols) {
                                let connections = currentGraph.getSymbolConnections(symbol);
                                storedGraph.addSymbol(symbol, connections);
                            }
                            let id = await synthNode(selectedSymbols, word, justification, foundIds, elimBasic);
                            library.set(word, [id, storedGraph]);
                            console.log('library');
                            console.log(library);
                        }
                        if (eyeButton.isActivated) {
                            eyeButton.isActivated = false;
                            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                    }
                }

                type(showDoneButton);
            }
        }
        


        function startLongPress(left, top, width, height, symbol=null, node=null) {
            ring = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        // Append the circle to the SVG
            ring.appendChild(circle);
            if (tabHeadersActivated[1]) tab1.appendChild(ring);
            if (tabHeadersActivated[4]) tab4.appendChild(ring);
            
            const symbolCenterX = left + width / 2;
            const symbolCenterY = top + height / 2;

            // Create the SVG element with the desired attributes
            
            ring.style.left = symbolCenterX - 25;
            ring.style.top = symbolCenterY - 25;
            ring.setAttribute("class", "progress-ring");
            ring.setAttribute("width", "50");
            ring.setAttribute("height", "50");
            ring.setAttribute("viewBox", `${symbolCenterX - 27} ${symbolCenterY - 27} 54 54`);

            // Create the circle element

            circle.setAttribute("cx", symbolCenterX.toString());
            circle.setAttribute("cy", symbolCenterY.toString());

            if (symbol === null) {
                circle.setAttribute("r", width.toString());
            } else {
                circle.setAttribute("r", "25");
            }
            circle.setAttribute("stroke-width", "5");
    
            ring.style.visibility = "visible";

            circle.style.stroke = "#00B0F0";
            progress = 0;
            circle.style.strokeDashoffset = 157; // Reset
            interval = setInterval(() => {
                progress += 1;
                const offset = 157 * (1 - progress / totalSteps); // More precise calculation
                circle.style.strokeDashoffset = offset;
        
                if (progress >= totalSteps) {
                    clearInterval(interval);
                    if (symbol === null) {
                        triggerLongPressNode(node);
                    } else {
                        triggerLongPress(symbol);
                    }
                }
            }, 10);
        }
    
        function endLongPress() {
            if (ring !== null && circle !== null) {
                clearInterval(interval);
                ring.style.visibility = "hidden";
                circle.style.strokeDashoffset = 157;
                circle.style.stroke = "transparent";
                ring = null;
                circle = null;
            }
        }
    
        function triggerLongPress(symbol, representatives=null) {
            if (circle !== null) {
                circle.style.stroke = "#FFC000";
            }
            moleculeString = "";

            let results = getMolecule(symbol, new Set([]), representatives=representatives);
            selectedSymbols = results.visited;
            if (results.leftStr !== "") moleculeString += results.leftStr + " - "
            moleculeString += results.centerStrs.join(" & ");
            if (results.rightStr !== "") moleculeString += " - " + results.rightStr
            console.log(`resultssss left ${results.leftStr} center ${results.centerStrs} right ${results.rightStr}`);

            selectedSymbols.forEach(selectedSymbol => {
                selectedSymbol.selected = true;
                if (!selectedSymbol.classList.contains("framed")) {
                    console.log(`add ${selectedSymbol}`);
                    selectedSymbol.classList.add("framed");
                }
            });
            console.log(`molecule ${moleculeString}`);
        }

        // Create a new copy of the symbol being clicked
        async function createSymbolCopy(mouseX, mouseY, elemId = -1, symbolX=null, symbolY=null, symbolColor=null, symbolAngle=null, symbolId=null) {
            let offsetX = symbolWidth * symbolScale / 2;
            let offsetY = symbolHeight * symbolScale / 2;
            // Create the copy
            const symbol = document.createElement('div');
            symbol.ondragstart = (e) => e.preventDefault();
            symbol.selected = false;
            symbol.moving = false;
            symbol.stopped = false;
            symbol.angle = 0;
            symbol.isDynamic = false;
            symbol.classList.add('symbol');
            symbol.elemId = elemId;
            symbol.elemIdTrue = symbol.elemId;
            symbol.innerHTML = symbolData[symbol.elemId];
            if (symbolX) {
                symbol.style.left = `${symbolX}px`;
                symbol.style.top = `${symbolY}px`;
            } else {
                symbol.style.left = `${mouseX - offsetX}px`;
                symbol.style.top = `${mouseY - offsetY}px`;
            }
            if (symbolColor) {
                dyeColor(symbol, symbolColor);
            } else if (tabHeadersActivated[4]) {
                symbolColor = await assignUserColor();
                console.log(symbol);
                console.log(symbolColor);
                dyeColor(symbol, symbolColor);
            }
            if (symbolAngle) {
                await rotateSymbol(symbol, symbolAngle);
            }
            symbol.dot = null;
    

            // Add pressing event listener to the symbol
            symbol.addEventListener("mousedown", (e) => {
                if (activeSymbol !== null) {
                    console.log(`active symbol ${activeSymbol.elemId}`);
                }
                console.log(`symbol ${symbol.elemId}`);

                activeSymbol = symbol; // becomes active when being clicked on
                selectedSymbols.forEach(selectedSymbol => {
                    if (selectedSymbol !== null && selectedSymbol !== symbol) { // hide all the frame of all symbols except for the current symbol
                        selectedSymbol.selected = false;
                        selectedSymbol.classList.remove("framed");
                        selectedSymbols.delete(selectedSymbol);
                        if (eyeButton.isActivated) {
                            eyeButton.isActivated = false;
                            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                        if (eyeButton2.isActivated) {
                            eyeButton2.isActivated = false;
                            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                    }
                });
                symbol.offsetX = e.clientX - symbol.offsetLeft;
                symbol.offsetY = e.clientY - symbol.offsetTop;
                symbol.selected = !symbol.selected;
                symbol.style.cursor = "grabbing";
                startLongPress(parseFloat(symbol.style.left), parseFloat(symbol.style.top), symbolWidth * symbolScale, symbolHeight * symbolScale, symbol);
                // console.log("mouse down " + activeSymbol.elemId);
            });


            /* if horizontal: left, right, top perpendicular, bottom perpendicular, top parallel, bottom parallel */
            /* if vertical: top, down, left perpendicular, right perpendicular, left parallel, right parallel */
            currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

            console.log(tabHeadersActivated);
            if (tabHeadersActivated[1]) tab1.appendChild(symbol);
            if (symbolX || tabHeadersActivated[4]) {
                tab4.appendChild(symbol);
            }

            if (selectedSymbols.size !== 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    selectedSymbol.selected = false;
                    selectedSymbol.classList.remove("framed");
                    selectedSymbols.delete(selectedSymbol);
                });
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }                
            }
            if (symbolX === null) {
                activeSymbol = symbol;
            }
            symbol.offsetX = offsetX;
            symbol.offsetY = offsetY;

            if (tabHeadersActivated[4] || symbolX!==null) {
                // Get div attributes
                const symbolPacket = {
                    id:elemId,
                    color:symbolColor,
                    angle:0,
                    dotX:null,
                    dotY:null
                };
                console.log(symbol);

                if (symbolId !== null) {
                    symbol.dataset.id = symbolId;
                } else {
                    symbol.dataset.id = await saveObj("symbol", symbolPacket, parseFloat(symbol.style.left), parseFloat(symbol.style.top));
                }
            }
            return symbol;
        }

        // Find all the symbols that are connected to one symbol
        function getMolecule(currentSymbol, visited, representatives=null) {
            visited.add(currentSymbol);

            console.log(`visit`);
            console.log(visited);
            console.log(currentSymbol);
            let leftStr = "";
            let centerStrs = [getMoleculeChar(currentSymbol)];
            console.log(`representatives`);
            console.log(representatives);
            if (representatives != null && representatives.has(currentSymbol)) {
                centerStrs.push(representatives.get(currentSymbol));
            }

            let rightStr = "";
            for (let i = 0; i < currentGraph.getSymbolConnections(currentSymbol).length; i++) {  // every magnet point
                for (const entry of currentGraph.getSymbolConnections(currentSymbol)[i]) {  // entry = [every other symbol connected to my magnet point, its magnet point]
                    if (!visited.has(entry[0])) {
                        let results = getMolecule(entry[0], visited, representatives=representatives);
                        visited = results.visited;
                        console.log(`entry[0] ${entry[0].elemId} entry[1] ${entry[1]}`);
                        if (entry[1] > 1 || i > 1) {
                            if (leftStr !== "" && results.leftStr !== "") {
                                leftStr = "(" + leftStr + ") & (" + results.leftStr + ")";
                            } else if (leftStr == "") {
                                leftStr = results.leftStr;
                            }
                            centerStrs.push(...results.centerStrs);
                            if (rightStr !== "" && results.rightStr !== "") {
                                rightStr = "(" + rightStr + ") & (" + results.rightStr + ")";
                            } else if (rightStr == "") {
                                rightStr = results.rightStr;
                            }
                            console.log(`me ${currentSymbol.elemId} entry[0] ${entry[0].elemId} centerStrs ${centerStrs.join(" & ")}`);
                        } else {
                            if (i === 0) {
                                if (results.leftStr !== "") leftStr += results.leftStr + " - "
                                leftStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") leftStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} left entry[0] ${leftStr} centerStrs ${centerStrs.join(" & ")}`);
                            } else if (i === 1) {
                                if (results.leftStr !== "") rightStr += results.leftStr + " - "
                                rightStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") rightStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} right entry[0] ${rightStr} centerStrs ${centerStrs.join(" & ")}`);
                            }
                        }

                    }
                }
            }
            console.log(`me ${currentSymbol.elemId}`);
            console.log(`left ${leftStr} center ${centerStrs.join(" & ")} right ${rightStr}`)
            console.log(`visited ${visited.size}`);
            return {visited: visited, leftStr: leftStr, centerStrs: centerStrs, rightStr: rightStr};
        }

        function getMoleculeChar(symbol) {
            const table = ['ġ', 'ċ', 'g', 'c', 'r', 'l', 'v', 'f', 'd', 't', 'b', 'p', 's', 'z', 'ṡ', 'ż', 'n', 'm'];
            let char = table[symbol.elemIdTrue * 2 + Number(symbol.isDynamic)];
            if (char === 'g' || char === 'c' || char === 'v' || char === 'd' || char === 't' || char === 's') {
                if (symbol.angle === 0 || symbol.angle === 180) {
                    char += ' horizontal';
                } else {
                    char += ' vertical';
                }
            }
            return char;
        }

        // Check for snapping connections
        function checkConnections(active) {
            let targetX;
            let targetY;
            readyActive = null;
            readyTarget = null;
            readyActiveSide = null;
            readyTargetSide = null;
            for (const target of currentGraph.getSymbols()) {
                if (target === active) continue; // Skip the active symbol itself
                const activeJunctions = getAbsJunctions(active);
                const targetJunctions = getAbsJunctions(target);

                targetJunctions.forEach((targetCoord, index) => {
                    switch (index) {
                        case 0: // connected at the left / top start
                            if (getDir(active) === getDir(target)) { // active right >=< target left
                                snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 0);
                            } else {
                                const [first, second, , fourth] = activeJunctions;  // valid coordinates for connecting
                                snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, 0, 0, '始');
                                if (getDir(active) === 0) {  // target 
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, 1, 0, '始');
                                } else {
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y + calY, 1, 0, 'heihei');
                                }
                                snapToSymbol(active, target, fourth.x, fourth.y, targetCoord.x, targetCoord.y, 3, 0, '始');
                            }
                            break;
                        case 1:  // connected at the right / bottom end
                            if (getDir(active) === getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, 0, 1, "snap to the right");
                            } else {
                                const [first, second, third] = activeJunctions.slice(0, 3);  // valid coordinates for connecting
                                if (getDir(active) === 1) {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, 0, 1, '末');
                                } else {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y - calY, 0, 1, 'meimei');
                                }
                                snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, 1, 1, '末');
                                snapToSymbol(active, target, third.x, third.y, targetCoord.x, targetCoord.y, 2, 1, '末');
                            }
                            break;
                        case 2:  // perpendicular: inserted at the top / left center
                            if (getDir(active) !== getDir(target)) {
                                if (getDir(active) === 0) {  // horizontal active inserted on vertical target 上
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 2, "卜");
                                } else {
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 2, "上");
                                }
                            }
                            break;
                        case 3:  // perpendicular: inserted at bottom / right center 下
                            if (getDir(active) !== getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, 0, 3, "下");
                            }
                            break;
                    }
                });

                if (getDir(active) === getDir(target)) {  // parallel
                    if (getDir(active) === 0) {
                        targetX = parseInt(target.style.left);
                        targetY = parseInt(target.style.top) - (symbolHeight - 7) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[4].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 5, 4);
                        }
                        targetY = parseInt(target.style.top) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[3].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 4, 5);
                        }
                    }
                    if (getDir(active) === 1) {
                        targetX = parseInt(target.style.left) - (symbolHeight - 7) * symbolScale;
                        targetY = parseInt(target.style.top);
                        if (currentGraph.getSymbolConnections(target)[0].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 5, 4);
                        }
                        targetX = parseInt(target.style.left) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[1].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 4, 5);
                        }
                    }
                }
            }
        }

        // Get the offset for the symbol when connected to another symbol (side 0 = left, 1 = right)
        function getRelJunctions(symbol) {
            let junctions; // [start, end, middle_1, middle_2]
            switch (symbol.elemId) {
                case 0:
                    junctions = [{x: 1, y: 13}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 1:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 2:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 14}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 3:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 4:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 5:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 6:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 7:
                    junctions = [{x: 1, y: 32}, {x: symbolWidth - calX, y: 32}, {x: symbolWidth / 2, y: 3}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 8:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
            }
            return junctions;
        }

        function getAbsJunctions(symbol) {
            const relJunctions = getRelJunctions(symbol);
            const rect = symbol.getBoundingClientRect();
            let absJunctions;
            if (symbol.angle === 0) {
                absJunctions = [{x: rect.left + relJunctions[0].x * symbolScale, y: rect.top + relJunctions[0].y * symbolScale},
                                {x: rect.left + relJunctions[1].x * symbolScale, y: rect.top + relJunctions[1].y * symbolScale},
                                {x: rect.left + relJunctions[2].x * symbolScale, y: rect.top + relJunctions[2].y * symbolScale},
                                {x: rect.left + relJunctions[3].x * symbolScale, y: rect.top + relJunctions[3].y * symbolScale}];
            }
            if (symbol.angle === 180) {
                absJunctions = [{x: rect.right - relJunctions[1].x * symbolScale, y: rect.bottom - relJunctions[1].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[0].x * symbolScale, y: rect.bottom - relJunctions[0].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[3].x * symbolScale, y: rect.bottom - relJunctions[3].y * symbolScale},
                                {x: rect.right - relJunctions[2].x * symbolScale, y: rect.bottom - relJunctions[2].y * symbolScale}];
            }
            if (symbol.angle === 90) {
                absJunctions = [{x: rect.right - relJunctions[0].y * symbolScale, y: rect.top + relJunctions[0].x * symbolScale},
                                {x: rect.right - relJunctions[1].y * symbolScale, y: rect.top + relJunctions[1].x * symbolScale},
                                {x: rect.right - relJunctions[3].y * symbolScale, y: rect.top + relJunctions[3].x * symbolScale},
                                {x: rect.right - relJunctions[2].y * symbolScale, y: rect.top + relJunctions[2].x * symbolScale}];
            }
            if (symbol.angle === 270) {
                absJunctions = [{x: rect.left + relJunctions[1].y * symbolScale + calInvY, y: rect.bottom - relJunctions[1].x * symbolScale},
                                {x: rect.left + relJunctions[0].y * symbolScale + calInvY, y: rect.bottom - relJunctions[0].x * symbolScale},
                                {x: rect.left + relJunctions[2].y * symbolScale, y: rect.bottom - relJunctions[2].x * symbolScale},
                                {x: rect.left + relJunctions[3].y * symbolScale, y: rect.bottom - relJunctions[3].x * symbolScale}];
            }
            if (symbol.elemId === 2) {
                if (symbol.angle === 0) {
                    absJunctions[2].x += calCan1;
                    absJunctions[3].x += calCan1;
                }
                if (symbol.angle === 270) {
                    absJunctions[2].y -= calCan1;
                    absJunctions[3].y -= calCan1;
                }
                if (symbol.angle === 90) {
                    absJunctions[2].y -= calCan2;
                    absJunctions[3].y -= calCan2;
                }
                if (symbol.angle === 180) {
                    absJunctions[2].x += calCan2;
                    absJunctions[3].x += calCan2;
                }
            }

            return absJunctions;
        }

        function getDist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function getDir(symbol) {
            if (symbol.angle === 0 || symbol.angle === 180) {
                return 0;  // horizontal
            }
            if (symbol.angle === 90 || symbol.angle === 270) {
                return 1;  // vertical
            }
        }


        // Snap active symbol to target
        function snapToSymbol(active, target, activeX, activeY, targetX, targetY, activeSide, targetSide, msg = "") {
            if (targetSide > 1 && currentGraph.getSymbolConnections(target)[targetSide].length > 0) {  // if trying to connect to 2, 3, 4, or 5, and there is already an element occupying
                console.log(`targetSide ${targetSide} length ${currentGraph.getSymbolConnections(target)[targetSide].length}`);
                return;
            }
            if (currentGraph.getSymbolConnections(target)[targetSide].length !== 0) {
                let hasOverlap = false;
                for (const entry of currentGraph.getSymbolConnections(target)[targetSide]) {
                    if (getDir(entry[0]) === getDir(active) && entry[1] === activeSide) {
                        hasOverlap = true;
                    }
                }
                if (hasOverlap) {
                    // console.log('hasOverlap');
                    return;
                }
            }
            if (getDist(activeX, activeY, targetX, targetY) < SNAP_DISTANCE) {
                const newX = parseInt(active.style.left) + targetX - activeX;
                const newY = parseInt(active.style.top) + targetY - activeY;
                if (msg !== "") {
                    console.log(`${msg} activeX: ${activeX} activeY: ${activeY} targetX: ${targetX} targetY: ${targetY}`);
                }
                active.style.left = `${newX}px`;
                active.style.top = `${newY}px`;
                // complete the linkage only when the mouse is released from the active symbol
                readyActive = active;
                readyTarget = target;
                readyActiveSide = activeSide;
                readyTargetSide = targetSide;
                console.log(`link detected active side ${readyActiveSide} target side ${readyTargetSide}`);
            }
        }

        // Add an event listener for clicks on the document
        document.addEventListener("click", (event) => {
            // Get the mouse coordinates
            const x = event.clientX; // X-coordinate relative to the viewport
            const y = event.clientY; // Y-coordinate relative to the viewport

            // Print the coordinates to the console
            console.log(`Mouse clicked at: X = ${x}, Y = ${y}`);
            console.log(currentGraph);
        });


        /* Library */
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;
        let nodeTextBoxes = {};
        let container = document.getElementById("network");
        let data = {nodes: nodes, edges: edges};
        let basicNodes = new Set();
        let options = {
            nodes: {
                shape: "circularImage",
                borderWidth: 3,
                color: {
                    border: "black",
                    background: "white",
                    highlight: {
                        border: "black",
                        background: "#f0f0f0" // Light gray on hover
                    },
                    hover: {
                        border: "black",
                        background: "#e0e0e0" // Slightly darker gray on hover
                    }
                },
                shapeProperties: { useBorderWithImage: true },
                size: 20
            },
            edges: {
                smooth: false
            },
            physics: { enabled: true }
        };
        async function initNodes() {
            for (let i = 0; i < symbolData.length; i++) {
                let svgString = symbolData[i];
                let newNode = {
                    id: await generateUniqueId(svgString),
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    title: symbolTitles[i]
                };
                console.log(newNode['id']);
                nodes.add(newNode);
                basicNodes.add(newNode);
            }
            network = new vis.Network(container, data, options);
            network.once('afterDrawing', function () {
                // Assuming 'container' is the DOM element where the network is rendered
                let containerWidth = container.offsetWidth;
                let containerHeight = container.offsetHeight;
                let scale = 1.5;
                console.log(containerWidth, containerHeight)
                network.moveTo({
                    offset: {
                        x: (0.5 * containerWidth) * scale,
                        y: (0.5 * containerHeight) * scale
                    },
                    scale: scale
            });});
        }
        initNodes();


        function capitalizeFirstLetter(val) {
            return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }

        function scaleSVG(svgString, targetSize = 40) {
            // Parse SVG string
            let parser = new DOMParser();
            let doc = parser.parseFromString(svgString, "image/svg+xml");
            let svg = doc.documentElement;

            let viewBox = svg.getAttribute("viewBox");
            let width = parseFloat(svg.getAttribute("width"));
            let height = parseFloat(svg.getAttribute("height"));

            if (viewBox) {
                let [x, y, w, h] = viewBox.split(" ").map(parseFloat);
                width = w;
                height = h;
            }

            if (!width || !height) return svgString; // Fallback: return original SVG

            // Calculate scale factor
            let scale = (targetSize * 0.6) / Math.max(width, height); 

            // Calculate translation to center the scaled content
            let translateX = (targetSize - width * scale) / 2;
            let translateY = (targetSize - height * scale) / 2;

            // Apply transform
            let transform = `translate(${translateX}, ${translateY}) scale(${scale})`;

            // Wrap everything inside a group <g> element to apply transformations
            let group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("transform", transform);
            while (svg.firstChild) {
                group.appendChild(svg.firstChild);
            }
            svg.innerHTML = ""; // Clear original SVG
            svg.appendChild(group);

            // Set viewBox to match the target circle size
            svg.setAttribute("width", targetSize);
            svg.setAttribute("height", targetSize);
            svg.setAttribute("viewBox", `0 0 ${targetSize} ${targetSize}`);

            return new XMLSerializer().serializeToString(svg);
        }

        // Synthesize a node from its components and connect the component nodes to the synthesized node
        async function synthNode(components, word, justification, foundIds, elimBasic) {
            let leftMost = 2 * document.documentElement.scrollWidth;
            let rightMost = -document.documentElement.scrollWidth;
            let topMost = 2 * document.documentElement.scrollHeight;
            let bottomMost = -document.documentElement.scrollHeight;
            let rect;
            let svgString = "";
            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                if (rect.left < leftMost) leftMost = rect.left;
                if (rect.right > rightMost) rightMost = rect.right;
                if (rect.top < topMost) topMost = rect.top;
                if (rect.bottom > bottomMost) bottomMost = rect.bottom;

                if (symbol.dot != null) {
                    rect = symbol.dot.getBoundingClientRect();
                    if (rect.left < leftMost) leftMost = rect.left;
                    if (rect.right > rightMost) rightMost = rect.right;
                    if (rect.top < topMost) topMost = rect.top;
                    if (rect.bottom > bottomMost) bottomMost = rect.bottom;
                }
            });
            console.log(`left ${leftMost} right ${rightMost} top ${topMost} bottom ${bottomMost}`);
            const ratio = 49.92 / (symbolWidth * symbolScale);

            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                let transX;
                let transY;
                switch(symbol.angle) {
                    case 0: transX = rect.left; transY = rect.top; break;
                    case 90: transX = rect.right; transY = rect.top; break;
                    case 180: transX = rect.right; transY = rect.bottom; break;
                    case 270: transX = rect.left; transY = rect.bottom; break;
                }
                svgString += `<g transform="translate(` + ((transX - leftMost) * ratio).toString() + `, ` + ((transY - topMost) * ratio).toString()
                            + `) rotate(` + symbol.angle.toString() + `)">` + symbol.querySelector("svg").innerHTML + `</g>\n`;
                
                if (symbol.dot != null) {
                    console.log("added dot!");
                    rect = symbol.dot.getBoundingClientRect();
                    svgString += `<g transform="translate(` + ((rect.left - leftMost) * ratio).toString() + `, ` + ((rect.top - topMost) * ratio).toString()
                    + `)">` + dotDataMini + `</g>\n`;
                }
            });


            const widthStr = ((rightMost - leftMost) * ratio).toString();
            const heightStr = ((bottomMost - topMost) * ratio).toString();
            svgString = `<svg width="` + widthStr + `" height="` + heightStr
                        + `" viewBox="0 0 ` + widthStr + ` ` + heightStr + `" xmlns="http://www.w3.org/2000/svg">\n`
                        + svgString
                        +  `</svg>`;

            let id = await generateUniqueId(svgString);
            let hasDuplicate = false;
            nodes.forEach(node => {
                if (node['id'] === id) {
                    hasDuplicate = true;
                }
            });

            if (!hasDuplicate) {
                let newNode = {
                    id: id,
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    title: capitalizeFirstLetter(word) + ". " + capitalizeFirstLetter(justification)
                };
                
                nodes.add(newNode); // Add node to dataset
                for (const symbol of selectedSymbols) {
                    if (!elimBasic.has(symbol)) addEdge(await generateUniqueId(symbolData[symbol.elemIdTrue]), id);
                }
                for (const foundId of foundIds) {
                    addEdge(foundId, id);
                }
            }
            return id;
        }

        function addEdge(sourceId, targetId) {
            // Get all existing edges
            const existingEdges = edges.get();

            // Check if the edge already exists between the two nodes, in either direction
            const edgeExists = existingEdges.some(edge => {
                return (edge.from === sourceId && edge.to === targetId) || (edge.from === targetId && edge.to === sourceId);
            });

            if (!edgeExists) {
                edges.add({
                    from: sourceId,
                    to: targetId,
                    arrows: { to: { enabled: true } },
                    color: { color: "black" }
                });
                console.log(`link ${sourceId} ${targetId}`);
            }
        }

        async function generateUniqueId(svgString) {
            console.log(`used string ${svgString}`);
            // Ensure consistent encoding
            const encoder = new TextEncoder();
            const data = encoder.encode(svgString.trim());  // Trim to avoid whitespace inconsistencies

            // Compute SHA-256 hash
            const hashBuffer = await crypto.subtle.digest("SHA-256", data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));

            // Convert hash to a base64 string (URL-safe)
            return "svg-" + btoa(String.fromCharCode(...hashArray))
                .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")  // Remove padding
                .substring(0, 16); // Trim for shorter ID
        }


    </script>
</body>
</html>