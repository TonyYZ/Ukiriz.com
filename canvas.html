<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag and Connect Symbols</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f4f4f9;
            /* background-color: #262626; */
            /* background-color: #eef7f2; */
            /* background-color: #f9f1db; */
            font-family: Consolas;
            display: flex;
            height: 100vh; /* Full viewport height */
        }


        .symbol {
            position: absolute;
            width: 117px; /* Full width = 156 */
            height: 50.25px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
            z-index: 3;
            pointer-events: auto;
        }
        .symbol img {
            width: 100%;
            height: 100%;
        }

        .dot {
            position: absolute;
            width: 5px; /* Full width = 156 */
            height: 5px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
        }

        /* Highlight connections */
        .framed {
            outline: 2px solid #00B0F0;
        }


        /* Basic styles for the button */
        .button {
            position: fixed; /* Enables top and left positioning */
            background-size: contain; /* Ensure the image covers the entire button */
            background-repeat: no-repeat;
            background-position: center;
            border: none;
            border-radius: 5px; /* Optional: Makes the button rounded */
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.2s;
            z-index: 1;
        }

        /* Add hover effect */
        .button:hover {
            opacity: 0.5;
        }

        .logo {
            position: fixed;
            top: 30px;
            right: 10px;
            width: 250px;
            height: auto;
            margin-bottom: 0; /* fixed ÂÖÉÁ¥†‰∏çÈúÄË¶ÅËøô‰∏™ */
        }

        .wheel {
            position: fixed;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            z-index: 1;
        }


        /* Tab styles */
        .tab {
            color: white;
            text-align: center;
            line-height: 100px;
            font-size: 40px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            width: 280px;
            height: 100px; /* Make taller for rectangular shape */
            padding: 0; /* No extra padding */
            cursor: pointer;
            margin: 0px 0; /* Spacing between buttons */
            border-radius: 0; /* Remove rounded corners */
            transition: background-color 1s ease-in-out, opacity 1s ease-in-out;
            opacity: 0.5; /* Start at a slightly faded state */
        }

        .tab:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transition: background-color 0.3s;
        }

        .tab-active {
            background-color: rgba(255, 255, 255, 0.6);
            opacity: 1; /* Fully visible */
        }

        :root { --sidebar-w: 280px; }

        /* Vertical bar styles */
        .vertical-bar {
            position: fixed;
            top: 0;
            right: 0;
            width: var(--sidebar-w);
            height: 100%;
            background-color: #00B0F0; /* Blue background */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 200px;
            z-index: 99999;
        }

        /* Content container */
        .content {
            margin-left: auto; /* Push content to the left of the vertical bar */
            margin-right: var(--sidebar-w); /* Leave space for the vertical bar */
            flex: 1;
            padding: 20px;
            overflow-y: auto; /* Allows vertical scrolling */
            height: 100vh;
        }

        /* Content sections */
        .tab-content {
            display: none; /* Hide all content by default */
            height: 100%;
        }

        .tab-content.active {
            display: block; /* Show active tab content */
        }

        #craftCanvas {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #chatCanvas {
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        .marquee-box {
            position: absolute;
            background: transparent;
            pointer-events: none;
            z-index: 99999;
            outline: 10px dashed #00B0F0;
        }

        /* Color palette styles */
        .palette {
            position: fixed;
            display: flex;
            justify-content: center;
            margin: 20px auto;
            gap: 10px;
        }

        .color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ccc;
        }

        .color:hover {
            border: 2px solid black;
        }


        .progress-ring {
            position: absolute;
            width: 50px; /* Ensure this matches the SVG width */
            height: 50px; /* Ensure this matches the SVG height */
            transform: rotate(-90deg);
            visibility: hidden;
        }

        .progress-ring circle {
            fill: none;
            stroke: transparent;
            stroke-width: 5;
            stroke-dasharray: 157; /* Full circle length */
            stroke-dashoffset: 157; /* Start fully hidden */
            transition: stroke-dashoffset 0s, stroke 0s;
        }

        /* Style for the label */
        .symbol-label {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            cursor: pointer;
            z-index: 7;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }

        .symbol-label.active {
            border-width: 3px; /* Thicker border when clicked */
        }

        /* Style for the input box */
        .label-input {
            position: absolute;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            border-radius: 5px;
            z-index: 5;
        }

        /* Auto-resizing textarea */
        .label-textarea {
            position: absolute;
            width: 167px;
            min-height: 40px;
            max-width: 200px;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            border-radius: 5px;
            resize: none;
            overflow: hidden;
            z-index: 5;
        }

        /* Style the submit button */
        .submit-button {
            position: absolute;
            background-color: white; /* Green */
            color: black;
            border: 1px solid black;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            width: 27px;
            height: 27px;
            line-height: 27px;
            text-align: center;
            z-index: 5;
        }

        /* Hover effect */
        .submit-button:hover {
            opacity: 0.5;
        }


        .typing-effect p {
            position: absolute;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            display: inline-block;
            white-space: pre-line;
            line-height: 1.5; /* Adjusts spacing for smooth movement */
            overflow: hidden;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #message-input {
            position: absolute;
            bottom: 80px;
            left: 400px;
            padding: 10px;
            width: 400px;
            font-size: 30px; /* Larger font size */
            background-color: transparent; /* Transparent background */
            border: none; /* No border */
            color: black; /* Text color */
        }

        /* Style the placeholder text (prompt) */
        #message-input::placeholder {
            font-style: italic; /* Italicize the placeholder text */
            color: gray; /* Gray color for the placeholder */
        }

        #cursor {
            display: inline-block;
            margin-left: 1px;
            animation: blink 0.8s infinite;
            font-weight: bold;
            animation: blink 0.8s infinite;
        }


        .image-container {
            display: flex;
            justify-content: center;
        }
        .image-container img {
            width: 10%; /* 50% of the parent container */
            height: auto; /* Maintain aspect ratio */
        }

        .image-row {
            display: flex;         /* Align images in a row */
            justify-content: center; /* Center images horizontally */
            align-items: center;    /* Align images vertically */
            gap: 10px;             /* Space between images */
        }

        .image-row img {
            width: 20%;   /* Set a uniform width */
            height: auto;  /* Set a uniform height */
            object-fit: cover; /* Crop images to fit without stretching */
        }

        #network {
            width: 82vw;
            height: 100vh;
            border: none;
            background: transparent;
            box-shadow: none;
        }

        #world {
            position: relative;
            width: 82vw;
            height: 100vh;
            background: #f4f4f9;
            overflow: hidden;
            cursor: grab;
        }

        #world.dragging {
            cursor: grabbing;
        }

        #worldContent {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(0px, 0px);
            will-change: transform;
        }

        .island {
            position: absolute;
        }

        .island-block {
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 6px;
        }

        .island-highlight { display: none; }
        .island.selected .island-highlight { display: block; }

        #tab-header4 {
            display: none;
        }

        .no-text-select, .no-text-select * {
            user-select: none !important;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
    <div class="vertical-bar">
        <img src="./icons/iti.svg" alt="Logo" class="logo" id="logo">
        <div class="tab" id="tab-header0" onclick="showTab(0)">Home</div>
        <div class="tab" id="tab-header1" onclick="showTab(1)">Craft</div>
        <div class="tab" id="tab-header2" onclick="showTab(2)">Library</div>
        <div class="tab" id="tab-header3" onclick="showTab(3)">World</div>
        <div class="tab" id="tab-header4" onclick="showTab(4)">Chat</div>
    </div>

    <div class="content">
        <div class="tab-content" id="tab0">
            <p style="text-align: center"><h1>Divinatory Conlang on Canvas</h1></p>
            Welcome here! <br>
            Ever wondered how divination works? <br>
            The fortune tellers somehow comprehend the meaning behind random patterns, from Tarot suits to teacup dregs...<br> Maybe there is some divine spirit hidden behind. Maybe it's just because they know how to tell a story out of them.<br><br>
            Anyway, these people train their intuition to access the powerful knowledge on the other side.
            This online platform plays with this idea, trying to make YOU the fortune teller, but in a more general sense: you communicate with others by <br> producing and interpreting abstract symbols. <br>Instead of teaching you an entire symbolic language, I will help you build a language by yourself.<br>
            You may see how intuition can be built up step by step.<br>
            Note that your language's "atoms" are fixed, but how the "molecules" are structured is up to you.  <br>
            They are designed by me, which are inspired by the Yijing trigrams.
            <br>

            Here are the possible ways of combining the symbols:<br>

            <div class="image-row">
                <img src="./icons/sp.png"/>
            </div>
            <br>
            The symbols connected in "series" represent spatially <b>contiguous</b> relationships: above, below, adjacent to, outside, etc.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a traffic light = three lights lined in a row.<br>
                (2) a barn = a roof on top of a pile of grains.<br>
            </p>
            The symbols connected in "parallel" represent <b>composite</b> concepts.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a white rock = the composite of whiteness and hardness.<br>
                (2) a bullet = the composite of smallness and advancing.<br>
            </p>

            <br>
            <div class="image-row">
                <img src="./icons/granary.png"/> <img src="./icons/bullet.png"/>
            </div>
            <br>
            As you can see, as long as it makes sense to you, it should work because it is all about <b>intuitiveness!</b><br><br>

            When you are making words, make sure the magnets connect the symbols. Only symbols connected to each other count as a word.<br>
            To check this, you can long-click on a symbol, and the entire connected component it belongs to will be highlighted.<br><br>
            Then, click on the <b>insight</b> button that looks like an eye, and it will propose some meanings from what it sees.<br>
            You can learn what each basic symbol means by clicking on the <b>insight</b> button and reading different meaningful aspects of the symbols.<br>
            While we only have the nine basic symbols from the start, <b>insight</b> will see what you teach it to see over time.<br>
            A window will pop up to ask you to assign the word for your symbols and the reason behind this, and the system will check if it makes sense.<br>
            If so, the new word you created will be available in the library.<br><br>

            In the next tab, poke around the interface and see if you can piece together your own expression for the words <b>"sky," "rain," "flower," and "computer."</b><br>
            Remember, when you are making the expressions, try to attend to the symbols' meaning (by clicking the <b>insight</b> button) <br>
            rather than purely by their visual resemblance to the concepts!
            <br><br><br><br>

        </div>
        <div class="tab-content" id="tab1">

            <div id="craftCanvas"> </div>

            <div id="craftControls">
                <!-- Color palette -->

                <div class="palette" id="palette">
                    <div class="color" style="background-color: #5cb3cc;"></div>
                    <div class="color" style="background-color: #D00000;"></div>
                    <div class="color" style="background-color: #d6a01d;"></div>
                    <div class="color" style="background-color: white;"></div>
                    <div class="color" style="background-color: #3B3838;"></div>
                </div>
            </div>
          <p></p>
        </div>
        <div class="tab-content" id="tab2">
          <div id="network"></div>
        </div>
        <div class="tab-content" id="tab3">
          <div id="world">
              <div id="worldContent"></div>
          </div>
        </div>
        <div class="tab-content" id="tab4">
            <div id="chatCanvas"> </div>
            <div id="chatControls">
                <!-- Input box at the bottom of the page -->
                <input type="text" id="message-input" placeholder="Say something in emoji..." />
            </div>
          <p></p>
        </div>
    </div>

    <script type="module">
        const tabHeaders = [document.getElementById("tab-header0"), document.getElementById("tab-header1"), document.getElementById("tab-header2"), document.getElementById("tab-header3"), document.getElementById("tab-header4")];
        let tabHeadersActivated = [false, false, false, false, false];
        let activeTabInterval = null;
        let marqueeChatEnabled = false;
        let marqueeCraftEnabled = false;
        let worldData = null;
        let worldRendered = false;
        let worldPanningEnabled = false;
        let worldSelectionEnabled = false;

        // Switching between tabs
        window.showTab = function(tabIndex) {
            // Clear alpha animation
            clearInterval(activeTabInterval);
            tabHeaders.forEach(h => h.classList.remove("tab-active"));

            // Hide all tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Show the selected tab content
            const activeContent = document.getElementById(`tab${tabIndex}`);
            activeContent.classList.add('active');

            if (tabIndex === 3) {  // Load world map
                enableWorldPanning();
                renderWorld();
                enableIslandSelection();
            }

            if (tabIndex === 1 && !marqueeCraftEnabled) {
                enableMarqueeSelection({
                    canvasEl: document.getElementById("craftCanvas"),
                    itemSelector: ".symbol",
                    ignoreSelector: "#palette, .wheel, .button, .label-input, .label-textarea, .submit-button",
                    clearSelection: () => {
                        const activeTab = document.querySelector(".tab-content.active");
                        const existingInput = activeTab?.querySelector(".label-input");
                        if (!existingInput) {
                            clearAllSymbolSelection();
                        }
                    },
                    onSelect: (el) => {
                        el.classList.add("framed");
                        selectedSymbols.add(el);
                        el.selected = true;
                    }
                });
                marqueeCraftEnabled = true;
            }

            if (tabIndex === 4 && !marqueeChatEnabled) {
                enableMarqueeSelection({
                    canvasEl: document.getElementById("chatCanvas"),
                    itemSelector: ".symbol, .symbol-label",
                    ignoreSelector: ".wheel, .button, .label-input, .label-textarea, .submit-button",
                    clearSelection: () => {
                        clearAllSymbolSelection();
                        clearAllEmojiSelection();
                    },
                    onSelect: (el) => {
                        if (el.classList.contains("symbol")) {
                            el.classList.add("framed");
                            selectedSymbols.add(el);
                        } else if (el.classList.contains("symbol-label")) {
                            el.classList.add("active");
                            selectedEmojis.add(el);
                        }
                        el.selected = true;
                    }
                });

                marqueeChatEnabled = true;
            }

            // if have not selected an island, cannot open the chat
            if (tabIndex === 4 && !selectedIsland) {
                return;
            }

            for (let i = 0; i < 5; i++) {
                if (i === tabIndex) {
                    tabHeaders[i].style.opacity = 1;
                    tabHeadersActivated[i] = true;
                } else {
                    tabHeaders[i].style.opacity = 0.5;
                    tabHeadersActivated[i] = false;
                }
            }
        }

        // Initialize the first tab as active
        showTab(0);
        const tab0 = document.getElementById("tab0");
        const tab1 = document.getElementById("tab1");
        const tab2 = document.getElementById("tab2");
        const tab3 = document.getElementById("tab3");
        const tab4 = document.getElementById("tab4");

        const chatCanvas = () => document.getElementById("chatCanvas");
        const chatControls = () => document.getElementById("chatControls");
        const craftCanvas = () => document.getElementById("craftCanvas");
        const craftControls = () => document.getElementById("craftControls");

        function appendToChatCanvas(el) {
            chatCanvas()?.appendChild(el);
        }

        function appendToChatControls(el) {
            chatControls()?.appendChild(el);
        }

        function appendToCraftCanvas(el) {
            craftCanvas()?.appendChild(el);
        }

        function appendToCraftControls(el) {
            craftControls()?.appendChild(el);
        }


        let activeSymbol = null;
        let activeEmoji = null;
        let selectedSymbols = new Set();
        let selectedEmojis = new Set();
        let dragGroup = null;     // Map<elem, {dx, dy}>
        let dragLeader = null;    // activeSymbol or activeEmoji
        let isGenerating = false;
        let readyActive = null;
        let readyActiveSide = null;
        let readyTarget = null;
        let readyTargetSide = null;
        let clickOnlySymbol = null;
        let clickOnlyEmoji = null;
        let selectionClickHandled = false;

        window.getDebugState = () => ({
            dragGroup,
            dragLeader,
            dragSnapLock,
            pendingSnapDelta,
            currentRoomId,
        });

        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, setPersistence, browserLocalPersistence, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setDoc, getDoc, updateDoc, doc, deleteDoc, arrayRemove, serverTimestamp, arrayUnion } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDcnYVyHx8ZgE_kKquLctcA3Q5LuSagZUE",
            authDomain: "divinatoryconlang.firebaseapp.com",
            projectId: "divinatoryconlang",
            storageBucket: "divinatoryconlang.firebasestorage.app",
            messagingSenderId: "939674998709",
            appId: "1:939674998709:web:bbf228a108e046c8006bfc",
            measurementId: "G-GLFVN6M297"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        let currentRoomId = "default"; // default room (or null)

        const objsColRef = (roomId = currentRoomId) =>
        collection(db, "rooms", roomId, "objs");

        const objDocRef = (id, roomId = currentRoomId) =>
        doc(db, "rooms", roomId, "objs", id);


        // Function to Save Emoji
        async function saveObj(type, content, x, y) {
            const ownerUid = currentUser?.uid || null; // must have signed in already
            const docRef = await addDoc(objsColRef(), {
                type,
                content,
                x,
                y,
                ownerUid,            // ‚úÖ NEW
                createdAt: serverTimestamp?.() // optional, if you already import it
            });
            return docRef.id;
        }

        async function updateObjPosition(id, x, y) {
            if (!id || !currentRoomId) {
                return;
            }
            try {
                await updateDoc(objDocRef(id), { x, y });
            } catch (e) {
                if (e.code === "not-found") return; // doc Â∑≤Ë¢´Âà†/ÂàáÊàøÈó¥ÂØºËá¥ÔºåÂøΩÁï•
                    throw e;
            }
        }

        async function updateSymbolAngle(id, angle) {
            try {
                await updateDoc(objDocRef(id), {"content.angle": angle});
            } catch (e) {
                if (e.code === "not-found") return;
                throw e;
            }
        }

        async function updateSymbolElemId(id, elemId) {
            try {
                await updateDoc(objDocRef(id), {"content.elemId": elemId});
            } catch (e) {
                if (e.code === "not-found") return;
                throw e;
            }
        }

        async function persistLink(aId, aSide, bId, bSide) {
            if (!tabHeadersActivated[4]) return;

            // store on both documents
            const aRef = objDocRef(aId);
            const bRef = objDocRef(bId);

            await updateDoc(aRef, {
                links: arrayUnion({ otherId: bId, mySide: aSide, otherSide: bSide })
            });
            await updateDoc(bRef, {
                links: arrayUnion({ otherId: aId, mySide: bSide, otherSide: aSide })
            });
        }

        // Remove link on both docs: A -- B
        async function removeLink(aId, aSide, bId, bSide) {
        await updateDoc(objDocRef(aId), {
            links: arrayRemove({ otherId: bId, mySide: aSide, otherSide: bSide })
        }).catch(()=>{});

        await updateDoc(objDocRef(bId), {
            links: arrayRemove({ otherId: aId, mySide: bSide, otherSide: aSide })
        }).catch(()=>{});
        }

        async function removeLinksBeforeDelete(symbolId) {
            const ref = objDocRef(symbolId);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;

            const data = snap.data();
            const links = data.links || [];

            // Remove reverse link from each neighbor
            for (const lk of links) {
                const otherRef = objDocRef(lk.otherId);

                // Reverse record on neighbor: mySide/otherSide swap
                await updateDoc(otherRef, {
                links: arrayRemove({
                    otherId: symbolId,
                    mySide: lk.otherSide,
                    otherSide: lk.mySide
                })
                }).catch(() => {});
            }
        }

        // Load emojis on page load
        window.onload = loadObj;

        function generateColor(uid) {
            let hash = 0;
            for (let i = 0; i < uid.length; i++) {
                hash = uid.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = `hsl(${hash % 360}, 70%, 60%)`; // Hue varies, but saturation & lightness are fixed
            return color;
        }

        // Initialize Firebase Authentication
        const auth = getAuth();
        let currentUser = null;

        await setPersistence(auth, browserLocalPersistence);

        // Function to sign in anonymously & store user ID
        async function signInAnonymouslyPersistent() {
            try {
                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;

                // Store user ID in local storage
                localStorage.setItem("anonymousUID", currentUser .uid);

                console.log("Signed in as a guest:", currentUser .uid);
            } catch (error) {
                console.error("Error with anonymous sign-in:", error);
            }
        }

        let signingIn = false;

        function waitForAuth() {
            return new Promise((resolve, reject) => {
                const unsub = onAuthStateChanged(
                auth,
                async (user) => {
                    if (user) {
                    currentUser = user;
                    console.log("User is signed in:", user.uid);
                    unsub();
                    resolve(user);
                    return;
                    }

                    // user ‰∏∫ nullÔºöÂ∞ùËØïÂåøÂêçÁôªÂΩïÔºàÂè™ÂÅö‰∏ÄÊ¨°ÔºåÈÅøÂÖçÂæ™ÁéØÔºâ
                    if (signingIn) return;
                    signingIn = true;

                    try {
                    const cred = await signInAnonymously(auth); // ‚úÖ Áõ¥Êé•Áî®ÂÆòÊñπÊñπÊ≥ï
                    currentUser = cred.user;
                    console.log("Signed in anonymously:", currentUser.uid);

                    // ‚úÖ ËøôÈáåÁõ¥Êé• resolveÔºå‰∏çÂøÖÁ≠â‰∏ã‰∏ÄÊ¨° onAuthStateChanged
                    unsub();
                    resolve(currentUser);
                    } catch (e) {
                    unsub();
                    reject(e);
                    }
                },
                (err) => {
                    reject(err);
                }
                );
            });
        }

        // Function to restore previous session or sign in a new user
        async function restoreAnonymousSession() {
            return waitForAuth();
        }

        async function boot() {
            await restoreAnonymousSession();
            await initNodes();
        }

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", boot);
        } else {
            boot(); // ‚úÖ load Â∑≤ÁªèËøá‰∫ÜÂ∞±Áõ¥Êé•Ë∑ë
        }

        // Function to assign and store color if not already assigned
        async function assignUserColor() {
            const userRef = doc(db, "users", currentUser.uid); // Reference to user's Firestore document
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
                return userSnap.data().color; // Return existing color
            } else {
                const newColor = generateColor(currentUser.uid);
                await setDoc(userRef, { color: newColor });
                return newColor;
            }
        }

        function canEditElement(el) {
            const me = currentUser?.uid;
            if (!me) return false;

            const owner = el?.dataset?.ownerUid;

            // üîë Not yet saved ‚Üí treat as mine
            if (!owner) return true;

            return owner === me;
        }

        function getEditableSelectedSymbols() {
            return Array.from(selectedSymbols).filter(s => canEditElement(s));
        }

        function getEditableSelectedEmojis() {
            return Array.from(selectedEmojis).filter(e => canEditElement(e));
        }


        // Keep this map at module scope if you want
        let symbolById = new Map();

        // Function to Load emojis and symbols
        async function loadObj() {
            const querySnapshot = await getDocs(objsColRef());

            // Clear maps (important when switching rooms)
            symbolById = new Map();

            // 1) First pass: create DOM elements and register them
            for (const docSnap of querySnapshot.docs) {
                const data = docSnap.data();

                if (data.type === "emoji") {
                const el = await createEmoji(data.content, data.x, data.y, docSnap.id);
                el.dataset.ownerUid = data.ownerUid || "";
                continue;
                }

                if (data.type === "symbol") {
                const symbol = await createSymbolCopy(
                    null, null,
                    data.content.elemId,
                    data.content.elemIdTrue,
                    data.x, data.y,
                    data.content.color,
                    data.content.angle,
                    docSnap.id
                );

                symbol.dataset.ownerUid = data.ownerUid || "";

                // Register in id -> element map
                symbolById.set(docSnap.id, symbol);

                // IMPORTANT: ensure it exists in currentGraph with empty adjacency list
                currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

                // Restore dot if exists
                if (data.content.dotX !== null) {
                    symbol.isDynamic = true;
                    const dot = document.createElement("div");
                    dot.innerHTML = dotData;
                    dot.classList.add("dot");
                    symbol.dot = dot;
                    dot.parent = symbol;
                    dot.style.left = `${data.content.dotX}px`;
                    dot.style.top  = `${data.content.dotY}px`;
                    appendToChatCanvas(dot);
                }
                }
            }

            // 2) Second pass: rebuild links in currentGraph
            for (const docSnap of querySnapshot.docs) {
                const data = docSnap.data();
                if (data.type !== "symbol") continue;

                const a = symbolById.get(docSnap.id);
                if (!a) continue;

                const links = data.links || [];
                for (const lk of links) {
                const b = symbolById.get(lk.otherId);
                if (!b) continue; // neighbor not loaded (should be rare)

                // Avoid duplicates: only add one direction using id ordering
                if (docSnap.id < lk.otherId) {
                    const aConns = currentGraph.getSymbolConnections(a);
                    const bConns = currentGraph.getSymbolConnections(b);
                    if (!aConns || !bConns) continue;

                    aConns[lk.mySide].push([b, lk.otherSide]);
                    bConns[lk.otherSide].push([a, lk.mySide]);
                }
                }
            }
        }


        // Function to delete a document
        async function deleteObj(roomId, docId) {
            try {
                await deleteDoc(doc(db, "rooms", roomId, "objs", docId));
                console.log(`Document with ID ${docId} deleted successfully.`);
            } catch (error) {
                console.error("Error deleting document:", error);
            }
        }


        class PatternGraph {
            constructor() {
                this.nodes = []; // [{elemIdTrue,isDynamic,angle}]
                this.adj = [];   // adj[i][side] = [[j, jSide], ...]
            }

            addNode(info) {
                const idx = this.nodes.length;
                this.nodes.push(info);
                this.adj.push([[], [], [], [], [], []]);
                return idx;
            }

            addEdge(i, side, j, jSide) {
                this.adj[i][side].push([j, jSide]);
            }

            size() {
                return this.nodes.length;
            }
        }

        function serializePatternGraph(pattern) {
            if (!pattern) return null;

            // pattern can be a PatternGraph instance or a plain object with same shape
            const nodes = Array.isArray(pattern.nodes) ? pattern.nodes.map(n => ({
                elemIdTrue: n.elemIdTrue ?? null,
                isDynamic: !!n.isDynamic,
                angle: n.angle ?? 0,
            })) : [];

            const edges = [];

            // pattern.adj[i][side] = [[j, jSide], ...]
            const adj = Array.isArray(pattern.adj) ? pattern.adj : [];
            for (let i = 0; i < adj.length; i++) {
                const sides = Array.isArray(adj[i]) ? adj[i] : [];
                for (let side = 0; side < sides.length; side++) {
                    const list = Array.isArray(sides[side]) ? sides[side] : [];
                    for (const pair of list) {
                        if (!Array.isArray(pair) || pair.length < 2) continue;
                        const [j, jSide] = pair;

                        edges.push({
                            from: i,
                            fromSide: side,
                            to: j,
                            toSide: jSide
                        });
                    }
                }
            }

            return { nodes, edges };
        }

        function deserializePatternGraph(raw) {
            if (!raw || !Array.isArray(raw.nodes)) return null;

            const pg = new PatternGraph();

            for (const n of raw.nodes) {
                pg.addNode({
                    elemIdTrue: n.elemIdTrue,
                    isDynamic: !!n.isDynamic,
                    angle: n.angle ?? 0
                });
            }

            if (Array.isArray(raw.edges)) {
                for (const e of raw.edges) {
                    if (
                        typeof e?.from !== "number" ||
                        typeof e?.fromSide !== "number" ||
                        typeof e?.to !== "number" ||
                        typeof e?.toSide !== "number"
                    ) continue;

                    // Optional bounds check
                    if (e.from < 0 || e.from >= pg.nodes.length) continue;
                    if (e.to < 0 || e.to >= pg.nodes.length) continue;
                    if (e.fromSide < 0 || e.fromSide > 5) continue;
                    if (e.toSide < 0 || e.toSide > 5) continue;

                    pg.addEdge(e.from, e.fromSide, e.to, e.toSide);
                }
            }

            return pg;
        }

        class SymbolGraph {
            constructor() {
                this.map = new Map(); // Maps symbol to its adjacency list
            }

            addSymbol(symbol, connections) {
                this.map.set(symbol, connections); // connections = [[], [], (n, j), [], [], []]
            }

            getSymbolConnections(symbol) {
                return this.map.get(symbol) || null; // Return connections or null if not found
            }

            getSymbols() {
                return Array.from(this.map.keys()); // Return all symbols in the graph
            }

            hasSymbol(symbol) {
                return this.map.has(symbol);
            }

            // ‚úÖ Âà†Èô§ËäÇÁÇπ + Ê∏ÖÁêÜÊâÄÊúâÂºïÁî®ÂÆÉÁöÑËæπ
            removeSymbol(symbol) {
                if (!this.map.has(symbol)) return;

                // 1) ÂÖà‰ªéÊâÄÊúâÂÖ∂‰ªñËäÇÁÇπÁöÑÈÇªÊé•Ë°®‰∏≠ÁßªÈô§ÊåáÂêë symbol ÁöÑËæπ
                for (const [node, conns] of this.map.entries()) {
                if (node === symbol) continue;
                for (let side = 0; side < 6; side++) {
                    const arr = conns[side];
                    if (!Array.isArray(arr) || arr.length === 0) continue;

                    // ÊØè‰∏™ÂÖÉÁ¥†ÂΩ¢Â¶Ç [neighbor, neighborSide]
                    conns[side] = arr.filter(([nbr, _nbrSide]) => nbr !== symbol);
                }
                this.map.set(node, conns);
                }

                // 2) ÂÜçÂà†Èô§ symbol Ëá™Â∑±
                this.map.delete(symbol);
            }

            // ‚úÖ ÂèØÈÄâÔºöÊâπÈáèÊ∏ÖÁêÜÂ∑≤‰∏çÂú® DOM ‰∏≠ÁöÑËäÇÁÇπÔºàÈò≤Âæ°ÊÄßÔºâ
            pruneDetachedSymbols() {
                for (const sym of this.map.keys()) {
                    if (!sym || !sym.isConnected) {
                        this.removeSymbol(sym);
                    }
                }
            }

            doesMatch(storedGraph, currSymbol, matchedSymbols) {
                if (matchedSymbols.size === storedGraph.map.size) return true; // Full match found

                for (let [storedSymbol] of storedGraph.map.entries()) {
                    if (matchedSymbols.has(storedSymbol)) continue; // Already matched

                    if (this.isSymbolMatch(currSymbol, storedSymbol)) {
                        console.log(`Matching: ${currSymbol.elemIdTrue} ‚Üî ${storedSymbol.elemIdTrue}`);
                        matchedSymbols.set(storedSymbol, currSymbol);

                        let isValid = true;

                        // Check all six sides
                        for (let i = 0; i < 6; i++) {
                            let storedNeighbors = storedGraph.map.get(storedSymbol)[i] || [];
                            let currNeighbors = this.map.get(currSymbol)?.[i] || [];

                            if (storedNeighbors.length > currNeighbors.length) {
                                console.log("Stored neighbor:" + storedNeighbors + " Current neighbor:" + currNeighbors);
                                console.log(`Mismatch at side ${i}: Not enough neighbors`);
                                isValid = false;
                                break;
                            }

                            let foundAll = true;
                            for (let [storedNeighbor, storedSide] of storedNeighbors) {
                                let foundMatch = false;

                                for (let [currNeighbor, currSide] of currNeighbors) {
                                    if (
                                        currSide === storedSide &&
                                        this.isSymbolMatch(currNeighbor, storedNeighbor)
                                    ) {
                                        if (matchedSymbols.has(currNeighbor) || this.doesMatch(storedGraph, currNeighbor, matchedSymbols)) {
                                            foundMatch = true;
                                            break;
                                        }
                                    }
                                }

                                if (!foundMatch) {
                                    console.log(`Neighbor mismatch: ${storedNeighbor.elemIdTrue} not found`);
                                    foundAll = false;
                                    break;
                                }
                            }

                            if (!foundAll) {
                                isValid = false;
                                break;
                            }
                        }

                        if (isValid) return true;
                        matchedSymbols.delete(storedSymbol); // Backtrack
                    }
                }
                return false;
            }

            isSymbolMatch(currSymbol, storedSymbol) {
                return (
                    currSymbol &&
                    storedSymbol &&
                    currSymbol.elemIdTrue === storedSymbol.elemIdTrue &&
                    currSymbol.isDynamic === storedSymbol.isDynamic &&
                    currSymbol.angle === storedSymbol.angle
                );
            }
        }

        function snapshotSelectionAsPattern(fullGraph, selectedSymbols) {
            const g = new PatternGraph();
            const indexOf = new Map(); // DOM symbol -> node index

            // 1) ËäÇÁÇπ
            for (const sym of selectedSymbols) {
                indexOf.set(sym, g.addNode({
                elemIdTrue: sym.elemIdTrue,
                isDynamic: !!sym.isDynamic,
                angle: sym.angle
                }));
            }

            // 2) ËæπÔºàÂè™‰øùÁïôÈÄâ‰∏≠ÂÜÖÈÉ®ÁöÑËæπÔºâ
            for (const sym of selectedSymbols) {
                const i = indexOf.get(sym);
                const conns = fullGraph.getSymbolConnections(sym);
                if (!conns) continue;

                for (let side = 0; side < 6; side++) {
                for (const [nbr, nbrSide] of conns[side]) {
                    if (!selectedSymbols.has(nbr)) continue;
                    const j = indexOf.get(nbr);
                    g.addEdge(i, side, j, nbrSide);
                }
                }
            }

            return g;
        }

        function matchPatternOnSelection(selectedSymbols, pattern) {
            // Êää selectedSymbols ÂèòÊàêÊï∞ÁªÑÔºåÊñπ‰æøÁî® index Ë°®Á§∫
            const sel = [...selectedSymbols];
            const n = sel.length;
            const m = pattern.nodes.length;
            if (m === 0 || n < m) return null;

            // Âª∫‰∏Ä‰∏™Âø´ÈÄüÈÇªÊé•Êü•ËØ¢ÔºöselAdj[i][side] = [[j, jSide], ...]ÔºàÂè™Âú®ÈÄâ‰∏≠ÂÜÖÈÉ®Ôºâ
            const indexOf = new Map(sel.map((s, i) => [s, i]));
            const selAdj = sel.map(() => [[], [], [], [], [], []]);

            for (let i = 0; i < n; i++) {
                const conns = currentGraph.getSymbolConnections(sel[i]) || [[],[],[],[],[],[]];
                for (let side = 0; side < 6; side++) {
                for (const [nbr, nbrSide] of conns[side]) {
                    if (!indexOf.has(nbr)) continue;
                    selAdj[i][side].push([indexOf.get(nbr), nbrSide]);
                }
                }
            }

            const usedSel = new Array(n).fill(false);
            const mapPtoS = new Array(m).fill(-1); // pattern node -> selected index

            function nodeMatch(si, pi) {
                const s = sel[si];
                const p = pattern.nodes[pi];
                return s &&
                s.elemIdTrue === p.elemIdTrue &&
                !!s.isDynamic === !!p.isDynamic &&
                s.angle === p.angle;
            }

            function backtrack(pi) {
                if (pi === m) return true;

                for (let si = 0; si < n; si++) {
                if (usedSel[si]) continue;
                if (!nodeMatch(si, pi)) continue;

                // Â∞ùËØïÊää pattern pi Êò†Â∞ÑÂà∞ selected si
                mapPtoS[pi] = si;
                usedSel[si] = true;

                // Ê†°È™åÔºöpattern pi Â∑≤ÁªèÊåáÂêëÁöÑÈÇªÂ±ÖÔºàÈÇ£‰∫õÂ∑≤Ë¢´Êò†Â∞ÑÁöÑÔºâÂøÖÈ°ªÂú® selAdj ÈáåÂ≠òÂú®
                let ok = true;
                for (let side = 0; side < 6 && ok; side++) {
                    for (const [pj, pjSide] of pattern.adj[pi][side]) {
                    const sj = mapPtoS[pj];
                    if (sj === -1) continue; // ËøòÊ≤°Êò†Â∞ÑÂà∞ÂÖ∑‰Ωì symbolÔºåÂÖà‰∏çÊ£ÄÊü•

                    // Ë¶ÅÊ±Ç si ÁöÑ side ‰∏äÂ≠òÂú® (sj, pjSide)
                    const arr = selAdj[si][side];
                    if (!arr.some(([nbrIndex, nbrSide]) => nbrIndex === sj && nbrSide === pjSide)) {
                        ok = false;
                        break;
                    }
                    }
                }

                if (ok && backtrack(pi + 1)) return true;

                // ÂõûÊ∫Ø
                usedSel[si] = false;
                mapPtoS[pi] = -1;
                }
                return false;
            }

            if (!backtrack(0)) return null;

            // ËøîÂõûÂåπÈÖçÂà∞ÁöÑ DOM symbols ÈõÜÂêà
            const matched = new Set();
            for (let pi = 0; pi < m; pi++) matched.add(sel[mapPtoS[pi]]);
            return matched;
        }

        const currentGraph = new SymbolGraph();
        const library = new Map();
        const scale = 0.75;
        const SNAP_DISTANCE = 30 * scale; // Pixel distance for snapping
        const UNSNAP_DISTANCE = 40 * scale; // can beÔºö+4 / +8
        let dragSnapLock = null; // { targetId, targetSide, activeSide }

        function setDragSnapLock(v, reason = "") {
            if (v) {
                console.warn("[SET dragSnapLock]", reason, v);
                console.trace();
            } else {
                console.warn("[CLR dragSnapLock]", reason);
            }
            dragSnapLock = v;
        }

        let groupDragActive = false;
        let pendingSnapDelta = null; // {dx, dy}
        let snapCooldownUntil = 0; // ms, prevents immediate re-snap after unlock

        let acc = 0;
        let moleculeString = "";
        let selectedColor = null;
        const positions = [2, 1, 0, 7, 3, 4, 5, 6]; // Angle 0 = to the right
        // Circle layout parameters
        const radius = 150; // Radius of the circle
        const centerX = 450; // Center of the canvas (half of canvas width)
        const centerY = 200; // Center of the canvas (half of canvas height)

        const symbolScale = 0.75;
        const symbolWidth = 156;
        const symbolHeight = 67;

        const calX = 1;
        const calY = 6.7 * symbolScale;
        const calInvY = 7 * symbolScale;
        const calCan1 = 4 * symbolScale;
        const calCan2 = 3.5 * symbolScale;


        // Long press variables
        let progress = 0;
        let interval;
        let ring = null;
        let circle = null;
        const pressDuration = 1000; // 1 second to complete the bar
        const totalSteps = pressDuration / 10;

        // Set the x and y coordinates dynamically using JavaScript
        const logo = document.getElementById('logo');

        const palette = document.getElementById('palette');
        palette.style.left = `685px`;
        palette.style.top = `55px`;

        // Symbol labels
        const symbolLabels = [[['empty', 'medium', 'place'], ['still', 'calm', 'fixed']],
            [['protect', 'constrain'], ['come', 'pull', 'retreat']],
            [['center', 'middle', 'inner', 'occupy', 'point', 'individual', 'barrier', 'obstacle', 'unit'], ['separate', 'source', 'spread', 'explode', 'radiate']],
            [['hidden', 'unsupported', 'supple', 'bloated'], ['decay', 'leak', 'discard', 'shed', 'loosen', 'let go']],
            [['base', 'carry', 'load', 'deep'], ['go', 'push', 'advance']],
            [['gap', 'contain', 'enclosure', 'shell', 'surround'], ['join', 'combine', 'close', 'squeeze', 'attach']],
            [['heap', 'pile', 'hill', 'stub', 'incomplete', 'cavity', 'blade', 'sharp', 'shallow', 'exposed'], ['depart', 'give', 'express']],
            [['full', 'substance', 'complete', 'large'], ['chaotic', 'turmoil', 'unrest', 'hustle', 'activity', 'bustle', 'dynamic', 'vibrancy']],
            [['monotonous', 'homogeneous', 'same', 'normal', 'substance'], ['complex', 'system', 'order', 'organic', 'intricate', 'variegated']]];

        const symbolTitles = ['Based on Trigram Kun ‚ò∑. Empty and still.',
                        'Based on Trigram Gen ‚ò∂. Constrain and fall.',
                        'Based on Trigram Kan ‚òµ. Occupy and radiate.',
                        'Based on Trigram Xun ‚ò¥. Latent and leak.',
                        'Based on Trigram Zhen ‚ò≥. Load and rise.',
                        'Based on Trigram Li ‚ò≤. Contain and attach.',
                        'Based on Trigram Dui ‚ò±. Express and expose.',
                        'Based on Trigram Qian ‚ò∞. Full and vibrant.',
                        'A uniquely √çt√≠ symbol. It is always balancing all elements, so it can be either monotonous or filled with variegated order.']
        // Symbol data (position on circle)
        const symbolData = [
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000;stroke-width:1.02897" d="M15.362 16.96v-1.28H49.92v2.56H15.362Z"></path><path d="M0 5.371v-1.28h34.56v2.56H0z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h38.08V4.48h2.56v13.76H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h23.68V4.48h2.56v11.2h23.68v2.56H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><a transform="translate(0 -12)"><path style="fill:#000" d="M0 31.52c0-1.28 0-1.28 16.31-1.28 8.438 0 12.956-.003 14.768.024 1.676.024.91-.928.319-1.77-6.312-9.011 4.424-20.08 13.641-14.065 5.795 3.782 5.914 12.549.223 16.464-2.752 1.894-2.823 1.899-25.021 1.903C0 32.8 0 32.8 0 31.52m43.461-2.46c6.384-3.947 3.578-13.7-3.941-13.7-8.426 0-10.362 11.492-2.437 14.458 1.796.672 4.604.338 6.378-.759"></path><path d="M-.007 31.517v-1.28h16.31s20.052 2.554 3.93 2.557l-20.24.003z" style="fill:#000"></path></a></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h38.08v2.56H9.28Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h26.24V4.48h2.56v13.76H9.28z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M49.915 19.513c0-1.28 0-1.28-16.31-1.28-8.438 0-12.955-.003-14.768.023-1.675.025-.909-.927-.318-1.77 6.312-9.01-4.424-20.08-13.642-14.065-5.795 3.782-5.913 12.55-.223 16.465 2.752 1.893 2.824 1.899 25.021 1.903 20.24.004 20.24.004 20.24-1.276M6.454 17.052c-6.384-3.947-3.578-13.7 3.941-13.7 8.426 0 10.363 11.493 2.437 14.459-1.796.672-4.604.338-6.378-.76"></path><path d="M49.922 19.51v-1.28h-16.31s-20.052 2.553-3.93 2.556l20.24.004z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M21.856 20.468c-3.226-1.115-6.05-3.957-6.641-6.684-.226-1.04-.226-1.04-7.72-1.04-7.495 0-7.495 0-7.495-1.28s0-1.28 7.348-1.28c4.823 0 6.48 0 7.148-.385.35-.201.427-.508.547-.975 2.649-10.367 17.185-10.367 19.834 0 .348 1.36.348 1.36 7.695 1.36s7.348 0 7.348 1.28 0 1.28-7.495 1.28c-7.494 0-7.494 0-7.72 1.04-1.093 5.04-7.683 8.47-12.85 6.684m5.74-2.465c6.55-2.232 6.55-11.806 0-14.039-7.822-2.664-13.768 6.713-7.883 12.43 2.026 1.966 5.032 2.58 7.882 1.61"></path><path d="M35.224 10.185H49.92v2.56h-7.494m-34.928.003H.003v-2.56h14.695" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h49.92v2.56H0Zm8-11.2V4.48h33.92v2.56H8Z"></path></svg>`
        ];


        const dotData = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="5" fill="red"/></svg>`;
        const dotDataMini = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="2" cy="2" r="2" fill="red"/></svg>`;
        const dotOffsetXData = [0, 45, 0, 46, -45, 0, -46, 0, 0];
        const dotOffsetYData = [0, 0, 0, -8, 0, 0, -8, -8, 0];


        async function rotateSymbol(symbol, addAngle, inChat=false) {
            detachSymbol(symbol);

            symbol.angle = (symbol.angle + addAngle) % 360;
            if (symbol.elemId === 1) {
                if (symbol.angle === 90) {
                    symbol.elemId = 4;
                    symbol.innerHTML = symbolData[4];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 4;
                    symbol.innerHTML = symbolData[4];
                }
            } else if (symbol.elemId === 3) {
                if (symbol.angle === 90) {
                    symbol.elemId = 6;
                    symbol.innerHTML = symbolData[6];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 6;
                    symbol.innerHTML = symbolData[6];
                }
            } else if (symbol.elemId === 4) {
                if (symbol.angle === 90) {
                    symbol.elemId = 1;
                    symbol.innerHTML = symbolData[1];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 1;
                    symbol.innerHTML = symbolData[1];
                }
            }else if (symbol.elemId === 6) {
                if (symbol.angle === 90) {
                    symbol.elemId = 3;
                    symbol.innerHTML = symbolData[3];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 3;
                    symbol.innerHTML = symbolData[3];
                }
            }
            // symbol.querySelector('svg').setAttribute('width', '100%');
            // symbol.querySelector('svg').setAttribute('height', '100%');
            symbol.style.transform = `rotate(${symbol.angle}deg)`;
            dyeColor(symbol, symbol.color);

            if (inChat) {
                if (symbol.isDynamic && symbol.dot) {
                    updateDotPositionLocal(symbol.dot);           // instant UI update
                    await persistDotPosition(symbol.dot);         // one DB write
                }
                await updateSymbolAngle(symbol.dataset.id, symbol.angle);
                await updateSymbolElemId(symbol.dataset.id, symbol.elemId);
            }
        }

        const turnButton = document.createElement("div");
        turnButton.classList.add("button");
        turnButton.style.width = `149px`;
        turnButton.style.height = `142px`;
        turnButton.style.backgroundImage = "url('./icons/turn.png')";
        turnButton.style.left = `40px`;
        turnButton.style.top = `30px`;
        turnButton.addEventListener("click", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    await rotateSymbol(selectedSymbol, 90);
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });
        appendToCraftControls(turnButton);

        const turnButton2 = turnButton.cloneNode(true);
        turnButton2.addEventListener("click", async (e) => {
            if (selectedSymbols.size !== 0) {
                for (const selectedSymbol of selectedSymbols) {
                    if (!canEditElement(selectedSymbol)) continue; // skip others
                    await rotateSymbol(selectedSymbol, 90, true);
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        appendToChatControls(turnButton2);

        const dotButton = document.createElement("div");
        dotButton.classList.add("button");
        dotButton.style.width = `143px`;
        dotButton.style.height = `94px`;
        dotButton.style.backgroundImage = "url('./icons/dot.png')";
        dotButton.style.left = `200px`;
        dotButton.style.top = `55px`;

        dotButton.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;
                        updateDotPositionLocal(dot);
                        await persistDotPosition(dot);
                        appendToCraftCanvas(dot);

                    } else {

                        selectedSymbol.dot.remove();
                        selectedSymbol.dot = null;
                    }

                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });

        appendToCraftControls(dotButton);

        const dotButton2 = dotButton.cloneNode(true);
        dotButton2.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size !== 0) {
                for (const selectedSymbol of selectedSymbols) {
                    if (!canEditElement(selectedSymbol)) continue; // skip others

                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;

                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;

                        updateDotPositionLocal(dot);
                        appendToChatCanvas(dot);

                        await persistDotPosition(dot);
                    } else {
                        if (tabHeadersActivated[4]) {
                            await updateDoc(objDocRef(selectedSymbol.dataset.id), {
                                "content.dotX": null,
                                "content.dotY": null
                            });
                        }

                        selectedSymbol.dot?.remove();
                        selectedSymbol.dot = null;
                    }
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        appendToChatControls(dotButton2);

        async function updateDotPositionLocal(dot) {
            const symbol = dot.parent;

            const canvas = getCanvasForElem(symbol);
            if (!canvas) return;

            const canvasRect = canvas.getBoundingClientRect();
            const rect = symbol.getBoundingClientRect();

            // ÊääËßÜÂè£ÂùêÊ†á -> canvas Â±ÄÈÉ®ÂùêÊ†á
            const symLeft   = rect.left   - canvasRect.left;
            const symTop    = rect.top    - canvasRect.top;
            const symRight  = rect.right  - canvasRect.left;
            const symBottom = rect.bottom - canvasRect.top;

            let x, y;

            switch (symbol.angle) {
                case 0:
                x = symLeft + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5;
                y = symTop  + dotOffsetYData[symbol.elemId] * symbolScale - 12;
                break;
                case 90:
                x = symRight - dotOffsetYData[symbol.elemId] * symbolScale;
                y = symTop + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 10;
                break;
                case 180:
                x = symRight - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5;
                y = symBottom - dotOffsetYData[symbol.elemId] * symbolScale - 7;
                break;
                case 270:
                x = symLeft + dotOffsetYData[symbol.elemId] * symbolScale - 10;
                y = symBottom - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 7;
                break;
            }

            dot.style.left = `${x}px`;
            dot.style.top  = `${y}px`;
        }

        async function persistDotPosition(dot) {
            const symbol = dot.parent;
            if (!tabHeadersActivated[4]) return;

            const x = parseFloat(dot.style.left);
            const y = parseFloat(dot.style.top);

            const id = symbol.dataset?.id;
            if (!id) return;

            await updateDoc(objDocRef(id), {
                "content.dotX": x,
                "content.dotY": y
            });
        }


        function countConnectedComponentsInSelection(selectedSymbols, graph) {
            const sel = selectedSymbols instanceof Set ? selectedSymbols : new Set(selectedSymbols);
            if (sel.size === 0) return 0;

            const visited = new Set();
            let components = 0;

            for (const start of sel) {
                if (visited.has(start)) continue;

                components++;
                // BFS
                const queue = [start];
                visited.add(start);

                while (queue.length) {
                    const node = queue.pop();
                    const conns = graph.getSymbolConnections(node);
                    if (!conns) continue;

                    for (let side = 0; side < 6; side++) {
                        const neighbors = conns[side] || [];
                        for (const [nbr, _nbrSide] of neighbors) {
                            if (!sel.has(nbr)) continue;      // searching scope is limited to the selected symbols
                            if (visited.has(nbr)) continue;
                            visited.add(nbr);
                            queue.push(nbr);
                        }
                    }
                }
            }

            return components;
        }

        function isSelectionConnected(selectedSymbols, graph) {
            return countConnectedComponentsInSelection(selectedSymbols, graph) <= 1;
        }

        const eyeButton = document.createElement("div");
        eyeButton.isActivated = false;
        eyeButton.classList.add("button");
        eyeButton.style.width = `150px`;
        eyeButton.style.height = `106px`;
        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
        eyeButton.style.left = `510px`;
        eyeButton.style.top = `40px`;

        eyeButton.addEventListener("mouseup", (e) => {
            eyeButton.isActivated = !eyeButton.isActivated;
            if (eyeButton.isActivated) {
                eyeButton.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();

                    if (isSelectionConnected(selectedSymbols, currentGraph)) {
                        showInput(foundIds, elimBasic, representatives, hasDuplicateExpression);
                    }
                }
            } else {
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        appendToCraftControls(eyeButton);

        const eyeButton2 = eyeButton.cloneNode(true);

        eyeButton2.addEventListener("mouseup", (e) => {
            eyeButton2.isActivated = !eyeButton2.isActivated;
            if (eyeButton2.isActivated) {
                eyeButton2.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();
                }
            } else {
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        appendToChatControls(eyeButton2);

        const removeButton = document.createElement("div");
        removeButton.isActivated = false;
        removeButton.classList.add("button");
        removeButton.style.width = `168.75px`;
        removeButton.style.height = `119.25px`;
        removeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeButton.style.left = `340px`;
        removeButton.style.top = `40px`;

        removeButton.addEventListener("mouseup", (e) => {
            if (selectedSymbols.size != 0) {
                for (const selectedSymbol of selectedSymbols) {
                    currentGraph.removeSymbol(selectedSymbol);
                    if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                    selectedSymbol.remove();
                }
                selectedSymbols.clear();
            }
            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        appendToCraftControls(removeButton);

        const removeButton2 = removeButton.cloneNode(true);

        removeButton2.addEventListener("mouseup", async (e) => {
            e.stopPropagation();
            e.preventDefault();

            // ----- Symbols: delete only mine -----
            if (selectedSymbols.size > 0) {
                const toDelete = getEditableSelectedSymbols(); // only editable symbols

                for (const selectedSymbol of toDelete) {
                    currentGraph.removeSymbol(selectedSymbol);

                    const id = selectedSymbol.dataset.id;
                    if (id) {
                        // 1) remove links on neighbors
                        await removeLinksBeforeDelete(id);

                        // 2) delete the symbol doc
                        await deleteObj(currentRoomId, id);
                    }

                    // UI cleanup
                    if (selectedSymbol.isDynamic) selectedSymbol.dot?.remove();
                    selectedSymbol.remove();

                    // keep Set in sync
                    selectedSymbols.delete(selectedSymbol);
                    selectedSymbol.selected = false;
                }
            }

            // ----- Emojis: delete only mine -----
            if (selectedEmojis.size > 0) {
                const toDeleteE = getEditableSelectedEmojis(); // only editable emojis

                for (const selectedEmoji of toDeleteE) {
                    const id = selectedEmoji.dataset.id;
                    if (id) {
                        await deleteObj(currentRoomId, id);
                    }
                    selectedEmoji.remove();

                    selectedEmojis.delete(selectedEmoji);
                    selectedEmoji.selected = false;
                }
            }

            if (eyeButton2.isActivated) {
                eyeButton2.isActivated = false;
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });


        appendToChatControls(removeButton2);

        const removeNodeButton = document.createElement("div");
        removeNodeButton.isActivated = false;
        removeNodeButton.classList.add("button");
        removeNodeButton.style.width = `168.75px`;
        removeNodeButton.style.height = `119.25px`;
        removeNodeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeNodeButton.style.left = `40px`;
        removeNodeButton.style.top = `30px`;
        tab2.appendChild(removeNodeButton);
        removeNodeButton.addEventListener("pointerup", async (e) => {
            e.stopPropagation();
            e.preventDefault();

            const selectedNodeIds = network.getSelectedNodes(); // array of node IDs

            if (selectedNodeIds.length === 0) {
                alert("No node selected!");
                return;
            }

            for (const nodeId of selectedNodeIds) {
                const node = nodes.get(nodeId);
                if (!node) continue;

                // 1) Prevent deleting basic nodes (use ID-based check)
                if (basicNodeIds.has(nodeId)) {
                    continue;
                }

                // 2) Remove from in-memory library (semantic layer)
                if (node.word) {
                    library.delete(node.word);
                }

                // 3) Remove connected edges (visual + data layer)
                const connectedEdges = edges.get({
                    filter: (edge) => edge.from === nodeId || edge.to === nodeId
                });
                edges.remove(connectedEdges);

                // 4) Remove node from vis dataset
                nodes.remove(nodeId);
            }

            // 6) Clear selection after deletion
            network.unselectAll();

            // Persist the new full graph state (single-doc storage)
            await saveLibraryGraphForUser();
        });



        function dyeColor(symbol, color) {
            const svgElement = symbol.querySelector("svg");
            const paths = svgElement.querySelectorAll("path"); // Get the first shape inside the SVG
            paths.forEach((path) => {
                path.setAttribute("style", "fill:" + color); // Change the fill attribute
            });
            symbol.color = color;
        }

        // Handle color selection
        palette.addEventListener("click", (e) => {
        if (e.target.classList.contains("color")) {
            selectedColor = e.target.style.backgroundColor; // Set the selected color
            if (selectedSymbols.size != 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    dyeColor(selectedSymbol, selectedColor);
                });
            }
            console.log(`Selected color: ${selectedColor}`);
        }
        });

        const wheel = document.createElement("div"); // Your wheel sprite
        wheel.classList.add("wheel");
        wheel.style.left = `50px`; // Set the x position
        wheel.style.bottom = `40px`; // Set the y position
        wheel.style.width = `290.67px`;
        wheel.style.height = `292.33px`;
        wheel.style.backgroundImage = "url('./icons/wheel/wheel.png')";
        let wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
        let wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
        console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY} ${window.innerHeight} ${parseFloat(wheel.style.bottom)}`);
        const centerRadius = 36; // Define center circle radius

        wheel.addEventListener("mousedown", async (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                wheel.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            }

            // Calculate the angle in degrees (0¬∞ at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45¬∞)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel.addEventListener("mouseup", (event) => {
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });

        appendToCraftControls(wheel);

        const wheel2 = wheel.cloneNode(true);
        wheel2.addEventListener("mousedown", async (e) => {
            document.body.classList.add("no-text-select");  // prevent textbox selection

            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                console.log("Clicked center!");
                wheel2.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            }

            // Calculate the angle in degrees (0¬∞ at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45¬∞)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel2.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                const symbol = await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel2.addEventListener("mouseup", (event) => {
            document.body.classList.remove("no-text-select");
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });
        appendToChatControls(wheel2);

        // Function to handle the message when Enter is pressed
        async function handleMessage() {
            const messageBox = document.getElementById('message-input');
            const userInput = messageBox.value;

            messageBox.value = '';

            try {
                const response = await fetch("https://divinatory-conlang.zhouyt-tony2018.workers.dev/", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    type: "emoji",
                    text: userInput
                })
                });

                const data = await response.json();
                await createEmoji(data.result);
            } catch (error) {
                console.error(error);
                alert("Emoji generation failed.");
            }
        }

        // Add event listener to the input box for the Enter key
        document.getElementById('message-input').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                handleMessage();
            }
        });

        function floatLabel(label) {
            const maxDistance = 20; // Maximum distance from the original position
            const originX = 0, originY = 0; // Store original position
            let x = 0, y = 0;

            setInterval(() => {
                let xDelta = getRandomFloat(-2, 2);
                let yDelta = getRandomFloat(-2, 2);

                // Calculate new position
                let newX = x + xDelta;
                let newY = y + yDelta;

                // Check if the new position is within the allowed distance
                let distance = Math.sqrt(newX ** 2 + newY ** 2);
                if (distance <= maxDistance) {
                    x = newX;
                    y = newY;
                    label.style.transform = `translate(${x}px, ${y}px)`;
                }
            }, 100);
        }

        function buildDragGroupSet(draggedEl) {
            const isSelected =
                selectedSymbols.has(draggedEl) || selectedEmojis.has(draggedEl);

            if (!isSelected) return new Set([draggedEl]);

            // ‚úÖ Âπ∂ÈõÜÔºöÊâÄÊúâË¢´ÈÄâ‰∏≠ÁöÑÁ¨¶Âè∑ + emoji
            const group = new Set();
            selectedSymbols.forEach(s => group.add(s));
            selectedEmojis.forEach(em => group.add(em));

            // Â¶ÇÊûú‰Ω†‰∏çÊÉ≥Êää‚ÄúÁ©∫ÈõÜÂêà‚ÄùÊãñÊàêÁ©∫ÔºåÂÖúÂ∫ïÔºö
            if (group.size === 0) group.add(draggedEl);
            return group;
        }

        async function createEmoji(emojiResponse, emojiX=null, emojiY=null, emojiId=null) {
            const emoji = document.createElement('div');
            emoji.classList.add('symbol-label');
            // Position the label near the symbol
            if (emojiX) {
                emoji.x = emojiX;
                emoji.y = emojiY;
            } else {
                emoji.x = getRandomFloat(window.innerWidth / 5, window.innerWidth * 4 / 5);
                emoji.y = getRandomFloat(window.innerHeight / 5, window.innerHeight * 4 / 5);
            }

            emoji.style.left = `${emoji.x}px`;
            emoji.style.top = `${emoji.y}px`;
            emoji.selected = false;

            // Add pressing event listener to the emoji
            emoji.addEventListener("mousedown", (e) => {
                const totalSelected = selectedSymbols.size + selectedEmojis.size;
                const inSelection = selectedEmojis.has(emoji);
                const wantsGroupDrag = inSelection && totalSelected > 1;

                // record click-vs-drag
                emoji._downClientX = e.clientX;
                emoji._downClientY = e.clientY;
                emoji._dragged = false;
                emoji._downWasSelected = selectedEmojis.has(emoji);
                emoji._downWasInMulti = wantsGroupDrag;
                emoji._downTotalSelected = selectedSymbols.size + selectedEmojis.size;

                // UI off
                if (eyeButton.isActivated) { eyeButton.isActivated=false; eyeButton.style.backgroundImage="url('./icons/eye_black.png')"; removeLabelInputs(); }
                if (eyeButton2.isActivated){ eyeButton2.isActivated=false; eyeButton2.style.backgroundImage="url('./icons/eye_black.png')"; removeLabelInputs(); }

                // Selection on mousedown:
                // If not selected, make it the only selection.
                if (!inSelection) {
                    clearAllSymbolSelection();
                    clearAllEmojiSelection();
                    emoji.selected = true;
                    emoji.classList.add("active");
                    selectedEmojis.add(emoji);
                }

                // dragging is owner-only (selection still allowed)
                if (!canEditElement(emoji)) {
                    emoji.style.cursor = "not-allowed";
                    clickOnlyEmoji = emoji;
                    return;
                }

                emoji.style.cursor = "grabbing";

                const canvas = getCanvasForElem(emoji);
                const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

                if (wantsGroupDrag) {
                    dragLeader = emoji;
                    dragGroup = new Map();

                    setDragSnapLock(null, "start drag");
                    pendingSnapDelta = null;
                    readyActive = readyTarget = null;
                    readyActiveSide = readyTargetSide = null;
                    dragGroupStarted = false;
                    dragGroupSet = null;

                    const groupSet = buildDragGroupSet(dragLeader);
                    for (const el of groupSet) {
                    if (!canEditElement(el)) continue; // can't drag others' items

                    const l = parseFloat(el.style.left) || 0;
                    const t = parseFloat(el.style.top)  || 0;
                    const dx = l - localX;
                    const dy = t - localY;
                    dragGroup.set(el, { dx, dy, dx0: dx, dy0: dy });
                    }

                    activeEmoji = emoji; // leader remains active
                } else {
                    dragLeader = null;
                    dragGroup = null;

                    activeEmoji = emoji;

                    const left = parseFloat(emoji.style.left) || 0;
                    const top  = parseFloat(emoji.style.top)  || 0;
                    emoji.offsetX = localX - left;
                    emoji.offsetY = localY - top;
                }
            });

            appendToChatCanvas(emoji);
            emoji.textContent = emojiResponse; // Default text
            floatLabel(emoji);

            if (emojiId !== null) {
                emoji.dataset.id = emojiId;
            } else {
                // after you created the DOM element `symbol`
                emoji.dataset.id = "";                 // not ready yet
                emoji._pendingIdPromise = (async () => {
                    const docId = await saveObj("emoji", emojiResponse, emoji.x, emoji.y);
                    emoji.dataset.id = docId;
                    return docId;
                })();
            }

            return emoji;
        }

        window.addEventListener("resize", () => {
            wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
            wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
            console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY}`);
        });

        function removeLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label.removable');
            labels.forEach(label => label.remove());
            const inputs = document.querySelectorAll('.label-input.removable');
            inputs.forEach(input => input.remove());
            const textareas = document.querySelectorAll('.label-textarea.removable');
            textareas.forEach(textarea => textarea.remove());
            const buttons = document.querySelectorAll('.submit-button.removable');
            buttons.forEach(button => button.remove());
            const outputBoxes = document.querySelectorAll('.typing-effect.removable');
            outputBoxes.forEach(outputBox => outputBox.remove());
        }

        function hideLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.remove('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.remove('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.classList.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.remove('active'));
        }

        function showLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.add('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.add('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.add.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.add('active'));
        }

        function clientToLocal(container, clientX, clientY) {
            const r = container.getBoundingClientRect();
            return { x: clientX - r.left, y: clientY - r.top };
        }

        function getCanvasForElem(el) {
            // Â¶ÇÊûúÁ¨¶Âè∑/emoji Ë¢´ append Âà∞Âì™‰∏™ canvasÔºåÂ∞±Áî®Âì™‰∏™ canvas
            return el.closest("#craftCanvas, #chatCanvas");
        }

        let dragGroupStarted = false; // Êú¨Ê¨°Áæ§ÊãñÊòØÂê¶Â∑≤ÊâßË°åËøá‚ÄúÂ§ñÈÉ®Êñ≠Èìæ‚Äù
        let dragGroupSet = null;      // Êñπ‰æøÂà§Êñ≠ÁªÑÂÜÖÊàêÂëòÔºàSetÔºâ

        function cutConnectionsOutside(sym, groupSet) {
            const conns = currentGraph.getSymbolConnections(sym);
            if (!conns) return;

            const aId = sym.dataset?.id; // sym id once

            for (let side = 0; side < conns.length; side++) {
                const entryLst = conns[side] || [];
                if (!entryLst.length) continue;

                const remain = [];
                for (const [nbr, nbrSide] of entryLst) {
                    if (groupSet.has(nbr)) {
                        // ‚úÖ Keep internal connection
                        remain.push([nbr, nbrSide]);
                    } else {
                        // ‚úÖ Cut external connection (memory)
                        const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
                        if (currentGraph.getSymbolConnections(nbr)) {
                            currentGraph.getSymbolConnections(nbr)[nbrSide] = back.filter(([x]) => x !== sym);
                        }

                        // ‚úÖ Cut external connection (Firestore) ‚Äî IMPORTANT
                        const bId = nbr?.dataset?.id;
                        if (aId && bId) {
                            removeLink(aId, side, bId, nbrSide).catch(console.error);
                        }
                    }
                }
                conns[side] = remain; // keep only internal links
            }
        }

        function detachSymbolLocal(symbol) {
            const conns = currentGraph.getSymbolConnections(symbol);
            if (!conns) return;

            for (let side = 0; side < conns.length; side++) {
                const lst = conns[side] || [];
                for (const [nbr, nbrSide] of lst) {
                // remove back-edge on neighbor
                const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
                currentGraph.getSymbolConnections(nbr)[nbrSide] = back.filter(([x]) => x !== symbol);
                }
                conns[side] = [];
            }
        }

        // Firestore removal (optional but recommended)
        async function detachSymbolRemote(symbol) {
            const aId = symbol.dataset?.id;
            if (!aId) return;

            const conns = currentGraph.getSymbolConnections(symbol);
            if (!conns) return;

            // removeLink(aId, side, bId, nbrSide) ‰Ω†‰πãÂâçÂ∑≤ÁªèÊúâ
            for (let side = 0; side < conns.length; side++) {
                const lst = conns[side] || [];
                for (const [nbr, nbrSide] of lst) {
                const bId = nbr.dataset?.id;
                if (bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
                }
            }
        }

        /** Detach immediately in memory, then best-effort in Firestore */
        function detachSymbol(symbol) {
            // remember old connections first (because local detach will clear the list)
            const snapshot = (currentGraph.getSymbolConnections(symbol) || []).map(arr => arr.slice());

            // local detach
            detachSymbolLocal(symbol);

            // remote detach (best-effort, no await to avoid UI stutter)
            const aId = symbol.dataset?.id;
            if (!aId) return;

            for (let side = 0; side < snapshot.length; side++) {
                for (const [nbr, nbrSide] of (snapshot[side] || [])) {
                const bId = nbr.dataset?.id;
                if (bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
                }
            }

            readyActive = null;
            readyTarget = null;
            readyActiveSide = null;
            readyTargetSide = null;
        }

        function cancelDraggingState() {
            activeSymbol = null;
            activeEmoji = null;

            dragGroup = null;
            dragLeader = null;

            dragGroupStarted = false;
            dragGroupSet = null;

            // ‚úÖ also reset group-drag runtime flags to avoid lingering behavior
            groupDragActive = false;
            pendingSnapDelta = null;
            setDragSnapLock(null, "cancel drag");

            // optional but usually correct: clear snap candidate
            readyActive = readyTarget = null;
            readyActiveSide = readyTargetSide = null;
        }

        function applyDeltaToGroup(dx, dy) {
            if (!dragGroup) return;

            for (const [el, off] of dragGroup.entries()) {
                if (!canEditElement(el)) continue;

                // ‚úÖ Persist the delta into the stored offsets
                off.dx += dx;
                off.dy += dy;

                // Optional: update style immediately (not strictly necessary because render uses off.* next)
                const left = (parseFloat(el.style.left) || 0) + dx;
                const top  = (parseFloat(el.style.top)  || 0) + dy;
                el.style.left = `${left}px`;
                el.style.top  = `${top}px`;
            }
        }


        document.addEventListener("mousemove", async (e) => {
            if (clickOnlySymbol && !clickOnlySymbol._dragged) {
                const dx = e.clientX - (clickOnlySymbol._downClientX ?? e.clientX);
                const dy = e.clientY - (clickOnlySymbol._downClientY ?? e.clientY);
                if (dx*dx + dy*dy > 16) clickOnlySymbol._dragged = true;
            }
            if (clickOnlyEmoji && !clickOnlyEmoji._dragged) {
                const dx = e.clientX - (clickOnlyEmoji._downClientX ?? e.clientX);
                const dy = e.clientY - (clickOnlyEmoji._downClientY ?? e.clientY);
                if (dx*dx + dy*dy > 16) clickOnlyEmoji._dragged = true;
            }

            // mark as dragged (for click-vs-drag toggle)
            if (activeSymbol && !activeSymbol._dragged) {
                const dx = e.clientX - (activeSymbol._downClientX ?? e.clientX);
                const dy = e.clientY - (activeSymbol._downClientY ?? e.clientY);
                if (dx*dx + dy*dy > 16) activeSymbol._dragged = true; // 4px
            }

            if (activeEmoji && !activeEmoji._dragged) {
                const dx = e.clientX - (activeEmoji._downClientX ?? e.clientX);
                const dy = e.clientY - (activeEmoji._downClientY ?? e.clientY);
                if (dx*dx + dy*dy > 16) activeEmoji._dragged = true; // 4px
            }

            if (dragGroup && dragLeader) {
                if (!canEditElement(dragLeader)) {
                    cancelDraggingState();
                    return;
                }

                // --- DEBUG throttle (log at most every 120ms) ---
                if (!window.__dbg) window.__dbg = {};
                const now = performance.now();
                if (!window.__dbg.t) window.__dbg.t = 0;
                const DBG = now - window.__dbg.t > 120;
                if (DBG) window.__dbg.t = now;


                groupDragActive = true;
                pendingSnapDelta = null;

                const canvas = getCanvasForElem(dragLeader);

                const pt = clientToLocal(canvas, e.clientX, e.clientY);
                if (!pt) {
                    cancelDraggingState();
                    return;
                }

                let localX = pt.x;
                let localY = pt.y;

                if (dragSnapLock) {
                    localX = dragSnapLock.localX0;
                    localY = dragSnapLock.localY0;
                }

                // ‚úÖ Á¨¨‰∏ÄÊ¨°ËøõÂÖ•Áæ§ÊãñÔºöÊääÁªÑÂÜÖÊâÄÊúâ symbol ‰∏é‚ÄúÁªÑÂ§ñ‚ÄùÊñ≠ÂºÄÔºà‰øùÁïôÁªÑÂÜÖÔºâ
                if (!dragGroupStarted) {
                    dragGroupStarted = true;
                    dragGroupSet = new Set(dragGroup.keys()); // ÂΩìÂâçË¢´ÊãñÂä®ÁöÑÊâÄÊúâÂÖÉÁ¥†Ôºàsymbol+emojiÔºâ

                    for (const el of dragGroupSet) {
                        if (el.classList?.contains("symbol")) {
                            cutConnectionsOutside(el, dragGroupSet);
                            el.moving = true; // Ë°®Á§∫ËøôÊ¨°ÊãñÊãΩÂ∑≤ÁªèÂ§ÑÁêÜËøáÊñ≠ÈìæÔºàÈÅøÂÖç‰Ω†ÂÖ∂ÂÆÉÈÄªËæëÈáçÂ§ç cutÔºâ
                        }
                    }
                }

                // Unlock by mouse travel (client distance)
                if (dragSnapLock) {
                    const mdx = e.clientX - dragSnapLock.clientX0;
                    const mdy = e.clientY - dragSnapLock.clientY0;
                    const mouseDist = Math.hypot(mdx, mdy);

                    if (mouseDist > UNSNAP_DISTANCE) {
                        // Jump the whole group under the current cursor BEFORE unlocking.
                        // This prevents the "cursor far away from objects after unlock" problem.
                        const jumpDx = pt.x - dragSnapLock.localX0;
                        const jumpDy = pt.y - dragSnapLock.localY0;
                        applyDeltaToGroup(jumpDx, jumpDy);

                        setDragSnapLock(null, "unlock");

                        for (const [el, off] of dragGroup.entries()) {
                            off.dx = off.dx0;
                            off.dy = off.dy0;
                        }

                        snapCooldownUntil = performance.now() + 150;
                    }
                }


                for (const [el, off] of dragGroup.entries()) {
                    const stillSelected = selectedSymbols.has(el) || selectedEmojis.has(el);
                    if (!stillSelected) continue;

                    if (!canEditElement(el)) continue;

                    el.style.left = `${localX + off.dx}px`;
                    el.style.top  = `${localY + off.dy}px`;
                }

                if (dragLeader && dragLeader.classList?.contains("symbol") && !dragSnapLock && performance.now() > snapCooldownUntil) {
                    pendingSnapDelta = null;
                    readyActive = readyTarget = null;
                    readyActiveSide = readyTargetSide = null;

                    checkConnections(dragLeader);
                }

                if (pendingSnapDelta) {
                    applyDeltaToGroup(pendingSnapDelta.dx, pendingSnapDelta.dy);
                    pendingSnapDelta = null;

                    if (!dragSnapLock) {
                        setDragSnapLock({
                            clientX0: e.clientX,
                            clientY0: e.clientY,
                            localX0: pt.x,
                            localY0: pt.y,
                            activeSide: readyActiveSide,
                            targetSide: readyTargetSide,
                            targetEl: readyTarget
                        }, "snap applied");
                    }
                }

                for (const [el] of dragGroup.entries()) {
                    if (el.classList?.contains("symbol") && el.isDynamic && el.dot) {
                        updateDotPositionLocal(el.dot);
                    }
                }

                // ‚úÖ Âè™ÂØπ leaderÔºàËã•ÊòØ symbolÔºâÊâßË°å‰Ω†ÂéüÊù•ÁöÑ‚ÄúÊñ≠Èìæ/Ê£ÄÊü•ËøûÊé•‚ÄùÈÄªËæë
                if (activeSymbol) {
                    const x = parseFloat(activeSymbol.style.left) || 0;
                    const y = parseFloat(activeSymbol.style.top)  || 0;

                    if (activeSymbol.labels) {
                        activeSymbol.labels.forEach(label => {
                            label.style.left = `${x + label.offsetX}px`;
                            label.style.top = `${y + label.offsetY}px`;
                        });
                    }
                    if (activeSymbol.input) {
                        activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
                        activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
                    }
                    if (activeSymbol.textarea) {
                        activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
                        activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
                    }
                    if (activeSymbol.submitButton) {
                        const tTop = parseFloat(activeSymbol.textarea.style.top) || 0;
                        activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
                        activeSymbol.submitButton.style.top = `${tTop + 8 + activeSymbol.textarea.scrollHeight}px`;
                    }
                    if (activeSymbol.pElement) {
                        const tTop = parseFloat(activeSymbol.textarea.style.top) || 0;
                        activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
                        activeSymbol.pElement.style.top = `${tTop - 10 + activeSymbol.textarea.scrollHeight}px`;
                    }
                    if (activeSymbol.doneButton) {
                        activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
                        activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
                    }

                    endLongPress();
                    activeSymbol.classList.add("framed");
                }

                groupDragActive = false;
                return;
            }


            if (activeEmoji) {
                // üö´ not mine ‚Üí do nothing (still selected)
                if (!canEditElement(activeEmoji)) {
                    cancelDraggingState();
                    return;
                }
                const canvas = getCanvasForElem(activeEmoji);
                const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

                let x = localX - activeEmoji.offsetX;
                let y = localY - activeEmoji.offsetY;

                activeEmoji.style.left = `${x}px`;
                activeEmoji.style.top = `${y}px`;
                activeEmoji.selected = true;
            }

            if (activeSymbol) {
                endLongPress();

                // üö´ not mine ‚Üí do nothing (still selected)
                if (!canEditElement(activeSymbol)) {
                    cancelDraggingState();
                    return;
                }

                const canvas = getCanvasForElem(activeSymbol);
                const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

                let x = localX - activeSymbol.offsetX;
                let y = localY - activeSymbol.offsetY;
                activeSymbol.style.left = `${x}px`;
                activeSymbol.style.top = `${y}px`;
                activeSymbol.selected = true;

                // hideLabelInputs();
                if (activeSymbol.labels) {
                    activeSymbol.labels.forEach(label => {
                        label.style.left = `${x + label.offsetX}px`;
                        label.style.top = `${y + label.offsetY}px`;
                    });
                }
                if (activeSymbol.input) {
                    activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
                    activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
                }
                if (activeSymbol.textarea) {
                    activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
                    activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
                }
                if (activeSymbol.submitButton) {
                    activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
                    activeSymbol.submitButton.style.top = `${parseFloat(activeSymbol.textarea.style.top) + 8 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.pElement) {
                    activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
                    activeSymbol.pElement.style.top = `${parseFloat(activeSymbol.textarea.style.top) - 10 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.doneButton) {
                    activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
                    activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
                }

                checkConnections(activeSymbol);

                const snappedCandidate = (readyActive === activeSymbol && readyTarget != null);
                if (!activeSymbol.moving && !snappedCandidate) {
                    // Cut connections
                    const conns = currentGraph.getSymbolConnections(activeSymbol) || [];
                    for (let i = 0; i < conns.length; i++) {
                        const entryLst = conns[i] || [];
                        if (entryLst.length) {
                            for (let j = 0; j < entryLst.length; j++) {
                                const [nbr, nbrSide] = entryLst[j];
                                const targetEntry = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
                                currentGraph.getSymbolConnections(nbr)[nbrSide] =
                                targetEntry.filter(sub => sub[0] !== activeSymbol);

                                const aId = activeSymbol.dataset.id;
                                const bId = nbr.dataset.id;
                                if (aId && bId) removeLink(aId, i, bId, nbrSide).catch(console.error);
                            }
                            conns[i] = [];
                        }
                    }
                    activeSymbol.moving = true;
                }

                if (!activeSymbol.classList.contains("framed")) {
                    activeSymbol.classList.add("framed");
                }

                if (activeSymbol?.isDynamic && activeSymbol.dot) {
                    updateDotPositionLocal(activeSymbol.dot);
                }

            }
        });


        function cleanupDetachedLinksFor(symbol, breakDist = 10) {
        const conns = currentGraph.getSymbolConnections(symbol);
        if (!conns) return;

        for (let side = 0; side < conns.length; side++) {
            const lst = conns[side] || [];
            // iterate backwards because we may splice
            for (let i = lst.length - 1; i >= 0; i--) {
            const [nbr, nbrSide] = lst[i];
            if (!nbr) continue;

            const aJ = getAbsJunctions(symbol)?.[side];
            const bJ = getAbsJunctions(nbr)?.[nbrSide];
            if (!aJ || !bJ) continue;

            const d = getDist(aJ.x, aJ.y, bJ.x, bJ.y);
            if (d <= breakDist) continue;

            // remove from symbol side
            lst.splice(i, 1);

            // remove reverse edge
            const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
            currentGraph.getSymbolConnections(nbr)[nbrSide] =
                back.filter(([x, s]) => !(x === symbol && s === side));

            // optional: removeLink(...) if you persist links
            const aId = symbol.dataset?.id;
            const bId = nbr.dataset?.id;
            if (aId && bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
            }
        }
        }

        let lastPointerDownTarget = null;

        document.addEventListener("pointerdown", (e) => {
            lastPointerDownTarget = e.target;
        }, true);

        function isBlankCanvasClick(e) {
            const content = document.querySelector(".content");
            if (!content) {
                return false;
            }

            // 1) Must click inside the content viewport (where you scroll)
            const cr = content.getBoundingClientRect();
            const inContent =
                e.clientX >= cr.left && e.clientX <= cr.right &&
                e.clientY >= cr.top  && e.clientY <= cr.bottom;

            if (!inContent) {
                return false;
            }

            // 2) Only handle when Craft or Chat tab is active (otherwise don't clear)
            // Adjust these indices if yours differ
            const inCraft = !!document.querySelector("#tab1.active");
            const inChat  = !!document.querySelector("#tab4.active");
            if (!inCraft && !inChat) {
                return false;
            }

            // 3) Find the real element under pointer (often .content in your scrolled-empty area)
            const el = document.elementFromPoint(e.clientX, e.clientY) || e.target;

            // 4) Clicked an item? then NOT blank
            const hitItem = !!el?.closest?.(".symbol, .symbol-label");

            // 5) Clicked UI? then NOT blank
            const hitUI = !!el?.closest?.(
                "#palette, .wheel, #chatControls, .vertical-bar, .tab, .button, .label-input, .label-textarea, .submit-button, .symbol-label"
            );

            return !hitItem && !hitUI;
        }

        function commitLink(a, aSide, b, bSide) {
            const aConns = currentGraph.getSymbolConnections(a);
            const bConns = currentGraph.getSymbolConnections(b);
            if (!aConns || !bConns) return;

            if (!aConns[aSide].some(([nbr, s]) => nbr === b && s === bSide)) aConns[aSide].push([b, bSide]);
            if (!bConns[bSide].some(([nbr, s]) => nbr === a && s === aSide)) bConns[bSide].push([a, aSide]);
        }

        function violatesConflicts(target, targetSide) {
            const conns = currentGraph.getSymbolConnections(target) || [];
            const conflicts = SIDE_CONFLICTS.get(targetSide) || [];
            for (const s of conflicts) {
                if ((conns[s]?.length || 0) > 0) return true;
            }
            return false;
        }

        document.addEventListener("mouseup", async (e) => {
            selectionClickHandled = false;

            if (marqueeActive || marqueeJustDidSelect) {
                marqueeJustDidSelect = false; // clear after using marquee box
                return;  // don't run isBlankCanvasClick and don't clear selection
            }

            const activeTab = document.querySelector(".tab-content.active");
            const existingInput = activeTab?.querySelector(".label-input");

            endLongPress();
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";

            if (activeSymbol) {
                const released = activeSymbol;
                activeSymbol = null;
                released.style.cursor = "grab";

                // --- 1) Decide final selection state for this mouseup ---
                // Default: keep selected
                let shouldBeSelected = true;

                // Click (no drag) toggles if:
                // - started from multi-selection (marquee), OR
                // - started as single selection (only 1 selected on mousedown)
                const clickToggle = !released._dragged && (released._downWasInMulti || released._downWasSelected);

                if (clickToggle) {
                    selectionClickHandled = true;
                    shouldBeSelected = !selectedSymbols.has(released);
                } else {
                    shouldBeSelected = true; // drag or normal press keeps it selected
                }

                // --- 2) Apply selection state ONCE (sync property + class + Set) ---
                released.selected = shouldBeSelected;
                if (shouldBeSelected) {
                    released.classList.add("framed");
                    selectedSymbols.add(released);
                } else {
                    if (clickToggle) cancelDraggingState();
                    released.classList.remove("framed");
                    selectedSymbols.delete(released);

                    // Turn off UI modes when deselecting (optional but matches your behavior)
                    if (eyeButton.isActivated) {
                        eyeButton.isActivated = false;
                        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                    if (eyeButton2.isActivated) {
                        eyeButton2.isActivated = false;
                        eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                }

                // --- 3) Commit link ONLY if the released symbol is selected and is the snap candidate ---
                if (shouldBeSelected && readyActive && readyTarget && readyActive === released) {
                    if (violatesConflicts(readyTarget, readyTargetSide)) {
                        console.warn("[COMMIT BLOCKED] conflict", {
                            targetElem: readyTarget.elemIdTrue,
                            targetSide: readyTargetSide
                        });
                    } else {
                        commitLink(readyActive, readyActiveSide, readyTarget, readyTargetSide);

                        // Persist only if both ids exist
                        const aId = readyActive.dataset?.id;
                        const bId = readyTarget.dataset?.id;
                        if (aId && bId) {
                            persistLink(aId, readyActiveSide, bId, readyTargetSide).catch(console.error);
                        }
                    }

                    // Clear candidate after using it (avoid accidental re-commit)
                    readyActive = readyTarget = null;
                    readyActiveSide = readyTargetSide = null;
                }

                // --- 4) Persist position / dot only for single drag (not group drag) ---
                if (!dragGroup) {
                    const x = parseFloat(released.style.left);
                    const y = parseFloat(released.style.top);

                    (async () => {
                    let id = released.dataset?.id;
                    if (!id && released._pendingIdPromise) id = await released._pendingIdPromise;
                    if (id) await updateObjPosition(id, x, y);
                    })().catch(console.error);

                    if (released.isDynamic && released.dot) {
                    updateDotPositionLocal(released.dot);
                    persistDotPosition(released.dot).catch(console.error);
                    }
                }

                // --- 5) Reset per-drag flags ---
                released.moving = false;
                isGenerating = false;
            }

            if (activeEmoji) {
                const released = activeEmoji;
                activeEmoji = null;
                released.style.cursor = "grab";

                const clickToggle = !released._dragged && (released._downWasInMulti || released._downWasSelected);

                if (clickToggle) {
                    selectionClickHandled = true;
                    if (selectedEmojis.has(released)) {
                        cancelDraggingState();
                        released.selected = false;
                        released.classList.remove("active");
                        selectedEmojis.delete(released);
                    } else {
                        // turning ON
                        clearAllSymbolSelection();
                        clearAllEmojiSelection();

                        released.selected = true;
                        released.classList.add("active");
                        selectedEmojis.add(released);
                    }
                } else {
                    // drag or normal press keeps it selected
                    released.selected = true;
                    released.classList.add("active");
                    selectedEmojis.add(released);
                }

                // Persist position only if this wasn't a group drag
                if (!dragGroup) {
                    const x = parseFloat(released.style.left);
                    const y = parseFloat(released.style.top);

                    (async () => {
                    let id = released.dataset?.id;
                    if (!id && released._pendingIdPromise) id = await released._pendingIdPromise;
                    if (id) await updateObjPosition(id, x, y);
                    })().catch(console.error);
                }
            }

            if (clickOnlySymbol) {
                const s = clickOnlySymbol;

                if (!s._dragged) {
                    selectionClickHandled = true;

                    // Same toggle rule as activeSymbol:
                    // click toggles only if it was already selected at mousedown OR in multi-selection
                    const clickToggle = (s._downWasInMulti || s._downWasSelected);

                    if (clickToggle) {
                        // toggle off/on
                        if (selectedSymbols.has(s)) {
                            s.selected = false;
                            s.classList.remove("framed");
                            selectedSymbols.delete(s);
                        } else {
                            clearAllSymbolSelection(); clearAllEmojiSelection();
                            s.selected = true;
                            s.classList.add("framed");
                            selectedSymbols.add(s);
                        }
                    } else {
                        // first-time click: keep it selected (single-select)
                        clearAllSymbolSelection(); clearAllEmojiSelection();
                        s.selected = true;
                        s.classList.add("framed");
                        selectedSymbols.add(s);
                    }
                }

                clickOnlySymbol = null;
            }

            if (clickOnlyEmoji) {
                const em = clickOnlyEmoji;

                if (!em._dragged) {
                    selectionClickHandled = true;

                    const clickToggle = (em._downWasInMulti || em._downWasSelected);

                    if (clickToggle) {
                        if (selectedEmojis.has(em)) {
                            em.selected = false;
                            em.classList.remove("active");
                            selectedEmojis.delete(em);
                        } else {
                            clearAllSymbolSelection(); clearAllEmojiSelection();
                            em.selected = true;
                            em.classList.add("active");
                            selectedEmojis.add(em);
                        }
                    } else {
                        clearAllSymbolSelection(); clearAllEmojiSelection();
                        em.selected = true;
                        em.classList.add("active");
                        selectedEmojis.add(em);
                    }
                }

                clickOnlyEmoji = null;
            }

            if (selectionClickHandled) return;

            if (dragGroup) {
                for (const el of dragGroup.keys()) {
                    const id = el.dataset?.id;
                    const x = parseFloat(el.style.left);
                    const y = parseFloat(el.style.top);
                    if (id) updateObjPosition(id, x, y).catch(console.error);

                    if (el.isDynamic && el.dot) {
                        updateDotPositionLocal(el.dot);
                        persistDotPosition(el.dot).catch(console.error);
                    }
                }

                // After group drag ends, reset per-symbol drag flags
                if (dragGroupSet) {
                    for (const el of dragGroupSet) {
                        if (el.classList?.contains("symbol")) {
                            el.moving = false;
                            cleanupDetachedLinksFor(el, 10)
                        }
                    }
                }
                dragGroup = null;
                dragLeader = null;
                dragGroupStarted = false;
                dragGroupSet = null;
                groupDragActive = false;
                pendingSnapDelta = null;
                setDragSnapLock(null, "end drag");
                readyActive = readyTarget = null;
                readyActiveSide = readyTargetSide = null;

            }

            let rect;

            // waiting for an explanation input, so input boxes aren't fragile (i.e. disappear when canvas is clicked)
            if (!existingInput && isBlankCanvasClick(e)) {
                // clear symbols safely
                for (const s of Array.from(selectedSymbols)) {
                    s.classList.remove("framed");
                    s.selected = false;
                }
                selectedSymbols.clear();

                // clear emojis safely
                for (const em of Array.from(selectedEmojis)) {
                    em.classList.remove("active");
                    em.selected = false;
                }
                selectedEmojis.clear();

                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
                if (eyeButton2.isActivated) {
                    eyeButton2.isActivated = false;
                    eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
            }

        });

        let marqueeActive = false;   // ÂΩìÂâçÊòØÂê¶Âú®Ê°ÜÈÄâÊâãÂäø‰∏≠
        let marqueeJustDidSelect = false; // Ëøô‰∏ÄËΩÆ pointerup ÊòØÂê¶ÂàöÂÅöËøáÊ°ÜÈÄâÈÄâÊã©

        function enableMarqueeSelection({
        canvasEl,
        itemSelector,
        ignoreSelector = "",
        clearSelection,
        onSelect,
        }) {
            let isDown = false;
            let isDragging = false;
            let downOnItem = false;

            let startClientX = 0, startClientY = 0;
            let box = null;

            function shouldIgnoreTarget(target) {
                if (!ignoreSelector) return false;
                return !!target.closest(ignoreSelector);
            }

            function ensureBox() {
                if (box) return box;
                box = document.createElement("div");
                box.className = "marquee-box";
                // ÂÖ≥ÈîÆÔºö‰∏çË¶ÅËÆ©ËìùÊ°ÜÂêÉÊéâ‰∫ã‰ª∂
                box.style.position = "absolute";
                box.style.pointerEvents = "none";
                box.style.display = "none";
                canvasEl.appendChild(box);
                return box;
            }

            function showBox(clientX1, clientY1, clientX2, clientY2) {
                const r = canvasEl.getBoundingClientRect();
                const x1 = Math.min(clientX1, clientX2) - r.left;
                const y1 = Math.min(clientY1, clientY2) - r.top;
                const x2 = Math.max(clientX1, clientX2) - r.left;
                const y2 = Math.max(clientY1, clientY2) - r.top;

                const b = ensureBox();
                b.style.left = `${x1}px`;
                b.style.top = `${y1}px`;
                b.style.width = `${x2 - x1}px`;
                b.style.height = `${y2 - y1}px`;
                b.style.display = "block";
            }

            function hideBox() {
                if (!box) return;
                box.style.display = "none";
            }

            // Áî®ËßÜÂè£ÂùêÊ†áÂÅöÁõ∏‰∫§Âà§Êñ≠ÔºöselectionRect ‰∏é itemRect ÈÉΩÊòØ viewport coords
            function selectInRect(clientX1, clientY1, clientX2, clientY2) {
                const selLeft = Math.min(clientX1, clientX2);
                const selTop = Math.min(clientY1, clientY2);
                const selRight = Math.max(clientX1, clientX2);
                const selBottom = Math.max(clientY1, clientY2);

                // Âè™Âú® canvas ÂÜÖÊâæ itemsÔºàÈÅøÂÖçÊâ´Âà∞Âà´ÁöÑ tabÔºâ
                const items = canvasEl.querySelectorAll(itemSelector);

                clearSelection?.();

                items.forEach(el => {
                const rect = el.getBoundingClientRect();
                const intersects =
                    rect.right >= selLeft &&
                    rect.left <= selRight &&
                    rect.bottom >= selTop &&
                    rect.top <= selBottom;

                if (intersects) onSelect?.(el);
                });
            }

            // Áî® pointer ‰∫ã‰ª∂Êõ¥Á®≥ÔºàÈº†Ê†áÁßªÂá∫‰πü‰∏ç‰∏¢Ôºâ
            canvasEl.addEventListener("pointerdown", (e) => {
                if (e.button !== 0) return; // Âè™Â∑¶ÈîÆ
                if (shouldIgnoreTarget(e.target)) return;

                downOnItem = !!e.target.closest(itemSelector);

                isDown = true;
                isDragging = false;
                startClientX = e.clientX;
                startClientY = e.clientY;

                // ÊçïËé∑ pointerÔºåÈÅøÂÖçÊãñÂá∫ canvas ÂêéÊñ≠Êéâ
                canvasEl.setPointerCapture?.(e.pointerId);
            });

            canvasEl.addEventListener("pointermove", (e) => {
                if (!isDown) return;

                if (downOnItem) return;

                const dx = e.clientX - startClientX;
                const dy = e.clientY - startClientY;
                const dist2 = dx * dx + dy * dy;

                // Â∞è‰∫éÈòàÂÄº‰∏çÁÆóÊãñÊãΩÔºåÈÅøÂÖçÁÇπ‰∏Ä‰∏ã‰πüÁîªÊ°Ü
                if (!isDragging && dist2 < 16) return;

                if (!isDragging) {
                    isDragging = true;
                    marqueeActive = true;
                }

                showBox(startClientX, startClientY, e.clientX, e.clientY);
                e.preventDefault();
            });

            canvasEl.addEventListener("pointerup", (e) => {
                if (!isDown) return;
                isDown = false;

                if (isDragging) {
                    selectInRect(startClientX, startClientY, e.clientX, e.clientY);
                    marqueeJustDidSelect = true;
                }

                hideBox();
                isDragging = false;
                downOnItem = false;
                marqueeActive = false;
            });

            canvasEl.addEventListener("pointercancel", () => {
                isDown = false;
                isDragging = false;
                downOnItem = false;
                marqueeActive = false;
                hideBox();
            });

        }

        function clearAllSymbolSelection() {
            // Remove frames from ALL selected symbols (mine + others)
            for (const s of Array.from(selectedSymbols)) {
                s.selected = false;
                s.classList.remove("framed");
            }
            selectedSymbols.clear();
        }

        function clearAllEmojiSelection() {
            for (const e of Array.from(selectedEmojis)) {
                e.selected = false;
                e.classList.remove("active");
            }
            selectedEmojis.clear();
        }

        function getRandomSubset(words, count) {
            return words.sort(() => Math.random() - 0.5).slice(0, count);
        }
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function areSetsEqual(set1, set2) {
            if (!set1 || !set2) return false; // guard against null values
            if (set1.size !== set2.size) return false; // Different sizes ‚Üí not equal
            for (let elem of set1) {
                if (!set2.has(elem)) return false; // If set2 is missing an element ‚Üí not equal
            }
            return true;
        }

        function buildSubgraphFromSelection(fullGraph, selectedSymbols) {
            const subGraph = new SymbolGraph();

            // add every selected symbol to the subgraph
            for (const symbol of selectedSymbols) {
                const connections = fullGraph.getSymbolConnections(symbol);
                if (!connections) continue;

                // deep-copy connection structure to avoid polluting the original graph
                subGraph.addSymbol(
                    symbol,
                    connections.map(side =>
                        side.filter(([neighbor]) => selectedSymbols.has(neighbor))
                    )
                );
            }

            return subGraph;
        }

        // Function to create labels for selected symbols
        function showSimpleLabel() {
            let labelData = [];

            selectedSymbols.forEach(selectedSymbol => {
            // Check if label already exists
            if (!selectedSymbol.querySelector('.symbol-label')) {
                const words = symbolLabels[selectedSymbol.elemIdTrue][Number(selectedSymbol.isDynamic)].slice();

                if (getDir(selectedSymbol) === 0 && !selectedSymbol.isDynamic) {
                if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 3) words.push(...["right side"]);
                if (selectedSymbol.elemIdTrue === 4 || selectedSymbol.elemIdTrue === 6) words.push(...["left side"]);
                if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 4) words.push(...["barrier"]);
                }

                if (getDir(selectedSymbol) === 1) {
                if (selectedSymbol.elemIdTrue === 1) {
                    if (selectedSymbol.isDynamic) {
                    words.push(...['gravity', 'fall', 'descend']);
                    } else {
                    words.push(...['top', 'roof', 'high', 'aloft']);
                    }
                }
                if (selectedSymbol.elemIdTrue === 3) {
                    if (!selectedSymbol.isDynamic) {
                    words.push(...['aerial', 'suspend', 'tall', 'float']);
                    }
                }
                if (selectedSymbol.elemIdTrue === 4) {
                    if (selectedSymbol.isDynamic) {
                    console.log('fly highhhhh');
                    words.push(...['ascend', 'rise', 'climb']);
                    } else {
                    words.push(...['low', 'ground', 'platform']);
                    }
                }
                }

                let subset = getRandomSubset(words, 2);

                // ‚úÖ ËßÜÂè£ÂùêÊ†á -> canvas Â±ÄÈÉ®ÂùêÊ†á
                const rect = selectedSymbol.getBoundingClientRect();
                const canvas = getCanvasForElem(selectedSymbol);
                const canvasRect = canvas ? canvas.getBoundingClientRect() : { left: 0, top: 0 };

                const cx = (rect.left - canvasRect.left) + rect.width / 2;
                const cy = (rect.top  - canvasRect.top)  + rect.height / 2;

                for (const word of subset) {
                    labelData.push([word, cx, cy, selectedSymbol]);
                }
            }
            });

            const foundIds = new Set();
            const elimBasic = new Set();  // we don't want basic-level symbols to connect to symbols that are much advanced than them
            const representatives = new Map();
            let hasDuplicateExpression = false;

            const selectionGraph =
                    buildSubgraphFromSelection(currentGraph, selectedSymbols);

            for (const [storedWord, [storedId, storedGraph]] of library) {
                let foundMatching = matchPatternOnSelection(selectedSymbols, storedGraph);
                if (areSetsEqual(foundMatching, selectedSymbols)) hasDuplicateExpression = true;

                if (foundMatching != null) {
                    let avgX = 0, avgY = 0;
                    let lastSymbol;

                    // Âèñ‰ªªÊÑè‰∏Ä‰∏™ symbol ÊâæÂà∞ÂÖ±Âêå canvas
                    const first = foundMatching.values().next().value;
                    const canvas = getCanvasForElem(first);
                    const canvasRect = canvas.getBoundingClientRect();

                    for (const symbol of foundMatching) {
                        const rect = symbol.getBoundingClientRect();

                        // ‚úÖ ËßÜÂè£ÂùêÊ†á -> canvas Â±ÄÈÉ®ÂùêÊ†á
                        const cx = (rect.left - canvasRect.left) + rect.width / 2;
                        const cy = (rect.top  - canvasRect.top)  + rect.height / 2;

                        avgX += cx;
                        avgY += cy;
                        lastSymbol = symbol;
                    }

                    representatives.set(lastSymbol, storedWord);
                    avgX /= foundMatching.size;
                    avgY /= foundMatching.size;

                    labelData.push([storedWord, avgX, avgY, lastSymbol]);
                    foundIds.add(storedId);

                    for (const symbol of foundMatching) {
                        elimBasic.add(symbol);
                    }
                }
            }

            labelData.forEach(labelDataSub => {
                const label = document.createElement('div');
                label.classList.add('symbol-label', 'removable');
                // Position the label near the symbol
                label.x = labelDataSub[1] + getRandomFloat(-100, 20);
                label.y = labelDataSub[2] + getRandomFloat(-30, 0);

                if (labelDataSub[3].labels === undefined) {
                    labelDataSub[3].labels = new Set([label]);
                } else {
                    labelDataSub[3].labels.add(label);
                }
                label.offsetX = label.x - parseFloat(labelDataSub[3].style.left);
                label.offsetY = label.y - parseFloat(labelDataSub[3].style.top);
                label.style.left = `${label.x}px`;
                label.style.top = `${label.y}px`;

                // 1) avoid triggering global logic when clicked on labels
                label.addEventListener("pointerdown", (e) => {
                    e.stopPropagation();
                }, true);

                // 2) remove label on pointerup
                label.addEventListener("pointerup", (e) => {
                    e.stopPropagation();
                    label.remove();
                });

                if (tabHeadersActivated[1]) appendToCraftCanvas(label);
                if (tabHeadersActivated[4]) appendToChatCanvas(label);
                label.textContent = labelDataSub[0]; // Default text
                floatLabel(label);
            });
            return [foundIds, elimBasic, representatives, hasDuplicateExpression];
        }

        let rightMost;
        let topMost;

        // Function to create a text input near the symbol
        function showInput(foundIds, elimBasic, representatives, hasDuplicateExpression) {

            function computeSelectionBoundsLocal() {
                const first = selectedSymbols.values().next().value;
                if (!first) return null;

                const canvas = first.closest("#craftCanvas, #chatCanvas");
                if (!canvas) return null;

                const canvasRect = canvas.getBoundingClientRect();

                let rightMost = -Infinity;
                let topMost = Infinity;

                for (const s of selectedSymbols) {
                    const r = s.getBoundingClientRect();
                    const right = r.right - canvasRect.left; // canvas-local
                    const top   = r.top   - canvasRect.top;  // canvas-local
                    if (right > rightMost) rightMost = right;
                    if (top < topMost) topMost = top;
                }

                return { canvas, rightMost, topMost };
            }

            const inputParent = selectedSymbols.values().next().value;
            if (!inputParent) return;

            const parentLeft = parseFloat(inputParent.style.left) || 0;
            const parentTop  = parseFloat(inputParent.style.top)  || 0;

            const bounds = computeSelectionBoundsLocal();
            if (!bounds) return;

            const { canvas, rightMost, topMost } = bounds;

            const input = document.createElement("input");
            input.classList.add("label-input", "removable");
            input.type = "text";
            input.placeholder = "What word is this?";

            // locate input in the canvas-local coordinate system
            input.x = rightMost + 5;
            input.y = topMost - 2;


            input.offsetX = input.x - parentLeft;
            input.offsetY = input.y - parentTop;

            input.style.position = "absolute";
            input.style.left = `${input.x}px`;
            input.style.top  = `${input.y}px`;

            inputParent.input = input;
            input.focus();

            appendToCraftCanvas(input);

            const textarea = document.createElement('textarea');
            textarea.classList.add('label-textarea', 'removable');
            textarea.placeholder = 'Why?';

            // Position the textarea near the symbol
            textarea.x = rightMost + 5;
            textarea.y = topMost + 35;

            textarea.offsetX = textarea.x - parentLeft;
            textarea.offsetY = textarea.y - parentTop;

            textarea.style.position = "absolute";
            textarea.style.left = `${textarea.x}px`;
            textarea.style.top = `${textarea.y}px`;

            inputParent.textarea = textarea;

            textarea.focus();

            // Adjust height dynamically as user types
            textarea.addEventListener('input', function () {
                textarea.style.height = 'auto'; // Reset height first
                textarea.style.height = `${textarea.scrollHeight}px`; // Set new height based on content
                submitButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
                cancelButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
            });

            appendToCraftCanvas(textarea);

            // Create the submit button
            const submitButton = document.createElement("button");
            submitButton.classList.add("submit-button", 'removable');
            submitButton.innerHTML = "‚úî"; // Check mark icon

            submitButton.x = rightMost + 5;
            submitButton.y = topMost + 43 + textarea.scrollHeight;

            submitButton.offsetX = submitButton.x - parentLeft;
            submitButton.offsetY = submitButton.y - parentTop;
            submitButton.style.left = `${submitButton.x}px`; // Position to the right of the textbox
            submitButton.style.top = `${submitButton.y}px`;

            inputParent.submitButton = submitButton;

            appendToCraftCanvas(submitButton);

            // Create the cancel button
            const cancelButton = document.createElement("button");
            cancelButton.classList.add("submit-button", 'removable');
            cancelButton.innerHTML = "‚úò"; // X mark icon

            cancelButton.x = rightMost + 40;
            cancelButton.y = topMost + 43 + textarea.scrollHeight;

            cancelButton.offsetX = cancelButton.x - parentLeft;
            cancelButton.offsetY = cancelButton.y - parentTop;
            cancelButton.style.left = `${cancelButton.x}px`; // Position to the right of the textbox
            cancelButton.style.top = `${cancelButton.y}px`;

            inputParent.cancelButton = cancelButton;

            appendToCraftCanvas(cancelButton);

            let word;
            let definition;
            let justification;

            // Handle button click event
            submitButton.onclick = async function () {
                word = input.value;

                // Recalculate the molecule to incorporate the advanced vocabulary

                // If the user has only selected one symbol
                if (selectedSymbols.size === 1) {
                    moleculeString = getMoleculeChar(selectedSymbols.values().next().value);
                } else if (selectedSymbols.size > 1) {
                    triggerLongPress(selectedSymbols.values().next().value, representatives);
                }

                definition = moleculeString;
                justification = textarea.value;

                console.log(`word ${word} definition ${definition} justification ${justification}`); // Handle submission logic here
                //input.remove();
                //textarea.remove();

                submitButton.remove();
                cancelButton.remove();
                input.readOnly = true;
                textarea.readOnly = true;

                if (!word || !definition || !justification) {
                    showFeedback('Please fill in all fields!', true);
                    return;
                }
console.warn("[submit] library size =", library?.size);
console.warn("[submit] library has word?", word, library?.has(word));
console.warn("[submit] library keys =", [...(library?.keys?.() || [])]);
                if (library.has(word)) {
                    showFeedback('You have already defined the word!', true);
                    return;
                }

                if (hasDuplicateExpression) {
                    showFeedback('You have already used this expression for defining another word!', true);
                    return;
                }

                try {
                    const response = await fetch("https://divinatory-conlang.zhouyt-tony2018.workers.dev/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        type: "conlang",
                        word,
                        definition,
                        justification
                    })
                    });

                    const data = await response.json();
                    showFeedback(data.result, false);
                } catch (error) {
                    console.error(error);
                    alert("Validation failed.");
                }
            };

            cancelButton.onclick = function () {
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
            }

            function showFeedback(feedback, manualFailed=false){
                console.log(`foundIds init ${foundIds}`);
                // Create the div element
                const outputBox = document.createElement("div");
                outputBox.classList.add("typing-effect", 'removable');

                const bounds = computeSelectionBoundsLocal();
                if (!bounds) return;

                const { canvas, rightMost } = bounds; // ‰Ω†ËøôÈáåÂè™Áî® rightMost ‰πüË°å

                // Create the p element
                const pElement = document.createElement("p");
                pElement.x = rightMost + 5;
                pElement.y = parseFloat(textarea.style.top) - 10 + textarea.scrollHeight;
                console.log(`scroll ${textarea.scrollHeight}`);

                pElement.offsetX = pElement.x - parentLeft;
                pElement.offsetY = pElement.y - parentTop;
                pElement.style.left = `${pElement.x}px`; // Position to the right of the textbox
                pElement.style.top = `${pElement.y}px`;

                inputParent.pElement = pElement;

                // Create a span element to hold the text (so the cursor stays at the end)
                const textSpan = document.createElement("span");
                textSpan.id = "typingText";
                pElement.appendChild(textSpan);

                // Create a cursor span element
                const cursorSpan = document.createElement("span");
                cursorSpan.id = "cursor";
                cursorSpan.textContent = "|"; // Cursor symbol
                pElement.appendChild(cursorSpan);

                // Append the p element to the div element
                outputBox.appendChild(pElement);

                // Append the div element to the body of the document
                if (tabHeadersActivated[1]) appendToCraftCanvas(outputBox);
                if (tabHeadersActivated[4]) appendToChatCanvas(outputBox);

                const text = feedback;
                let index = 0;
                const speed = 10; // Speed of typing in milliseconds
                const maxLineLen = 20;
                let lineIndex = 0;
                let passed;
                function type(onComplete) {
                    if (document.getElementById("typingText") !== null) {
                        if (index < text.length) {
                            if (lineIndex < Math.floor(document.getElementById("typingText").innerHTML.length / maxLineLen) && text.charAt(index) === ' ') {
                                document.getElementById("typingText").innerHTML += '\n';
                                lineIndex++;
                            }
                            document.getElementById("typingText").innerHTML += text.charAt(index);
                            index++;
                            setTimeout(() => type(onComplete), speed);
                        } else {
                            if (text.includes("Yes")) {
                                passed = true;
                            } else {
                                passed = false;
                            }
                            if (onComplete) onComplete(passed);
                        }
                    }
                }

                function showDoneButton(passed) {
                    console.log(`foundIds ${foundIds}`);

                    const doneButton = document.createElement("button");
                    doneButton.classList.add("submit-button", "removable");
                    if (passed) {
                        doneButton.innerHTML = "‚úî"; // Check mark icon
                    } else {
                        doneButton.innerHTML = "‚úò"; // X mark icon
                    }

                    doneButton.x = rightMost + 5; // Position to the right of the textbox

                    // Make sure the paragraph has laid out with all typed text
                    const pTop = parseFloat(pElement.style.top) || 0;

                    // Use actual rendered height instead of estimating with lineIndex
                    const textHeight = pElement.scrollHeight;
                    // or: const textHeight = pElement.getBoundingClientRect().height;

                    doneButton.answerHeight = textHeight + 22; // small gap
                    doneButton.y = pTop + doneButton.answerHeight;

                    doneButton.offsetX = doneButton.x - parentLeft;
                    doneButton.offsetY = doneButton.y - parentTop;
                    doneButton.style.left = `${doneButton.x}px`; // Position to the right of the textbox
                    doneButton.style.top = `${doneButton.y}px`;

                    inputParent.doneButton = doneButton;
                    console.log(doneButton.style.left);
                    console.log(doneButton.style.top);

                    if (tabHeadersActivated[1]) appendToCraftCanvas(doneButton);
                    if (tabHeadersActivated[4]) appendToChatCanvas(doneButton);

                    doneButton.onclick = async function () {
                        if (passed && !manualFailed) {
                            clearInterval(activeTabInterval);

                            tabHeaders[2].classList.add('tab-active');

                            activeTabInterval = setInterval(() => {
                                tabHeaders[2].classList.toggle('tab-active');
                            }, 1000); // Adjust timing as needed (1s cycle: 0.5s fade in, 0.5s fade out)

                            const pattern = snapshotSelectionAsPattern(currentGraph, selectedSymbols);
                            let id = await synthNode(selectedSymbols, word, justification, foundIds, elimBasic, pattern);
                            library.set(word, [id, pattern]);
                            console.log('library');
                            console.log(library);
                        }
                        if (eyeButton.isActivated) {
                            eyeButton.isActivated = false;
                            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                    }
                }

                type(showDoneButton);
            }
        }



        function startLongPress(left, top, width, height, symbol=null, node=null) {
            ring = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        // Append the circle to the SVG
            ring.appendChild(circle);
            if (tabHeadersActivated[1]) appendToCraftCanvas(ring);
            if (tabHeadersActivated[4]) appendToChatCanvas(ring);

            const symbolCenterX = left + width / 2;
            const symbolCenterY = top + height / 2;

            // Create the SVG element with the desired attributes

            ring.style.left = symbolCenterX - 25;
            ring.style.top = symbolCenterY - 25;
            ring.setAttribute("class", "progress-ring");
            ring.setAttribute("width", "50");
            ring.setAttribute("height", "50");
            ring.setAttribute("viewBox", `${symbolCenterX - 27} ${symbolCenterY - 27} 54 54`);

            // Create the circle element

            circle.setAttribute("cx", symbolCenterX.toString());
            circle.setAttribute("cy", symbolCenterY.toString());

            if (symbol === null) {
                circle.setAttribute("r", width.toString());
            } else {
                circle.setAttribute("r", "25");
            }
            circle.setAttribute("stroke-width", "5");

            ring.style.visibility = "visible";

            circle.style.stroke = "#00B0F0";
            progress = 0;
            circle.style.strokeDashoffset = 157; // Reset
            interval = setInterval(() => {
                progress += 1;
                const offset = 157 * (1 - progress / totalSteps); // More precise calculation
                circle.style.strokeDashoffset = offset;

                if (progress >= totalSteps) {
                    clearInterval(interval);
                    if (symbol === null) {
                        triggerLongPressNode(node);
                    } else {
                        triggerLongPress(symbol);
                    }
                }
            }, 10);
        }

        function endLongPress() {
            if (ring !== null && circle !== null) {
                clearInterval(interval);
                ring.style.visibility = "hidden";
                circle.style.strokeDashoffset = 157;
                circle.style.stroke = "transparent";
                ring = null;
                circle = null;
            }
        }

        function triggerLongPress(symbol, representatives=null) {
            if (circle !== null) {
                circle.style.stroke = "#FFC000";
            }
            moleculeString = "";

            clearAllSymbolSelection();
            dragGroup = null;
            dragLeader = null;

            let results = getMolecule(symbol, new Set([]), representatives=representatives);
            selectedSymbols = results.visited;
            if (results.leftStr !== "") moleculeString += results.leftStr + " - "
            moleculeString += results.centerStrs.join(" & ");
            if (results.rightStr !== "") moleculeString += " - " + results.rightStr
            console.log(`resultssss left ${results.leftStr} center ${results.centerStrs} right ${results.rightStr}`);

            selectedSymbols.forEach(selectedSymbol => {
                selectedSymbol.selected = true;
                selectedSymbol.classList.add("framed");
            });
            console.log(`molecule ${moleculeString}`);
        }


        const Side = {
            START: 0,    // start
            END: 1,      // end
            MID_TOP: 2,  // top / left middle
            MID_BOT: 3,  // bottom / right middle
            PAR_TOP: 4,  // top parallel
            PAR_BOT: 5   // bottom parallel
        };

        const SINGLE_OCCUPANCY = new Set([Side.MID_TOP, Side.MID_BOT, Side.PAR_TOP, Side.PAR_BOT]);

        const MULTI_OCCUPANCY = new Set([Side.START, Side.END]);

        // Create a new copy of the symbol being clicked
        async function createSymbolCopy(mouseX, mouseY, elemId = null, elemIdTrue = null, symbolX=null, symbolY=null, symbolColor=null, symbolAngle=null, symbolId=null) {
            const { x, y } = clientToLocal(craftCanvas(), mouseX, mouseY);
            let offsetX = symbolWidth * symbolScale / 2;
            let offsetY = symbolHeight * symbolScale / 2;

            // Create the copy
            const symbol = document.createElement('div');
            symbol.ondragstart = (e) => e.preventDefault();
            symbol.selected = false;
            symbol.moving = false;
            symbol.angle = symbolAngle ? symbolAngle : 0;
            symbol.isDynamic = false;
            symbol.classList.add('symbol');
            symbol.elemId = elemId;

            elemIdTrue = elemIdTrue ? elemIdTrue : elemId;
            symbol.elemIdTrue = elemIdTrue;
            symbol.innerHTML = symbolData[symbol.elemId];

            if (symbolX === null) symbol.accId = acc;  // newly created

            if (symbolX !== null) {
                symbol.style.left = `${symbolX}px`;
                symbol.style.top = `${symbolY}px`;
            } else {
                symbol.style.left = `${x - offsetX}px`;
                symbol.style.top = `${y - offsetY}px`;
            }
            if (symbolColor !== null) {  // loaded in the chat interface
                dyeColor(symbol, symbolColor);
            } else if (tabHeadersActivated[4]) {  // newly created in the chat interface
                symbolColor = await assignUserColor();
                dyeColor(symbol, symbolColor);
            }  // otherwise, newly created in the craft interface

            if (symbolAngle !== null) {
                symbol.style.transform = `rotate(${symbolAngle}deg)`;
            }
            symbol.dot = null;


            // Add pressing event listener to the symbol
            symbol.addEventListener("mousedown", (e) => {
                const totalSelected = selectedSymbols.size + selectedEmojis.size;
                const inSelection = selectedSymbols.has(symbol);
                const wantsGroupDrag = inSelection && totalSelected > 1;

                // record click-vs-drag
                symbol._downClientX = e.clientX;
                symbol._downClientY = e.clientY;
                symbol._dragged = false;
                symbol._downWasSelected = selectedSymbols.has(symbol);
                symbol._downWasInMulti = wantsGroupDrag; // remember state at down time
                symbol._downTotalSelected = selectedSymbols.size + selectedEmojis.size;

                // UI off
                if (eyeButton.isActivated) { eyeButton.isActivated=false; eyeButton.style.backgroundImage="url('./icons/eye_black.png')"; removeLabelInputs(); }
                if (eyeButton2.isActivated){ eyeButton2.isActivated=false; eyeButton2.style.backgroundImage="url('./icons/eye_black.png')"; removeLabelInputs(); }

                // ‚úÖ Selection on mousedown:
                // If it was not selected, make it the only selection (single-select).
                // If it was already selected, keep selection as-is for now (toggle happens on mouseup if no drag).
                if (!inSelection) {
                    clearAllSymbolSelection();
                    clearAllEmojiSelection();
                    symbol.selected = true;
                    symbol.classList.add("framed");
                    selectedSymbols.add(symbol);
                }

                // long press ok
                startLongPress(parseFloat(symbol.style.left), parseFloat(symbol.style.top), symbolWidth * symbolScale, symbolHeight * symbolScale, symbol);

                // owner-only drag
                if (!canEditElement(symbol)) {
                    symbol.style.cursor = "not-allowed";
                    // allow click-to-toggle selection for others
                    clickOnlySymbol = symbol;
                    return; // no dragging
                }

                symbol.style.cursor = "grabbing";
                symbol.moving = false;

                const canvas = getCanvasForElem(symbol);
                const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

                if (wantsGroupDrag) {
                    dragLeader = symbol;
                    dragGroup = new Map();

                    setDragSnapLock(null, "start drag");
                    pendingSnapDelta = null;
                    readyActive = readyTarget = null;
                    readyActiveSide = readyTargetSide = null;
                    dragGroupStarted = false;
                    dragGroupSet = null;

                    const groupSet = buildDragGroupSet(dragLeader);
                    for (const el of groupSet) {
                    if (!canEditElement(el)) continue; // can't drag others' items

                    const left = parseFloat(el.style.left) || 0;
                    const top  = parseFloat(el.style.top)  || 0;
                    const dx = left - localX;
                    const dy = top  - localY;

                    dragGroup.set(el, { dx, dy, dx0: dx, dy0: dy });
                    }

                    activeSymbol = symbol; // leader remains active
                } else {
                    dragLeader = null;
                    dragGroup = null;

                    activeSymbol = symbol;
                    const left = parseFloat(symbol.style.left) || 0;
                    const top  = parseFloat(symbol.style.top)  || 0;
                    symbol.offsetX = localX - left;
                    symbol.offsetY = localY - top;
                }
            });


            /* if horizontal: left, right, top perpendicular, bottom perpendicular, top parallel, bottom parallel */
            /* if vertical: top, down, left perpendicular, right perpendicular, left parallel, right parallel */
            currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

            if (tabHeadersActivated[1]) appendToCraftCanvas(symbol);
            if (tabHeadersActivated[4] || symbolX !== null) appendToChatCanvas(symbol);

            if (selectedSymbols.size !== 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    selectedSymbol.selected = false;
                    selectedSymbol.classList.remove("framed");
                    selectedSymbols.delete(selectedSymbol);
                });
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
                if (eyeButton2.isActivated) {
                    eyeButton2.isActivated = false;
                    eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
            }
            if (symbolX === null) {
                activeSymbol = symbol;
            }
            symbol.offsetX = offsetX;
            symbol.offsetY = offsetY;

            if (tabHeadersActivated[4] || symbolX!==null) {
                // Get div attributes
                const symbolPacket = {
                    elemId:elemId,
                    elemIdTrue:elemIdTrue,
                    color:symbolColor,
                    angle:0,
                    dotX:null,
                    dotY:null
                };

                if (symbolId !== null) {
                    symbol.dataset.id = symbolId;
                } else {
                    // after you created the DOM element `symbol`
                    symbol.dataset.id = "";                 // not ready yet
                    symbol._pendingIdPromise = (async () => {
                        const docId = await saveObj("symbol", symbolPacket, parseFloat(symbol.style.left), parseFloat(symbol.style.top));
                        symbol.dataset.id = docId;
                        return docId;
                    })();
                }
            }

            return symbol;
        }

        // Find all the symbols that are connected to one symbol
        function getMolecule(currentSymbol, visited, representatives=null) {
            visited.add(currentSymbol);

            console.log(`visit`);
            console.log(visited);
            console.log(currentSymbol);
            let leftStr = "";
            let centerStrs = [getMoleculeChar(currentSymbol)];
            console.log(`representatives`);
            console.log(representatives);
            if (representatives != null && representatives.has(currentSymbol)) {
                centerStrs.push(representatives.get(currentSymbol));
            }

            let rightStr = "";
            for (let i = 0; i < currentGraph.getSymbolConnections(currentSymbol).length; i++) {  // every magnet point
                for (const entry of currentGraph.getSymbolConnections(currentSymbol)[i]) {  // entry = [every other symbol connected to my magnet point, its magnet point]
                    if (!visited.has(entry[0])) {
                        let results = getMolecule(entry[0], visited, representatives=representatives);
                        visited = results.visited;
                        console.log(`entry[0] ${entry[0].elemId} entry[1] ${entry[1]}`);
                        if (entry[1] > 1 || i > 1) {
                            if (leftStr !== "" && results.leftStr !== "") {
                                leftStr = "(" + leftStr + ") & (" + results.leftStr + ")";
                            } else if (leftStr == "") {
                                leftStr = results.leftStr;
                            }
                            centerStrs.push(...results.centerStrs);
                            if (rightStr !== "" && results.rightStr !== "") {
                                rightStr = "(" + rightStr + ") & (" + results.rightStr + ")";
                            } else if (rightStr == "") {
                                rightStr = results.rightStr;
                            }
                            console.log(`me ${currentSymbol.elemId} entry[0] ${entry[0].elemId} centerStrs ${centerStrs.join(" & ")}`);
                        } else {
                            if (i === 0) {
                                if (results.leftStr !== "") leftStr += results.leftStr + " - "
                                leftStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") leftStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} left entry[0] ${leftStr} centerStrs ${centerStrs.join(" & ")}`);
                            } else if (i === 1) {
                                if (results.leftStr !== "") rightStr += results.leftStr + " - "
                                rightStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") rightStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} right entry[0] ${rightStr} centerStrs ${centerStrs.join(" & ")}`);
                            }
                        }

                    }
                }
            }
            console.log(`me ${currentSymbol.elemId}`);
            console.log(`left ${leftStr} center ${centerStrs.join(" & ")} right ${rightStr}`)
            console.log(`visited ${visited.size}`);
            return {visited: visited, leftStr: leftStr, centerStrs: centerStrs, rightStr: rightStr};
        }

        function getMoleculeChar(symbol) {
            const table = ['ƒ°', 'ƒã', 'g', 'c', 'r', 'l', 'v', 'f', 'd', 't', 'b', 'p', 's', 'z', '·π°', '≈º', 'n', 'm'];
            let char = table[symbol.elemIdTrue * 2 + Number(symbol.isDynamic)];
            if (char === 'g' || char === 'c' || char === 'v' || char === 'd' || char === 't' || char === 's') {
                if (symbol.angle === 0 || symbol.angle === 180) {
                    char += ' horizontal';
                } else {
                    char += ' vertical';
                }
            }
            return char;
        }

        // Check for snapping connections
        function checkConnections(active) {
            let targetX;
            let targetY;
            readyActive = null;
            readyTarget = null;
            readyActiveSide = null;
            readyTargetSide = null;
            for (const target of currentGraph.getSymbols()) {
                 // Skip the active symbol itself
                if (target === active) continue;
                // During group drag, ignore targets inside the dragged group
                if (groupDragActive && dragGroupSet && dragGroupSet.has(target)) continue;

                const activeJunctions = getAbsJunctions(active);
                const targetJunctions = getAbsJunctions(target);

                targetJunctions.forEach((targetCoord, index) => {
                    switch (index) {
                        case 0: // connected at the left / top start
                            if (getDir(active) === getDir(target)) { // active right >=< target left
                                snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, Side.END, Side.START);
                            } else {
                                const [first, second, , fourth] = activeJunctions;  // valid coordinates for connecting
                                snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, Side.START, Side.START, 'Âßã');
                                if (getDir(active) === 0) {  // target
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, Side.END, Side.START, 'Âßã');
                                } else {
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y + calY, Side.END, Side.START, 'heihei');
                                }
                                snapToSymbol(active, target, fourth.x, fourth.y, targetCoord.x, targetCoord.y, Side.MID_BOT, Side.START, 'Âßã');
                            }
                            break;
                        case 1:  // connected at the right / bottom end
                            if (getDir(active) === getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, Side.START, Side.END, "snap to the right");
                            } else {
                                const [first, second, third] = activeJunctions.slice(0, 3);  // valid coordinates for connecting
                                if (getDir(active) === 1) {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, Side.START, Side.END, 'Êú´');
                                } else {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y - calY, Side.START, Side.END, 'meimei');
                                }
                                snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, Side.END, Side.END, 'Êú´');
                                snapToSymbol(active, target, third.x, third.y, targetCoord.x, targetCoord.y, Side.MID_TOP, Side.END, 'Êú´');
                            }
                            break;
                        case 2:  // perpendicular: inserted at the top / left middle
                            if (getDir(active) !== getDir(target)) {
                                if (getDir(active) === 0) {  // horizontal active inserted on vertical target ‰∏ä
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, Side.END, Side.MID_TOP, "Âçú");
                                } else {
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, Side.END, Side.MID_TOP, "‰∏ä");
                                }
                            }
                            break;
                        case 3:  // perpendicular: inserted at bottom / right middle ‰∏ã
                            if (getDir(active) !== getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, Side.START, Side.MID_BOT, "‰∏ã");
                            }
                            break;
                    }
                });

                if (getDir(active) === getDir(target)) {  // parallel
                    if (getDir(active) === 0) {
                        targetX = parseFloat(target.style.left);
                        targetY = parseFloat(target.style.top) - (symbolHeight - 7) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[Side.PAR_TOP].length === 0) {
                            snapToSymbol(active, target, parseFloat(active.style.left), parseFloat(active.style.top), targetX, targetY, Side.PAR_BOT, Side.PAR_TOP);
                        }
                        targetY = parseFloat(target.style.top) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[Side.PAR_BOT].length === 0) {
                            snapToSymbol(active, target, parseFloat(active.style.left), parseFloat(active.style.top), targetX, targetY, Side.PAR_TOP, Side.PAR_BOT);
                        }
                    }
                    if (getDir(active) === 1) {
                        targetX = parseFloat(target.style.left) - (symbolHeight - 7) * symbolScale;
                        targetY = parseFloat(target.style.top);
                        if (currentGraph.getSymbolConnections(target)[Side.PAR_TOP].length === 0) {
                            snapToSymbol(active, target, parseFloat(active.style.left), parseFloat(active.style.top), targetX, targetY, Side.PAR_BOT, Side.PAR_TOP);
                        }
                        targetX = parseFloat(target.style.left) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[Side.PAR_BOT].length === 0) {
                            snapToSymbol(active, target, parseFloat(active.style.left), parseFloat(active.style.top), targetX, targetY, Side.PAR_TOP, Side.PAR_BOT);
                        }
                    }
                }
            }
        }

        // Get the offset for the symbol when connected to another symbol (side 0 = left, 1 = right)
        function getRelJunctions(symbol) {
            let junctions; // [start, end, middle_1, middle_2]
            switch (symbol.elemId) {
                case 0:
                    junctions = [{x: 1, y: 13}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 1:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 2:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 14}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 3:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 4:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 5:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 6:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 7:
                    junctions = [{x: 1, y: 32}, {x: symbolWidth - calX, y: 32}, {x: symbolWidth / 2, y: 3}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 8:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
            }
            return junctions;
        }

        function getAbsJunctions(symbol) {
            const relJunctions = getRelJunctions(symbol);
            const rect = symbol.getBoundingClientRect();
            let absJunctions;
            if (symbol.angle === 0) {
                absJunctions = [{x: rect.left + relJunctions[0].x * symbolScale, y: rect.top + relJunctions[0].y * symbolScale},
                                {x: rect.left + relJunctions[1].x * symbolScale, y: rect.top + relJunctions[1].y * symbolScale},
                                {x: rect.left + relJunctions[2].x * symbolScale, y: rect.top + relJunctions[2].y * symbolScale},
                                {x: rect.left + relJunctions[3].x * symbolScale, y: rect.top + relJunctions[3].y * symbolScale}];
            }
            if (symbol.angle === 180) {
                absJunctions = [{x: rect.right - relJunctions[1].x * symbolScale, y: rect.bottom - relJunctions[1].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[0].x * symbolScale, y: rect.bottom - relJunctions[0].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[3].x * symbolScale, y: rect.bottom - relJunctions[3].y * symbolScale},
                                {x: rect.right - relJunctions[2].x * symbolScale, y: rect.bottom - relJunctions[2].y * symbolScale}];
            }
            if (symbol.angle === 90) {
                absJunctions = [{x: rect.right - relJunctions[0].y * symbolScale, y: rect.top + relJunctions[0].x * symbolScale},
                                {x: rect.right - relJunctions[1].y * symbolScale, y: rect.top + relJunctions[1].x * symbolScale},
                                {x: rect.right - relJunctions[3].y * symbolScale, y: rect.top + relJunctions[3].x * symbolScale},
                                {x: rect.right - relJunctions[2].y * symbolScale, y: rect.top + relJunctions[2].x * symbolScale}];
            }
            if (symbol.angle === 270) {
                absJunctions = [{x: rect.left + relJunctions[1].y * symbolScale + calInvY, y: rect.bottom - relJunctions[1].x * symbolScale},
                                {x: rect.left + relJunctions[0].y * symbolScale + calInvY, y: rect.bottom - relJunctions[0].x * symbolScale},
                                {x: rect.left + relJunctions[2].y * symbolScale, y: rect.bottom - relJunctions[2].x * symbolScale},
                                {x: rect.left + relJunctions[3].y * symbolScale, y: rect.bottom - relJunctions[3].x * symbolScale}];
            }
            if (symbol.elemId === 2) {
                if (symbol.angle === 0) {
                    absJunctions[2].x += calCan1;
                    absJunctions[3].x += calCan1;
                }
                if (symbol.angle === 270) {
                    absJunctions[2].y -= calCan1;
                    absJunctions[3].y -= calCan1;
                }
                if (symbol.angle === 90) {
                    absJunctions[2].y -= calCan2;
                    absJunctions[3].y -= calCan2;
                }
                if (symbol.angle === 180) {
                    absJunctions[2].x += calCan2;
                    absJunctions[3].x += calCan2;
                }
            }

            return absJunctions;
        }

        function getDist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function getDir(symbol) {
            if (symbol.angle === 0 || symbol.angle === 180) {
                return 0;  // horizontal
            }
            if (symbol.angle === 90 || symbol.angle === 270) {
                return 1;  // vertical
            }
        }


        // Side conflict rules: prevent ugly overlaps (parallel vs mid insert)
        const SIDE_CONFLICTS = new Map([
            [Side.MID_TOP, [Side.PAR_TOP]],
            [Side.MID_BOT, [Side.PAR_BOT]],
            [Side.PAR_TOP, [Side.MID_TOP]],
            [Side.PAR_BOT, [Side.MID_BOT]],
        ]);

        // Snap active symbol to target
        function snapToSymbol(active, target, activeX, activeY, targetX, targetY, activeSide, targetSide, msg = "") {
            if (groupDragActive && dragGroupSet && dragGroupSet.has(target)) return;

            const tConns = currentGraph.getSymbolConnections(target)?.[targetSide] || [];

            // Treat "occupied" as: not myself AND not in my current drag group
            const isOther = (nbr) => nbr !== active && !(dragGroupSet && dragGroupSet.has(nbr));

            // ---- 1) Occupancy rules ----
            if (SINGLE_OCCUPANCY.has(targetSide)) {
                // Sides 2/3/4/5: only one occupant allowed (ignore self + group)
                if (tConns.some(([nbr]) => isOther(nbr))) return;
            } else {
                // Sides 0/1: multi-occupancy allowed, but prevent "overlap"
                for (const [nbr, nbrSide] of tConns) {
                if (!isOther(nbr)) continue;              // ignore self + group members
                if (getDir(nbr) === getDir(active) && nbrSide === activeSide) return;
                }
            }

            // ---- 1.5) Visual overlap conflicts: block snap early (mousemove stage) ----
            // If the target side would conflict with existing attachments on the target, don't even snap.
            if (violatesConflicts(target, targetSide)) return;

            // (Optional) Also block if active side conflicts with existing attachments on active itself.
            // This prevents snapping into crowded areas on the moving symbol.
            if (violatesConflicts(active, activeSide)) return;

            // ---- 2) Distance check ----
            if (getDist(activeX, activeY, targetX, targetY) >= SNAP_DISTANCE) return;


            const oldX = parseFloat(active.style.left) || 0;
            const oldY = parseFloat(active.style.top)  || 0;

            const dx = (targetX - activeX);
            const dy = (targetY - activeY);

            // Record candidate connection (mouse up will finalize)
            readyActive = active;
            readyTarget = target;
            readyActiveSide = activeSide;
            readyTargetSide = targetSide;

            // ---- 3) Group drag: request a delta for the whole group ----
            if (groupDragActive) {
                pendingSnapDelta = { dx, dy };
                return;
            }

            // ---- 4) Single drag: move immediately ----
            active.style.left = `${oldX + dx}px`;
            active.style.top  = `${oldY + dy}px`;
        }


        // Add an event listener for clicks on the document
        document.addEventListener("click", (event) => {
            // Get the mouse coordinates
            const x = event.clientX; // X-coordinate relative to the viewport
            const y = event.clientY; // Y-coordinate relative to the viewport

            // Print the coordinates to the console
            console.log(`Mouse clicked at: X = ${x}, Y = ${y}`);
            console.log(currentGraph);
        });


        /* Library */
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;
        let nodeTextBoxes = {};
        let container = document.getElementById("network");
        let data = {nodes: nodes, edges: edges};
        let basicNodeIds = new Set();
        let options = {
            nodes: {
                shape: "circularImage",
                borderWidth: 3,
                color: {
                    border: "black",
                    background: "white",
                    highlight: {
                        border: "black",
                        background: "#f0f0f0" // Light gray on hover
                    },
                    hover: {
                        border: "black",
                        background: "#e0e0e0" // Slightly darker gray on hover
                    }
                },
                shapeProperties: { useBorderWithImage: true },
                size: 20
            },
            edges: {
                smooth: false
            },
            physics: { enabled: true }
        };

        async function initNodes() {
            for (let i = 0; i < symbolData.length; i++) {
                const svgString = symbolData[i];
                const id = await generateUniqueId(svgString);
                nodes.add({
                    id,
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    word: "",
                    title: symbolTitles[i]
                });
                basicNodeIds.add(id);
            }

            network = new vis.Network(container, data, options);

            await loadLibraryGraphForUser();
            rebuildLibraryFromNodes();

            network.once('afterDrawing', function () {
                // Assuming 'container' is the DOM element where the network is rendered
                let containerWidth = container.offsetWidth;
                let containerHeight = container.offsetHeight;
                let scale = 1.5;
                console.log(containerWidth, containerHeight)
                network.moveTo({
                    offset: {
                        x: (0.5 * containerWidth) * scale,
                        y: (0.5 * containerHeight) * scale
                    },
                    scale: scale
            });});
            network.on("dragEnd", () => scheduleSaveLibraryGraph());
        }

        function exportGraphState() {
            // nodes.get() returns fields in the dataset (x/y may be absent)
            const allNodes = nodes.get();
            const allEdges = edges.get();

            // Get current positions (if network not ready, skip)
            const pos = network ? network.getPositions(allNodes.map(n => n.id)) : {};

            const exportNodes = allNodes.map(n => ({
                id: n.id,
                word: n.word || "",
                title: n.title || "",
                svg: n._svg || null,
                x: pos[n.id]?.x ?? null,
                y: pos[n.id]?.y ?? null,
                pattern: n.pattern ? serializePatternGraph(n.pattern) : null,
            }));

            const exportEdges = allEdges.map(e => ({
                id: e.id || `${e.from}->${e.to}`,
                from: e.from,
                to: e.to,
            }));

            return { nodes: exportNodes, edges: exportEdges };
        }

        async function saveLibraryGraphForUser() {
            if (!currentUser) return;

            const ref = doc(db, "users", currentUser.uid, "libraryGraph", "state");
            const state = exportGraphState();

            await setDoc(ref, {
            nodes: state.nodes,
            edges: state.edges,
            updatedAt: serverTimestamp(),
            }, { merge: true });
        }

        async function loadLibraryGraphForUser() {
            if (!currentUser) return;

            const ref = doc(db, "users", currentUser.uid, "libraryGraph", "state");
            const snap = await getDoc(ref);
            if (!snap.exists()) return;

            const { nodes: savedNodes = [], edges: savedEdges = [], view = null } = snap.data();

            // 1) add nodes if absent in dataset, otherwise update word/title/pos
            for (const sn of savedNodes) {
                // If the node already exists in the dataset, update it; otherwise add it.
                const exists = nodes.get(sn.id);

                // Deserialize pattern safely (supports old records without pattern)
                const parsedPattern = sn.pattern ? deserializePatternGraph(sn.pattern) : null;

                if (!exists) {
                    // Synthesized nodes need svg to rebuild the image
                    if (!sn.svg) continue;

                    // Better debug (do not stringify via '+')
                    console.warn("[load node]", {
                        id: sn.id,
                        word: sn.word,
                        hasPattern: !!sn.pattern,
                        parsedPattern
                    });

                    nodes.add({
                        id: sn.id,
                        shape: "circularImage",
                        image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(sn.svg)),
                        word: sn.word || "",
                        title: sn.title || "",
                        x: sn.x ?? undefined,
                        y: sn.y ?? undefined,
                        _svg: sn.svg,
                        pattern: parsedPattern, // PatternGraph instance or null
                    });
                } else {
                    nodes.update({
                        id: sn.id,
                        word: sn.word || exists.word || "",
                        title: sn.title || exists.title || "",
                        ...(sn.x != null && sn.y != null ? { x: sn.x, y: sn.y } : {}),
                        ...(sn.svg ? { _svg: sn.svg } : {}),
                        // only overwrite pattern if saved data actually has one
                        ...(sn.pattern !== undefined ? { pattern: parsedPattern } : {}),
                    });
                }
            }

            // 2) add edges
            for (const se of savedEdges) {
                // avoid repeating edges
                const already = edges.get(se.id);
                if (already) continue;

                edges.add({
                    id: se.id || `${se.from}__${se.to}`, // generate one if absent
                    from: se.from,
                    to: se.to,
                    arrows: { to: { enabled: true } },
                    color: { color: "black" }
                });
            }
        }

        function rebuildLibraryFromNodes() {
            library.clear();

            for (const n of nodes.get()) {
                if (!n.word) continue;
                if (!n.pattern) continue; // basic nodes may not have pattern

                library.set(n.word, [n.id, n.pattern]); // n.pattern is PatternGraph (deserialized)
            }
        }

        async function deleteLibraryNodeForUser(uid, nodeId) {
            const ref = doc(db, "users", uid, "libraryNodes", nodeId);
            await deleteDoc(ref);
        }

        async function deleteLibraryEdgeForUser(uid, edgeId) {
            const ref = doc(db, "users", uid, "libraryEdges", edgeId);
            await deleteDoc(ref);
        }

        function capitalizeFirstLetter(val) {
            return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }

        function scaleSVG(svgString, targetSize = 40) {
            // Parse SVG string
            let parser = new DOMParser();
            let doc = parser.parseFromString(svgString, "image/svg+xml");
            let svg = doc.documentElement;

            let viewBox = svg.getAttribute("viewBox");
            let width = parseFloat(svg.getAttribute("width"));
            let height = parseFloat(svg.getAttribute("height"));

            if (viewBox) {
                let [x, y, w, h] = viewBox.split(" ").map(parseFloat);
                width = w;
                height = h;
            }

            if (!width || !height) return svgString; // Fallback: return original SVG

            // Calculate scale factor
            let scale = (targetSize * 0.6) / Math.max(width, height);

            // Calculate translation to center the scaled content
            let translateX = (targetSize - width * scale) / 2;
            let translateY = (targetSize - height * scale) / 2;

            // Apply transform
            let transform = `translate(${translateX}, ${translateY}) scale(${scale})`;

            // Wrap everything inside a group <g> element to apply transformations
            let group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("transform", transform);
            while (svg.firstChild) {
                group.appendChild(svg.firstChild);
            }
            svg.innerHTML = ""; // Clear original SVG
            svg.appendChild(group);

            // Set viewBox to match the target circle size
            svg.setAttribute("width", targetSize);
            svg.setAttribute("height", targetSize);
            svg.setAttribute("viewBox", `0 0 ${targetSize} ${targetSize}`);

            return new XMLSerializer().serializeToString(svg);
        }

        // Synthesize a node from its components and connect the component nodes to the synthesized node
        async function synthNode(components, word, justification, foundIds, elimBasic, pattern) {
            let leftMost = 2 * document.documentElement.scrollWidth;
            let rightMost = -document.documentElement.scrollWidth;
            let topMost = 2 * document.documentElement.scrollHeight;
            let bottomMost = -document.documentElement.scrollHeight;
            let rect;
            let svgString = "";
            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                if (rect.left < leftMost) leftMost = rect.left;
                if (rect.right > rightMost) rightMost = rect.right;
                if (rect.top < topMost) topMost = rect.top;
                if (rect.bottom > bottomMost) bottomMost = rect.bottom;

                if (symbol.dot != null) {
                    rect = symbol.dot.getBoundingClientRect();
                    if (rect.left < leftMost) leftMost = rect.left;
                    if (rect.right > rightMost) rightMost = rect.right;
                    if (rect.top < topMost) topMost = rect.top;
                    if (rect.bottom > bottomMost) bottomMost = rect.bottom;
                }
            });
            console.log(`left ${leftMost} right ${rightMost} top ${topMost} bottom ${bottomMost}`);
            const ratio = 49.92 / (symbolWidth * symbolScale);

            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                let transX;
                let transY;
                switch(symbol.angle) {
                    case 0: transX = rect.left; transY = rect.top; break;
                    case 90: transX = rect.right; transY = rect.top; break;
                    case 180: transX = rect.right; transY = rect.bottom; break;
                    case 270: transX = rect.left; transY = rect.bottom; break;
                }
                svgString += `<g transform="translate(` + ((transX - leftMost) * ratio).toString() + `, ` + ((transY - topMost) * ratio).toString()
                            + `) rotate(` + symbol.angle.toString() + `)">` + symbol.querySelector("svg").innerHTML + `</g>\n`;

                if (symbol.dot != null) {
                    console.log("added dot!");
                    rect = symbol.dot.getBoundingClientRect();
                    svgString += `<g transform="translate(` + ((rect.left - leftMost) * ratio).toString() + `, ` + ((rect.top - topMost) * ratio).toString()
                    + `)">` + dotDataMini + `</g>\n`;
                }
            });


            const widthStr = ((rightMost - leftMost) * ratio).toString();
            const heightStr = ((bottomMost - topMost) * ratio).toString();
            svgString = `<svg width="` + widthStr + `" height="` + heightStr
                        + `" viewBox="0 0 ` + widthStr + ` ` + heightStr + `" xmlns="http://www.w3.org/2000/svg">\n`
                        + svgString
                        +  `</svg>`;

            let id = await generateUniqueId(svgString);
            let hasDuplicate = false;
            nodes.forEach(node => {
                if (node['id'] === id) {
                    hasDuplicate = true;
                }
            });

            if (!hasDuplicate) {
                const serializedPattern = serializePatternGraph(pattern);
                let newNode = {
                    id: id,
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    word: word,
                    title: capitalizeFirstLetter(word) + ". " + capitalizeFirstLetter(justification),
                    _svg: svgString,
                    pattern: serializedPattern,
                };

                nodes.add(newNode); // Add node to dataset
                for (const symbol of selectedSymbols) {
                    if (!elimBasic.has(symbol)) addEdge(await generateUniqueId(symbolData[symbol.elemIdTrue]), id);
                }
                for (const foundId of foundIds) {
                    addEdge(foundId, id);
                }
            }

            scheduleSaveLibraryGraph();
            return id;
        }

        let saveTimer = null;
        function scheduleSaveLibraryGraph() {
            clearTimeout(saveTimer);
            saveTimer = setTimeout(() => {
                saveLibraryGraphForUser().catch(console.error);
            }, 500);
        }

        function addEdge(sourceId, targetId) {
            // Get all existing edges
            const existingEdges = edges.get();

            // Check if the edge already exists between the two nodes, in either direction
            const edgeExists = existingEdges.some(edge => {
                return (edge.from === sourceId && edge.to === targetId) || (edge.from === targetId && edge.to === sourceId);
            });

            if (!edgeExists) {
                edges.add({
                    from: sourceId,
                    to: targetId,
                    arrows: { to: { enabled: true } },
                    color: { color: "black" }
                });
                console.log(`link ${sourceId} ${targetId}`);
            }
        }

        async function generateUniqueId(svgString) {
            console.log(`used string ${svgString}`);
            // Ensure consistent encoding
            const encoder = new TextEncoder();
            const data = encoder.encode(svgString.trim());  // Trim to avoid whitespace inconsistencies

            // Compute SHA-256 hash
            const hashBuffer = await crypto.subtle.digest("SHA-256", data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));

            // Convert hash to a base64 string (URL-safe)
            return "svg-" + btoa(String.fromCharCode(...hashArray))
                .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")  // Remove padding
                .substring(0, 16); // Trim for shorter ID
        }

        // immediately fetch regardless of the tab
        fetch("./world.json")
        .then(r => r.json())
        .then(data => {
            worldData = data.world;
            console.log("World data loaded");
        });

        function renderWorld() {
            if (worldRendered) return;
            if (!worldData) return; // data has not arrived yet

            const world = document.getElementById("world");
            const content = document.getElementById("worldContent");

            // Now the world is displayed, we can safely measure it
            const W = world.offsetWidth;
            const H = world.offsetHeight;

            worldData.islands.forEach(islandData => {
                const islandSVG = createIslandSVG(islandData);
                islandSVG.style.left = islandData.x * W + "px";
                islandSVG.style.top  = islandData.y * H + "px";
                content.appendChild(islandSVG);
            });

            worldRendered = true;
        }

        function createIslandSVG(islandData) {
            const blockSize = 20;
            const radius = 5;      // ‰Ω†Ë¶ÅÁöÑ 5px ÂúÜËßí
            const strokeW = 2;
            const highlightExtra = 8;
            const highlightW = strokeW + highlightExtra;

            const maxStroke = Math.max(strokeW, highlightW);
            const pad = maxStroke / 2;

            const blocks = islandData.blocks;
            if (!blocks?.length) return null;

            // ====== 0) Âπ≥ÁßªÂà∞Ê≠£Âå∫Èó¥ ======
            const minX = Math.min(...blocks.map(b => b.x));
            const minY = Math.min(...blocks.map(b => b.y));
            const xs = blocks.map(b => b.x - minX);
            const ys = blocks.map(b => b.y - minY);
            const width = Math.max(...xs) + 1;
            const height = Math.max(...ys) + 1;

            // occupancy matrix
            const matrix = Array.from({ length: height }, () => Array(width).fill(false));
            blocks.forEach(b => (matrix[b.y - minY][b.x - minX] = true));

            // ====== 1) edge cancellationÔºöÂè™‰øùÁïôÂ§ñËæπÁïåËæπ ======
            const edgeMap = new Map();
            const eKey = (x1, y1, x2, y2) => `${x1},${y1}->${x2},${y2}`;
            const eRev = (x1, y1, x2, y2) => `${x2},${y2}->${x1},${y1}`;

            function addEdge(x1, y1, x2, y2) {
                const rk = eRev(x1, y1, x2, y2);
                if (edgeMap.has(rk)) edgeMap.delete(rk);
                else edgeMap.set(eKey(x1, y1, x2, y2), { x1, y1, x2, y2 });
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!matrix[y][x]) continue;
                    addEdge(x, y, x + 1, y);         // top
                    addEdge(x + 1, y, x + 1, y + 1); // right
                    addEdge(x + 1, y + 1, x, y + 1); // bottom
                    addEdge(x, y + 1, x, y);         // left
                }
            }

            const edges = Array.from(edgeMap.values());
            if (!edges.length) return null;

            // ====== 2) Trace closed loops directly from directed boundary edges ======
            // edgeMap currently stores directed outer boundary edges with consistent orientation.
            const parsePoint = (k) => {
                const [x, y] = k.split(",").map(Number);
                return { x, y };
            };

            const startKey = (e) => `${e.x1},${e.y1}`;
            const endKey   = (e) => `${e.x2},${e.y2}`;
            const edgeKey  = (e) => `${e.x1},${e.y1}->${e.x2},${e.y2}`;

            // Build "outgoing directed edges" index: startPoint -> [edge, edge, ...]
            const outgoing = new Map();
            for (const e of edges) {
                const sk = startKey(e);
                if (!outgoing.has(sk)) outgoing.set(sk, []);
                outgoing.get(sk).push(e);
            }

            // Optional but helpful: stable ordering (prevents random traversal differences)
            for (const arr of outgoing.values()) {
                arr.sort((a, b) => {
                    // sort by end point
                    if (a.x2 !== b.x2) return a.x2 - b.x2;
                    return a.y2 - b.y2;
                });
            }

            const visitedDir = new Set();
            const loops = [];

            for (const e0 of edges) {
                const k0 = edgeKey(e0);
                if (visitedDir.has(k0)) continue;

                const loop = [];
                let cur = e0;

                // start point
                loop.push({ x: cur.x1, y: cur.y1 });

                let guard = 0;
                while (cur && guard++ < 200000) {
                    visitedDir.add(edgeKey(cur));

                    // append current edge end point
                    loop.push({ x: cur.x2, y: cur.y2 });

                    const nextStart = `${cur.x2},${cur.y2}`;

                    // If we returned to the first point, loop closed
                    const first = loop[0];
                    if (cur.x2 === first.x && cur.y2 === first.y) break;

                    const candidates = outgoing.get(nextStart) || [];

                    // choose the first unvisited outgoing edge from this vertex
                    // (for orthogonal pixel boundary, this is usually unique)
                    let next = null;
                    for (const e of candidates) {
                        if (!visitedDir.has(edgeKey(e))) {
                            next = e;
                            break;
                        }
                    }

                    // Fallback: if all are visited but not closed, data/traversal issue
                    if (!next) break;

                    cur = next;
                }

                // accept only closed loops
                if (loop.length >= 4) {
                    const a = loop[0];
                    const b = loop[loop.length - 1];
                    if (a.x === b.x && a.y === b.y) {
                        loops.push(loop);
                    }
                }
            }

            // ====== 3) Ê∏ÖÁêÜÔºöÂéªÊéâÂÖ±Á∫øÁÇπÔºà‰øùËØÅÁõ¥Á∫ø‰ªçÊòØÁõ¥Á∫øÔºå‰∏ç‚ÄúÈí¢Á¨îÂåñ‚ÄùÔºâ ======
            function isCollinear(a, b, c) {
                // (b-a) x (c-b) == 0
                const abx = b.x - a.x, aby = b.y - a.y;
                const bcx = c.x - b.x, bcy = c.y - b.y;
                return (abx * bcy - aby * bcx) === 0;
            }

            function simplifyLoop(loop) {
                // loop ÊòØÈó≠ÂêàÁöÑÔºöÊúÄÂêé‰∏Ä‰∏™ÁÇπ==Á¨¨‰∏Ä‰∏™ÁÇπÔºàÊàë‰ª¨ÂÖÅËÆ∏‰∏ç‰∏•Ê†ºÔºåÂÖàÂº∫Âà∂Èó≠ÂêàÔºâ
                const first = loop[0];
                const last = loop[loop.length - 1];
                const closed = (first.x === last.x && first.y === last.y) ? loop : [...loop, { ...first }];

                // ÂéªÊéâËøûÁª≠ÈáçÂ§çÁÇπ
                const dedup = [closed[0]];
                for (let i = 1; i < closed.length; i++) {
                    const p = closed[i], q = dedup[dedup.length - 1];
                    if (p.x !== q.x || p.y !== q.y) dedup.push(p);
                }

                // ÂéªÂÖ±Á∫øÁÇπÔºà‰øùÁïôÊãêËßíÔºâ
                const out = [];
                for (let i = 0; i < dedup.length; i++) {
                    const prev = dedup[(i - 1 + dedup.length) % dedup.length];
                    const cur = dedup[i];
                    const next = dedup[(i + 1) % dedup.length];
                    // ‰∏çÂà†Èô§Èó≠ÂêàÁÇπÊú¨Ë∫´ÁöÑÂç†‰ΩçÔºöÊúÄÂêé‰∏Ä‰∏™ÁÇπÁ≠â‰∫éÁ¨¨‰∏Ä‰∏™ÁÇπÔºåÊúÄÂêéÂÜçÂ§ÑÁêÜ
                    out.push(cur);
                }

                // out ‰ªçÂê´Èó≠ÂêàÈáçÂ§çÁÇπÔºåÂÖàÂéªÊéâÊúÄÂêé‰∏Ä‰∏™ÈáçÂ§çÁÇπ
                if (out.length >= 2) {
                    const a = out[0], b = out[out.length - 1];
                    if (a.x === b.x && a.y === b.y) out.pop();
                }

                const simplified = [];
                for (let i = 0; i < out.length; i++) {
                    const prev = out[(i - 1 + out.length) % out.length];
                    const cur = out[i];
                    const next = out[(i + 1) % out.length];
                    if (!isCollinear(prev, cur, next)) simplified.push(cur);
                }

                // ÈáçÊñ∞Èó≠Âêà
                if (simplified.length >= 3) simplified.push({ ...simplified[0] });
                return simplified;
            }

            const simpleLoops = loops
                .map(simplifyLoop)
                .filter(l => l.length >= 4); // Ëá≥Â∞ë‰∏âËßíÂΩ¢+Èó≠ÂêàÁÇπ

            // ====== 4) ÁîüÊàê‚ÄúÂè™Âú® 90¬∞ ÊãêËßíÂúÜËßí‚ÄùÁöÑ pathÔºàÂõ∫ÂÆöÂçäÂæÑ radius pxÔºâ ======
            function roundedOrthogonalPath(loop, rPx, scalePx) {
                // loop: Èó≠ÂêàÁÇπÂàóÔºåÊúÄÂêé‰∏Ä‰∏™ÁÇπ==Á¨¨‰∏Ä‰∏™ÁÇπÔºõÁÇπÂùêÊ†áÂçï‰Ωç=cell
                // Âè™ÂØπÁúüÊ≠£ÊãêËßíÔºàÈùûÂÖ±Á∫øÔºâÂÅöÂúÜËßí„ÄÇÁî±‰∫éÊàë‰ª¨Â∑≤ simplifyÔºåÊâÄÊúâÁÇπÈÉΩÂ∫îÊòØÊãêËßí„ÄÇ
                if (loop.length < 4) return "";

                // ÂéªÊéâÊúÄÂêé‰∏Ä‰∏™ÈáçÂ§çÁÇπÁî®‰∫éÁéØÁ¥¢Âºï
                const ring = loop.slice(0, -1);
                const n = ring.length;

                function v(a, b) { return { x: b.x - a.x, y: b.y - a.y }; }
                function len(vv) { return Math.hypot(vv.x, vv.y); }
                function norm(vv) {
                const l = len(vv);
                return { x: vv.x / l, y: vv.y / l };
                }
                function cross(a, b) { return a.x * b.y - a.y * b.x; }

                let d = "";

                for (let i = 0; i < n; i++) {
                    const p0 = ring[(i - 1 + n) % n];
                    const p1 = ring[i];
                    const p2 = ring[(i + 1) % n];

                    const inVec = v(p1, p0);   // p1 -> p0
                    const outVec = v(p1, p2);  // p1 -> p2

                    const inLenPx = len(inVec) * scalePx;
                    const outLenPx = len(outVec) * scalePx;

                    // clampÔºö‰∏çËÉΩË∂ÖËøáÁõ∏ÈÇªËæπÁöÑ‰∏ÄÂçä
                    const rr = Math.min(rPx, inLenPx / 2, outLenPx / 2);

                    const uIn = norm(inVec);
                    const uOut = norm(outVec);

                    // ÂàáÁÇπ
                    const pIn = { x: p1.x + (uIn.x * rr) / scalePx, y: p1.y + (uIn.y * rr) / scalePx };
                    const pOut = { x: p1.x + (uOut.x * rr) / scalePx, y: p1.y + (uOut.y * rr) / scalePx };

                    if (i === 0) d += `M${pIn.x * scalePx},${pIn.y * scalePx} `;
                    else d += `L${pIn.x * scalePx},${pIn.y * scalePx} `;

                    // ÊñπÂêëÔºöÁî®ËΩ¨ÂêëÂÜ≥ÂÆö sweepÔºàSVG y ËΩ¥Âêë‰∏ãÔºâ
                    // Ëã•‰Ω†ÂèëÁé∞ÂúÜÂºß‚ÄúÈºìÈîôÊñπÂêë‚ÄùÔºåÊää 0/1 ÂØπË∞ÉÂç≥ÂèØÔºàsweep = crossSign < 0 ? 0 : 1Ôºâ
                    const turn = cross(inVec, outVec);
                    const sweep = turn < 0 ? 1 : 0;

                    d += `A ${rr} ${rr} 0 0 ${sweep} ${pOut.x * scalePx} ${pOut.y * scalePx} `;
                }

                d += "Z";
                return d;
            }

            let d = "";
            for (const loop of simpleLoops) {
                d += roundedOrthogonalPath(loop, radius, blockSize) + " ";
            }

            // ====== 5) ËæìÂá∫ SVGÔºàÈÅøÂÖç stroke Ë¢´Ë£ÅÂàáÔºâ ======
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.classList.add("island");
            svg.dataset.islandId = islandData.id;
            svg.style.position = "absolute";

            svg.setAttribute("width", width * blockSize + maxStroke);
            svg.setAttribute("height", height * blockSize + maxStroke);

            // ÈÄâ‰∏≠ÊèèËæπÔºàÊõ¥Á≤ó„ÄÅ‰∏çÂêåÈ¢úËâ≤ÔºâÔºåÈªòËÆ§ÈöêËóè
            const highlight = document.createElementNS(svgNS, "path");
            highlight.setAttribute("d", d);
            highlight.setAttribute("fill", "none");
            highlight.setAttribute("stroke", "#00B0F0");       // ‰Ω†ÊÉ≥Ë¶ÅÁöÑÈÄâ‰∏≠È¢úËâ≤
            highlight.setAttribute("stroke-width", String(highlightW)); // ÊØîÂéüÊù•Á≤ó‰∏ÄÁÇπ
            highlight.setAttribute("stroke-linejoin", "round");
            highlight.setAttribute("stroke-linecap", "round");
            highlight.setAttribute("opacity", "0.9");
            highlight.setAttribute("transform", `translate(${pad},${pad})`);
            highlight.classList.add("island-highlight"); // Áî® class ÊéßÂà∂ÊòæÁ§∫

            // ÂéüÊú¨ÁöÑËΩÆÂªìÔºà‰øùÊåÅ‰Ω†ÁöÑÈ£éÊ†ºÔºâ
            const base = document.createElementNS(svgNS, "path");
            base.setAttribute("d", d);
            base.setAttribute("fill", "white");
            base.setAttribute("stroke", "black");
            base.setAttribute("stroke-width", String(strokeW));
            base.setAttribute("stroke-linejoin", "round");
            base.setAttribute("stroke-linecap", "round");
            base.setAttribute("transform", `translate(${pad},${pad})`);
            base.classList.add("island-base");

            svg.appendChild(highlight);
            svg.appendChild(base);

            return svg;
        }


        function enableWorldPanning() {
            if (worldPanningEnabled) return;
            worldPanningEnabled = true;

            const world = document.getElementById("world");
            const content = document.getElementById("worldContent");

            let offsetX = 0, offsetY = 0;
            let dragging = false;
            let startX = 0, startY = 0;
            let startOffsetX = 0, startOffsetY = 0;

            function setTransform() {
                content.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            world.addEventListener("pointerdown", (e) => {
                // Âè≥ÈîÆ‰∏çÊãñ
                if (e.button === 2) return;

                // Â¶ÇÊûú‰Ω†Â∏åÊúõ‚ÄúÁÇπÂà∞Â≤õÂ±ø‰πüËÉΩÊãñ‚ÄùÔºåÂ∞±‰∏çÂÅö‰∏ãÈù¢Ëøô‰∏™Âà§Êñ≠
                // Â¶ÇÊûú‰Ω†Â∏åÊúõ‚ÄúÁÇπÂ≤õÂ±øÊòØÈÄâÊã©Ôºå‰∏çÊãñ‚ÄùÔºåÂ∞±‰øùÁïôËøô‰∏™Âà§Êñ≠Ôºö
                // if (e.target.closest("svg")) return;

                dragging = true;
                world.classList.add("dragging");

                startX = e.clientX;
                startY = e.clientY;
                startOffsetX = offsetX;
                startOffsetY = offsetY;

                world.setPointerCapture(e.pointerId);
                e.preventDefault();
            });

            world.addEventListener("pointermove", (e) => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                offsetX = startOffsetX + dx;
                offsetY = startOffsetY + dy;
                setTransform();
            });

            function endDrag(e) {
                dragging = false;
                world.classList.remove("dragging");
                try { world.releasePointerCapture(e.pointerId); } catch {}
            }

            world.addEventListener("pointerup", endDrag);
            world.addEventListener("pointercancel", endDrag);

            // Èò≤Ê≠¢Âè≥ÈîÆËèúÂçïÂΩ±Âìç‰ΩìÈ™åÔºàÂèØÈÄâÔºâ
            world.addEventListener("contextmenu", (e) => e.preventDefault());

            setTransform();

            return {
                getOffset: () => ({ x: offsetX, y: offsetY }),
                setOffset: (x, y) => { offsetX = x; offsetY = y; setTransform(); }
            };
        }

        let selectedIsland = null;
        let selectionEnabled = false;

        function enableIslandSelection() {
            if (selectionEnabled) return;
            selectionEnabled = true;

            const world = document.getElementById("world");

            let downX = 0, downY = 0;
            let downIsland = null;
            let didDrag = false;

            const CLICK_TOLERANCE = 6;

            function islandUnderPointer(e) {
                const el = document.elementFromPoint(e.clientX, e.clientY);
                return el ? el.closest("svg.island") : null;
            }

            function deselectIsland() {
                if (!selectedIsland) return;
                selectedIsland.classList.remove("selected");
                selectedIsland = null;
                hideChatTab();

                // Â¶ÇÊûúÂΩìÂâçÂú® Chat tabÔºåÂª∫ËÆÆÂõûÂà∞ World
                showTab(3);
            }

            world.addEventListener("pointerdown", (e) => {
                if (e.button !== 0) return; // Âè™Â§ÑÁêÜÂ∑¶ÈîÆ
                downX = e.clientX;
                downY = e.clientY;
                didDrag = false;
                downIsland = islandUnderPointer(e);
            });

            world.addEventListener("pointermove", (e) => {
                if (e.buttons !== 1) return; // ‰ªÖÂ∑¶ÈîÆÊåâ‰ΩèÊó∂
                const moved = Math.hypot(e.clientX - downX, e.clientY - downY);
                if (moved > CLICK_TOLERANCE) didDrag = true;
            });

            world.addEventListener("pointerup", async (e) => {
                if (e.button !== 0) return;

                // ‚úÖ Â¶ÇÊûúÊòØÊãñÊãΩÁªìÊùüÔºö‰∏çÂÅö‰ªª‰ΩïÈÄâ‰∏≠/ÂèñÊ∂àÊìç‰ΩúÔºà‰øùÁïôÂΩìÂâçÈÄâ‰∏≠Ôºâ
                if (didDrag) return;

                const upIsland = islandUnderPointer(e);

                // ÁÇπÂà∞Á©∫ÁôΩÔºöÂèñÊ∂àÈÄâ‰∏≠ÔºàÂπ∂ÈöêËóè ChatÔºâ
                if (!upIsland) {
                deselectIsland();
                return;
                }

                // ÂøÖÈ°ªÊåâ‰∏ãÂíåÊä¨Ëµ∑Âú®Âêå‰∏Ä‰∏™Â≤õ‰∏äÊâçÁÆó‚ÄúÁÇπÂáªÂ≤õÂ±ø‚Äù
                if (!downIsland || upIsland !== downIsland) return;

                // ÂÜçÁÇπ‰∏ÄÊ¨°Âêå‰∏Ä‰∏™ÔºöÂèñÊ∂à
                if (selectedIsland === upIsland) {
                deselectIsland();
                return;
                }

                // ÂàáÊç¢ÈÄâ‰∏≠
                if (selectedIsland) selectedIsland.classList.remove("selected");
                selectedIsland = upIsland;
                selectedIsland.classList.add("selected");

                showChatTabForIsland(selectedIsland.dataset.islandId || "Chat");
                // showTab(4); // ÂèØÈÄâÔºöËá™Âä®ÂàáÂà∞ Chat

                await switchRoom(roomIdFromIslandId(selectedIsland.dataset.islandId));
            });

            // ‚úÖ ÂÖ≥ÈîÆÔºöÁßªÈô§/‰∏çË¶ÅÂÜçÁî® ‚Äúclick ÁÇπÁ©∫ÁôΩÂèñÊ∂àÈÄâ‰∏≠‚Äù
            // Âõ†‰∏∫ÊãñÊãΩ‰πüÂèØËÉΩËß¶Âèë clickÔºåÂØºËá¥ËØØÂèñÊ∂à
            // Ôºà‰∏äÈù¢ pointerup Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÁÇπÁ©∫ÁôΩÂèñÊ∂àÔºâ
        }

        function showChatTabForIsland(islandId) {
            const chatHeader = document.getElementById("tab-header4");
            chatHeader.textContent = islandId;     // tab ÊòæÁ§∫Â≤õÂ±øÂêçÂ≠ó
            chatHeader.style.display = "block";    // ÊòæÁ§∫ Chat tab
        }

        function hideChatTab() {
            const chatHeader = document.getElementById("tab-header4");
            chatHeader.style.display = "none";
            chatHeader.textContent = "Chat";       // ÂèØÈÄâÔºöÊÅ¢Â§çÈªòËÆ§Â≠óÊ†∑
        }

        function roomIdFromIslandId(id) {
            return String(id).trim().replace(/[\/#\.\$\[\]]/g, "_");
        }

        function clearChatUI() {
            const canvas = chatCanvas();
            if (canvas) canvas.innerHTML = "";
        }


        async function switchRoom(roomId) {
            currentRoomId = roomId;
            clearChatUI();   // ‰Ω†Ëá™Â∑±ÂÆûÁé∞ÔºöÊääÂΩìÂâçËÅäÂ§©ÂÆ§Ê∏≤ÊüìÂá∫Êù•ÁöÑ emoji/symbol/dot Ê∏ÖÊéâ
            await loadObj(); // ‰ªé rooms/{roomId}/objs ÈáçÊñ∞Âä†ËΩΩ
        }


    </script>
</body>
</html>