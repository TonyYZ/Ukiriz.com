<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drag and Connect Symbols</title>
    <style>
      :root {
        --mono-en: Consolas, 'Courier New', ui-monospace, SFMono-Regular, Menlo, Monaco;
        --mono-zh:
          'Sarasa Mono SC', 'Source Han Mono SC', 'Noto Sans Mono CJK SC', 'PingFang SC',
          'Microsoft YaHei', monospace;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #f4f4f9;
        /* background-color: #262626; */
        /* background-color: #eef7f2; */
        /* background-color: #f9f1db; */
        font-family: var(--mono-en);
        display: flex;
        height: 100vh; /* Full viewport height */
      }

      body.lang-zh {
        font-family: var(--mono-en), var(--mono-zh);
      }

      .symbol {
        position: absolute;
        width: 117px; /* Full width = 156 */
        height: 50.25px; /* Full height = 67 */
        cursor: grab;
        user-select: none;
        z-index: 3;
        pointer-events: auto;
      }
      .symbol img {
        width: 100%;
        height: 100%;
      }

      .dot {
        position: absolute;
        width: 5px; /* Full width = 156 */
        height: 5px; /* Full height = 67 */
        cursor: grab;
        user-select: none;
      }

      /* Highlight connections */
      .framed {
        outline: 2px solid #00b0f0;
      }

      /* Basic styles for the button */
      .button {
        position: fixed; /* Enables top and left positioning */
        background-size: contain; /* Ensure the image covers the entire button */
        background-repeat: no-repeat;
        background-position: center;
        border: none;
        border-radius: 5px; /* Optional: Makes the button rounded */
        cursor: pointer;
        opacity: 1;
        transition: opacity 0.2s;
        z-index: 1;
      }

      /* Add hover effect */
      .button:hover {
        opacity: 0.5;
      }

      .logo {
        position: fixed;
        top: 30px;
        right: 10px;
        width: 250px;
        height: auto;
        margin-bottom: 0; /* fixed å…ƒç´ ä¸éœ€è¦è¿™ä¸ª */
      }

      .wheel {
        position: fixed;
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center;
        cursor: pointer;
        z-index: 1;
      }

      /* Tab styles */
      .tab {
        color: white;
        text-align: center;
        line-height: 100px;
        font-size: 40px;
        font-family: inherit; /* Set font to match labels */
        width: 280px;
        height: 100px; /* Make taller for rectangular shape */
        padding: 0; /* No extra padding */
        cursor: pointer;
        margin: 0px 0; /* Spacing between buttons */
        border-radius: 0; /* Remove rounded corners */
        transition:
          background-color 1s ease-in-out,
          opacity 1s ease-in-out;
        opacity: 0.5; /* Start at a slightly faded state */
      }

      .tab:hover {
        background-color: rgba(255, 255, 255, 0.4);
        transition: background-color 0.3s;
      }

      .tab-active {
        background-color: rgba(255, 255, 255, 0.6);
        opacity: 1; /* Fully visible */
      }

      :root {
        --sidebar-w: 280px;
      }

      /* Vertical bar styles */
      .vertical-bar {
        position: fixed;
        top: 0;
        right: 0;
        width: var(--sidebar-w);
        height: 100%;
        background-color: #00b0f0; /* Blue background */
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 200px;
        z-index: 99999;
      }

      /* Content container */
      .content {
        margin-left: auto; /* Push content to the left of the vertical bar */
        margin-right: var(--sidebar-w); /* Leave space for the vertical bar */
        flex: 1;
        padding: 20px;
        overflow-y: auto; /* Allows vertical scrolling */
        height: 100vh;
      }

      /* Content sections */
      .tab-content {
        display: none; /* Hide all content by default */
        height: 100%;
      }

      .tab-content.active {
        display: block; /* Show active tab content */
      }

      #craftCanvas {
        position: relative;
        width: 100%;
        height: 100%;
      }

      #chatCanvas {
        position: relative;
        min-width: 100%;
        min-height: 100%;
      }

      .marquee-box {
        position: absolute;
        background: transparent;
        pointer-events: none;
        z-index: 99999;
        outline: 10px dashed #00b0f0;
      }

      #top-right-ui {
        position: fixed;
        top: 55px; /* ä½ æƒ³è¦çš„ */
        right: calc(var(--sidebar-w) + 30px);
        display: flex;
        align-items: center;
        gap: 25px;
        z-index: 1000000;
      }

      /* language toggle pill (matches badge style) */
      .lang-toggle {
        position: relative;
        display: inline-block;
        z-index: 100000;
      }

      /* the circle */
      .lang-circle {
        width: 43px;
        height: 43px;
        border-radius: 50%;
        background: white;
        border: 2px solid #ccc;
        cursor: pointer;
        font-family: inherit;
        font-size: 16px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        user-select: none;
      }

      /* dropdown bubble */
      .lang-menu {
        position: absolute;
        top: 0;

        right: calc(100% + 8px);
        left: auto;

        background: white;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 6px;
        display: none;
        gap: 6px;
        white-space: nowrap;

        z-index: 1000002;
      }

      .lang-toggle.open .lang-menu {
        display: flex;
      }

      .lang-item {
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: transparent;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        font-family: inherit;
        font-size: 12px;
      }
      .lang-item:hover {
        background: rgba(0, 0, 0, 0.06);
      }
      .lang-item.active {
        background: rgba(0, 0, 0, 0.1);
      }

      #quota-badge {
        z-index: 1000000; /* âœ… ç›–åœ¨å†…å®¹ä¸Šï¼Œä½†ä½äº/é«˜äºæ éƒ½è¡Œ */
        padding: 6px 10px;
        border-radius: 5px;
        border: 1px solid #000;
        background: rgba(255, 255, 255, 0.9);
        font-size: 16px;
        font-family: inherit;
        pointer-events: auto; /* å¯é€‰ï¼šä¸æŒ¡ç‚¹å‡» */
      }

      #quota-badge * {
        pointer-events: auto;
      }

      /* Color palette styles */
      .palette {
        position: fixed;
        display: flex;
        justify-content: center;
        margin: 20px auto;
        gap: 10px;
      }

      .color {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #ccc;
      }

      .color:hover {
        border: 2px solid black;
      }

      .progress-ring {
        position: absolute;
        width: 50px; /* Ensure this matches the SVG width */
        height: 50px; /* Ensure this matches the SVG height */
        transform: rotate(-90deg);
        visibility: hidden;
      }

      .progress-ring circle {
        fill: none;
        stroke: transparent;
        stroke-width: 5;
        stroke-dasharray: 157; /* Full circle length */
        stroke-dashoffset: 157; /* Start fully hidden */
        transition:
          stroke-dashoffset 0s,
          stroke 0s;
      }

      /* Style for the label */
      .symbol-label {
        position: absolute;
        background: white;
        border: 1px solid black;
        padding: 4px 8px;
        border-radius: 5px;
        font-size: 16px;
        font-family: inherit; /* Set font to match labels */
        cursor: pointer;
        z-index: 7;
        pointer-events: auto;
        user-select: none;
        -webkit-user-select: none;
      }

      .symbol-label.active {
        border-width: 3px; /* Thicker border when clicked */
      }

      /* Style for the input box */
      .label-input {
        position: absolute;
        width: 200px;
        border: 1px solid black;
        padding: 5px;
        font-size: 16px;
        font-family: inherit; /* Set font to match labels */
        border-radius: 5px;
        z-index: 5;
      }

      /* Auto-resizing textarea */
      .label-textarea {
        position: absolute;
        width: 200px;
        min-height: 40px;
        max-width: 200px;
        border: 1px solid black;
        padding: 5px;
        font-size: 16px;
        font-family: inherit;
        border-radius: 5px;
        resize: none;
        overflow: hidden;
        z-index: 5;
      }

      /* Style the submit button */
      .submit-button {
        position: absolute;
        background-color: white; /* Green */
        color: black;
        border: 1px solid black;
        border-radius: 5px;
        font-size: 16px;
        cursor: pointer;
        width: 27px;
        height: 27px;
        line-height: 27px;
        text-align: center;
        z-index: 5;
      }

      /* Hover effect */
      .submit-button:hover {
        opacity: 0.5;
      }

      .typing-effect p {
        position: absolute;
        font-size: 16px;
        font-family: inherit;
        display: inline-block;
        white-space: pre-line;
        line-height: 1.5; /* Adjusts spacing for smooth movement */
        overflow: hidden;
      }

      @keyframes blink {
        50% {
          opacity: 0;
        }
      }

      #message-input {
        position: absolute;
        bottom: 80px;
        left: 400px;
        padding: 10px;
        width: 400px;
        font-size: 30px; /* Larger font size */
        background-color: transparent; /* Transparent background */
        border: none; /* No border */
        color: black; /* Text color */
      }

      /* Style the placeholder text (prompt) */
      #message-input::placeholder {
        font-style: italic; /* Italicize the placeholder text */
        color: gray; /* Gray color for the placeholder */
      }

      #cursor {
        display: inline-block;
        margin-left: 1px;
        animation: blink 0.8s infinite;
        font-weight: bold;
        animation: blink 0.8s infinite;
      }

      .image-container {
        display: flex;
        justify-content: center;
      }
      .image-container img {
        width: 10%; /* 50% of the parent container */
        height: auto; /* Maintain aspect ratio */
      }

      .image-row {
        display: flex; /* Align images in a row */
        justify-content: center; /* Center images horizontally */
        align-items: center; /* Align images vertically */
        gap: 10px; /* Space between images */
      }

      .image-row img {
        width: 20%; /* Set a uniform width */
        height: auto; /* Set a uniform height */
        object-fit: cover; /* Crop images to fit without stretching */
      }

      #network {
        width: 82vw;
        height: 100vh;
        border: none;
        background: transparent;
        box-shadow: none;
      }

      /* World: solid ocean color, no background animation */
      #world {
        position: relative;
        width: calc(100vw - var(--sidebar-w));
        height: calc(100vh + 39px);
        margin: -20px;
        background: #00b0f050; /* solid */
        overflow: hidden;
        cursor: grab;
      }

      .foam {
        position: absolute;
        width: 22px;
        height: 10px;
        pointer-events: none;
        image-rendering: pixelated;

        /* 3 bumps wave */
        background:
                /* bump 1 */
          linear-gradient(#fff 0 0) 0px 6px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 2px 4px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 4px 2px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 6px 4px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 8px 6px / 2px 2px no-repeat,
          /* bump 2 */ linear-gradient(#fff 0 0) 8px 6px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 10px 4px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 12px 2px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 14px 4px / 2px 2px no-repeat,
          linear-gradient(#fff 0 0) 16px 6px / 2px 2px no-repeat;

        animation: foamBob var(--dur, 1.6s) steps(6) infinite;
        animation-delay: var(--delay, 0s);
        opacity: var(--alpha, 0.85);
      }

      @keyframes foamBob {
        0% {
          transform: translateY(0px);
          opacity: 0;
        }
        15% {
          opacity: var(--alpha, 0.85);
        }
        50% {
          transform: translateY(calc(-1 * var(--rise, 10px)));
          opacity: 1;
        }
        85% {
          opacity: var(--alpha, 0.85);
        }
        100% {
          transform: translateY(0px);
          opacity: 0;
        }
      }

      #world.dragging {
        cursor: grabbing;
      }

      #worldContent {
        position: absolute;
        left: 0;
        top: 0;
        transform: translate(0px, 0px);
        will-change: transform;
      }

      .island {
        position: absolute;
      }

      .island-block {
        position: absolute;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 6px;
      }

      .island-highlight {
        display: none;
      }
      .island.selected .island-highlight {
        display: block;
      }

      #tab-header4 {
        display: none;
      }

      .no-text-select,
      .no-text-select * {
        user-select: none !important;
      }
    </style>
    <script
      type="text/javascript"
      src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"
    ></script>
  </head>
  <body>
    <div id="top-right-ui">
      <div id="lang-toggle" class="lang-toggle">
        <button id="lang-btn" class="lang-circle" title="Language">ğŸŒ</button>
        <div id="lang-menu" class="lang-menu">
          <button id="lang-en" class="lang-item">EN</button>
          <button id="lang-zh" class="lang-item">ä¸­æ–‡</button>
        </div>
      </div>
      <div id="quota-badge" class="quota-badge">Credits spent: --/--</div>
    </div>

    <div class="vertical-bar">
      <img src="./icons/iti.svg" alt="Logo" class="logo" id="logo" />
      <div class="tab" id="tab-header0" onclick="showTab(0)">Home</div>
      <div class="tab" id="tab-header1" onclick="showTab(1)">Craft</div>
      <div class="tab" id="tab-header2" onclick="showTab(2)">Library</div>
      <div class="tab" id="tab-header3" onclick="showTab(3)">World</div>
      <div class="tab" id="tab-header4" onclick="showTab(4)">Chat</div>
    </div>

    <div class="content">
      <div class="tab-content" id="tab0">
        <div id="home-content"></div>
      </div>

      <div class="tab-content" id="tab1">
        <div id="craftCanvas"></div>

        <div id="craftControls">
          <!-- Color palette -->

          <div class="palette" id="palette">
            <div class="color" style="background-color: #5cb3cc"></div>
            <div class="color" style="background-color: #d00000"></div>
            <div class="color" style="background-color: #d6a01d"></div>
            <div class="color" style="background-color: white"></div>
            <div class="color" style="background-color: black"></div>
          </div>
        </div>
        <p></p>
      </div>
      <div class="tab-content" id="tab2">
        <div id="network"></div>
      </div>
      <div class="tab-content" id="tab3">
        <div id="world">
          <div id="worldContent"></div>
        </div>
      </div>
      <div class="tab-content" id="tab4">
        <div id="chatCanvas"></div>
        <div id="chatControls">
          <!-- Input box at the bottom of the page -->
          <input
            type="text"
            id="message-input"
            placeholder="Say something in emoji..."
            maxlength="32"
          />
        </div>
        <p></p>
      </div>
    </div>

    <script type="module">
      // --- i18n dictionary (minimal starter) ---
      const I18N = {
        en: {
          homeHTML: `
            <h1 style="text-align: center">Divinatory Conlang on Canvas</h1>
            <br>
            <p>
            Welcome!<br />
            Ever wondered how divination works?<br />
            Fortune tellers interpret meaning in random patternsâ€”from Tarot cards to teacup dregs.
            Maybe thereâ€™s a divine spirit hidden behind it. Maybe they simply know how to tell a
            story from what they see.
            </p>

            <p>
            Either way, they train their intuition to access whatever knowledge lies â€œon the other
            side.â€ This platform plays with that idea: it invites <b>you</b> to become the fortune
            teller â€”â€” in a broader sense. Here, you glimpse the meaning of life by producing and
            interpreting abstract symbols. Instead of teaching you a complete symbolic language, Iâ€™ll
            help you build one yourself.
            </p>

            <p>
            Youâ€™ll see how intuition can be built step by step.<br />
            Note: your languageâ€™s â€œatomsâ€ are fixed, but how the â€œmoleculesâ€ are structured is up to
            you. The atoms are designed by me, inspired by the Yijing trigrams.
            </p>


            <div
            style="
                max-width: 680px;
                margin: 18px auto 22px auto;
                padding: 14px 16px;
                background: white;
                border: 1px solid black;
                border-radius: 10px;
                box-shadow: 0 4px 0 rgba(0, 0, 0, 0.08);
                font-family: inherit;
            "
            >
            <div style="text-align: center; font-size: 18px; margin-bottom: 10px">
                <b>TL;DR â€” How to start</b>
            </div>

            <div style="font-size: 14px; line-height: 1.45">
                <div style="margin-bottom: 8px">
                <b>1) Build a word:</b> In <b>Craft</b>, drag symbols and let the magnets snap them
                together.
                </div>
                <div style="margin-bottom: 8px">
                <b>2) Check + learn:</b> <b>Click and hold</b> to highlight the connected cluster,
                then press <b>Insight</b> (the eye).
                </div>
                <div style="margin-bottom: 10px">
                <b>3) Name + save:</b> Enter a word + your reasoning. If it passes, it appears in the
                <b>Library</b> â†’ use it in <b>Chat</b>.
                </div>

                <div
                style="
                    text-align: center;
                    padding-top: 8px;
                    border-top: 1px dashed rgba(0, 0, 0, 0.35);
                "
                >
                Starter challenge: <b>sky</b>, <b>rain</b>, <b>flower</b>, <b>computer</b>.
                </div>
            </div>
            </div>


            <p>Here are the main ways of combining the symbols:</p>

            <div class="image-row">
                <img
                class="i18n-img"
                data-src-en="./icons/sp.png"
                data-src-zh="./icons/sp-zh.png"
                src="./icons/sp.png"
                alt="Symbol Combinations"
                />
            </div>

            <p>
            Symbols connected in <b>series</b> represent contiguous spatial relationships: above,
            below, adjacent to, inside/outside, etc.
            </p>

            <p style="text-align: center">
            <b>Examples</b><br />
            (1) A traffic light = three lights lined up in a row.<br />
            (2) A barn = a roof on top of a pile of grains.
            </p>

            <p>Symbols connected in <b>parallel</b> represent <b>composite</b> concepts.</p>

            <p style="text-align: center">
            <b>Examples</b><br />
            (1) A white rock = the composite of whiteness and hardness.<br />
            (2) A bullet = the composite of smallness and advancing.
            </p>

            <div class="image-row">
                <img
                class="i18n-img"
                data-src-en="./icons/granary.png"
                data-src-zh="./icons/granary-zh.png"
                src="./icons/granary.png"
                alt="Granary example"
                />
                <img
                class="i18n-img"
                data-src-en="./icons/bullet.png"
                data-src-zh="./icons/bullet-zh.png"
                src="./icons/bullet.png"
                alt="Bullet example"
                />
            </div>

            <p>
            As long as it makes sense to you, it worksâ€”because itâ€™s all about <b>intuitiveness</b>.
            </p>

            <p>
            When you make a word, make sure the magnets connect the symbols. Only symbols that are
            actually connected count as a word. To check this, <b>click and hold</b> a symbol and the
            entire connected cluster it belongs to will be highlighted.
            </p>

            <p>
            Then click the <b>insight</b> button (the eye). It will suggest meanings based on what it
            â€œsees.â€ You can learn what each basic symbol means by clicking <b>insight</b> and reading
            the different aspects it proposes. While we only have nine basic symbols to start,
            <b>insight</b> will learn what you teach it over time.
            </p>

            <p>
            A window will pop up asking you to name your word and explain your reasoning, and the
            system will check if it makes sense. If it does, the new word you created will appear in
            the Library.
            </p>

            <p>
            In the next tab, poke around the interface and see if you can build your own expressions
            for
            <b>â€œsky,â€ â€œrain,â€ â€œflower,â€ and â€œcomputer.â€</b><br />
            Try to attend to the symbolsâ€™ meanings (via <b>insight</b>) rather than relying purely on
            visual resemblance.
            </p>

            <p>
            After that, you can communicate with others using emojis or the expressions youâ€™ve
            created. You can post a problem you have, or just chat. Others may interpret the same
            symbols differentlyâ€”and thatâ€™s fine. What matters is resonating with the symbols and
            being inspired by them.
            </p>

            <p>
            <i>P.S.</i> Since LLM calls cost money, thereâ€™s a daily limit on how many times you can
            validate a symbol or generate emojis (<b>100 credits/day</b>). If youâ€™d like to support
            me, you can donate on Ko-fi to upgrade (<b>$5 â†’ 1000 credits/day for one month</b>).
            </p>
            <br /><br /><br /><br />
          `,
          tldrTitle: 'TL;DR â€” How to start',
          home: 'Home',
          insight: 'Insight',
          craft: 'Craft',
          library: 'Library',
          world: 'World',
          chat: 'Chat',
          credits: (used, limit) => {
            const left = Math.max(0, limit - used);
            return `Credits: ${left}/${limit}`;
          },
          supportCode: 'Support code',
          clickToCopy: '(click to copy UID)',
          supportOnKofi: 'â˜• Support on Ko-fi',
        },
        zh: {
          homeHTML: `
            <h1 style="text-align:center;">å¦è¨€ç”»å¸ƒ </h1>

            <p>
            æ¬¢è¿æ¥åˆ°è¿™é‡Œã€‚<br>
            ä½ æœ‰æ²¡æœ‰æƒ³è¿‡ï¼šå åœä¸ºä»€ä¹ˆâ€œçœ‹èµ·æ¥èƒ½çœ‹å‡ºä¸œè¥¿â€ï¼Ÿ<br>
            å¡”ç½—ç‰Œã€èŒ¶æ¸£ã€äº‘çº¹ã€ç¡¬å¸çš„æ­£åâ€¦â€¦å®ƒä»¬æœ¬èº«å¹¶æ²¡æœ‰å›ºå®šæ„ä¹‰ï¼Œä½†å åœå¸ˆå´èƒ½ä»éšæœºå›¾æ¡ˆé‡Œè®²å‡ºä¸€ä¸ªæ•…äº‹ã€‚
            ä¹Ÿè®¸è¿™èƒŒåæœ‰ç¥ç§˜åŠ›é‡ï¼›ä¹Ÿè®¸åªæ˜¯å› ä¸ºä»–ä»¬æ“…é•¿è‡ªåœ†å…¶è¯´ï¼ŒæŠŠçº¿ç´¢â€œè¿æˆä¸€æ¡çº¿â€ã€‚
            </p>

            <p>
            è¿™ä¸ªå¹³å°åœ¨ç©åŒä¸€ä¸ªæƒ³æ³•ï¼šè®©ä½ æˆä¸ºâ€œå åœå¸ˆâ€â€”â€”æ›´å¹¿ä¹‰åœ°è¯´ï¼Œæˆä¸ºä¸€ä¸ªèƒ½è¿ç”¨æŠ½è±¡ç¬¦å·å¹¶ä»¥æ­¤çª¥æ¢ç”Ÿæ´»æ„ä¹‰çš„äººã€‚<br>
            æˆ‘ä¸ä¼šç›´æ¥æ•™ä½ ä¸€æ•´å¥—ç¬¦å·è¯­è¨€ï¼›ç›¸åï¼Œæˆ‘ä¼šå¸®ä½ ä»é›¶å¼€å§‹æŠŠè¯­è¨€â€œè‡ªå·±é€ å‡ºæ¥â€ã€‚ä½ ä¼šçœ‹åˆ°ç›´è§‰æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥è¢«è®­ç»ƒå’Œç§¯ç´¯çš„ã€‚
            </p>

            <p>
            ä½ çš„è¯­è¨€â€œåŸå­â€ï¼ˆåŸºç¡€ç¬¦å·ï¼‰æ˜¯å›ºå®šçš„ï¼›ä½†â€œåˆ†å­â€ï¼ˆç»„åˆæ–¹å¼ï¼‰å®Œå…¨ç”±ä½ å†³å®šã€‚<br>
            è¿™äº›åŸºç¡€ç¬¦å·ç”±æˆ‘è®¾è®¡ï¼Œçµæ„Ÿæ¥è‡ªã€Šæ˜“ç»ã€‹å…«å¦ã€‚
            </p>

            <!-- TL;DR card -->
            <div style="
            max-width: 680px;
            margin: 18px auto 22px auto;
            padding: 14px 16px;
            background: white;
            border: 1px solid black;
            border-radius: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.08);
            font-family: inherit;
            ">
            <div style="text-align:center; font-size:18px; margin-bottom:10px;">
                <b>å¤ªé•¿ä¸çœ‹ â€” ä¸‰æ­¥ä¸Šæ‰‹</b>
            </div>

            <div style="font-size:14px; line-height:1.5;">
                <div style="margin-bottom:8px;">
                <b>1ï¼‰é€ ä¸€ä¸ªè¯ï¼š</b>å» <b>Craft</b>ï¼ŒæŠŠç¬¦å·æ‹–åˆ°ç”»å¸ƒä¸Šï¼Œè®©ç£å¸æŠŠå®ƒä»¬â€œå¸åœ¨ä¸€èµ·â€ã€‚
                </div>
                <div style="margin-bottom:8px;">
                <b>2ï¼‰æ£€æŸ¥ + å­¦ä¹ ï¼š</b><b>é•¿æŒ‰</b>ä»»æ„ç¬¦å·ï¼Œä¼šé«˜äº®å®ƒæ‰€åœ¨çš„<b>è¿é€šç»„</b>ï¼›ç„¶åç‚¹ <b>æ´å¯Ÿ</b>ï¼ˆçœ¼ç›æŒ‰é’®ï¼‰çœ‹ç³»ç»Ÿç»™çš„å«ä¹‰æç¤ºã€‚
                </div>
                <div style="margin-bottom:10px;">
                <b>3ï¼‰å‘½å + ä¿å­˜ï¼š</b>è¾“å…¥è¿™ä¸ªç»„åˆå¯¹åº”çš„è¯ï¼Œä»¥åŠä½ çš„ç†ç”±ã€‚é€šè¿‡æ£€æŸ¥åï¼Œå®ƒä¼šå‡ºç°åœ¨ <b>è¯åº“</b>ï¼Œä¹‹åå°±èƒ½åœ¨ <b>èŠå¤©</b> é‡Œç”¨å®ƒäº¤æµã€‚
                </div>

                <div style="text-align:center; padding-top:8px; border-top:1px dashed rgba(0,0,0,0.35);">
                æ–°æ‰‹æŒ‘æˆ˜ï¼š<b>â€œå¤©ç©º / é›¨ / èŠ± / ç”µè„‘â€</b>
                </div>
            </div>
            </div>

            <p><b>ç¬¦å·æ€ä¹ˆç»„åˆï¼Ÿ</b>ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼š</p>

            <div class="image-row">
                <img
                class="i18n-img"
                data-src-en="./icons/sp.png"
                data-src-zh="./icons/sp-zh.png"
                src="./icons/sp.png"
                alt="ç¬¦åˆç»„åˆæ–¹å¼"
                />
            </div>

            <p>
            <b>ä¸²è”</b>è¡¨ç¤ºç©ºé—´ä¸Šçš„<b>ç›¸é‚»/è¿ç»­å…³ç³»</b>ï¼šä¸Šä¸‹ã€å·¦å³ã€å†…éƒ¨/å¤–éƒ¨ã€è´´è¿‘ã€è¦†ç›–â€¦â€¦<br>
            </p>

            <p style="text-align:center;">
            <b>ä¾‹å­</b><br>
            ï¼ˆ1ï¼‰äº¤é€šç¯ = ä¸‰ç›ç¯æ’æˆä¸€åˆ—ã€‚<br>
            ï¼ˆ2ï¼‰è°·ä»“ = â€œå±‹é¡¶â€åœ¨â€œè°·ç‰©å †â€ä¸Šé¢ã€‚
            </p>

            <p>
            <b>å¹¶è”</b>è¡¨ç¤º<b>å¤åˆæ¦‚å¿µ</b>ï¼šæŠŠå¤šä¸ªæ€§è´¨/å«ä¹‰â€œå åŠ åˆ°ä¸€èµ·â€ã€‚<br>
            </p>

            <p style="text-align:center;">
            <b>ä¾‹å­</b><br>
            ï¼ˆ1ï¼‰ç™½è‰²çš„çŸ³å¤´ = â€œç™½â€ + â€œç¡¬â€ã€‚<br>
            ï¼ˆ2ï¼‰å­å¼¹ = â€œå°â€ + â€œå‰è¿›/å†²å‡»â€ã€‚
            </p>

            <div class="image-row">
                <img
                class="i18n-img"
                data-src-en="./icons/granary.png"
                data-src-zh="./icons/granary-zh.png"
                src="./icons/granary.png"
                alt="ç²®ä»“ç¤ºä¾‹"
                />
                <img
                class="i18n-img"
                data-src-en="./icons/bullet.png"
                data-src-zh="./icons/bullet-zh.png"
                src="./icons/bullet.png"
                alt="å­å¼¹ç¤ºä¾‹"
                />
            </div>

            <p>
            åªè¦è¿™ä¸ªç»„åˆå¯¹ä½ æ¥è¯´è®²å¾—é€šï¼Œå®ƒå°±èƒ½æˆç«‹â€”â€”å› ä¸ºè¿™é‡Œè¿½æ±‚çš„æ ¸å¿ƒå°±æ˜¯ <b>ç›´è§‰ä¸Šçš„åˆç†æ€§</b>ã€‚
            </p>

            <p>
            å½“ä½ åœ¨é€ è¯æ—¶ï¼Œè¯·ç¡®ä¿ç¬¦å·ä¹‹é—´çœŸçš„è¢«â€œç£å¸è¿æ¥â€èµ·æ¥ï¼š<b>åªæœ‰è¿åœ¨ä¸€èµ·çš„ç¬¦å·æ‰ç®—ä¸€ä¸ªè¯</b>ã€‚<br>
            ä½ å¯ä»¥<b>é•¿æŒ‰</b>æŸä¸ªç¬¦å·æ¥æ£€æŸ¥ï¼šå®ƒæ‰€åœ¨çš„æ•´å—<b>è¿é€šç»„</b>ä¼šè¢«é«˜äº®ã€‚
            </p>

            <p>
            ç„¶åç‚¹å‡» <b>æ´å¯Ÿ</b>ï¼ˆçœ¼ç›æŒ‰é’®ï¼‰ï¼Œç³»ç»Ÿä¼šæ ¹æ®å®ƒâ€œçœ‹åˆ°â€çš„ç»“æ„ç»™å‡ºä¸€äº›å«ä¹‰å»ºè®®ã€‚<br>
            ä½ ä¹Ÿå¯ä»¥åè¿‡æ¥ç”¨å®ƒå­¦ä¹ æ¯ä¸ªåŸºç¡€ç¬¦å·ï¼šå¤šç‚¹å‡ æ¬¡æ´å¯Ÿï¼Œè¯»ä¸€è¯»å®ƒç»™çš„ä¸åŒè§’åº¦ï¼Œä½ ä¼šé€æ¸å½¢æˆè‡ªå·±çš„ç†è§£ã€‚<br>
            è™½ç„¶ä¸€å¼€å§‹åªæœ‰ä¹ä¸ªåŸºç¡€ç¬¦å·ï¼Œä½† <b>æ´å¯Ÿ</b> ä¼šéšç€ä½ ä¸æ–­å‘½åä¸è§£é‡Šï¼Œé€æ¸â€œå­¦ä¼šâ€ä½ æ•™å®ƒçš„ä¸œè¥¿ã€‚
            </p>

            <p>
            å½“ä½ å‡†å¤‡å¥½ä¿å­˜æ–°è¯æ—¶ï¼Œä¼šå¼¹å‡ºçª—å£è®©ä½ è¾“å…¥ï¼š<b>è¿™ä¸ªè¯æ˜¯ä»€ä¹ˆ</b>ï¼Œä»¥åŠ<b>ä½ ä¸ºä»€ä¹ˆè¿™ä¹ˆå‘½å</b>ã€‚ç³»ç»Ÿä¼šæ£€æŸ¥ä½ çš„è§£é‡Šæ˜¯å¦è‡ªæ´½ã€‚<br>
            é€šè¿‡åï¼Œè¿™ä¸ªæ–°è¯ä¼šå‡ºç°åœ¨ <b>è¯åº“</b>ã€‚
            </p>

            <p>
            æ¥ä¸‹æ¥ä½ å°±å¯ä»¥ç”¨ä½ é€ å‡ºæ¥çš„è¯å»å’Œåˆ«äººäº¤æµï¼šå¯ä»¥åœ¨ <b>ä¸–ç•Œçš„å²›å±¿</b> é‡Œå‘ emojiï¼Œä¹Ÿå¯ä»¥å‘ä½ è‡ªå·±é€ å‡ºæ¥çš„è¡¨è¾¾ã€‚<br>
            åˆ«äººçš„è§£é‡Šå¯èƒ½è·Ÿä½ ä¸ä¸€æ ·â€”â€”æ²¡å…³ç³»ã€‚é‡è¦çš„æ˜¯ä½ å’Œè¿™äº›ç¬¦å·äº§ç”Ÿå…±é¸£ï¼Œå¹¶ä»å®ƒä»¬é‚£é‡Œå¾—åˆ°å¯å‘ã€‚
            </p>

            <p>
            <i>P.S.</i> å› ä¸ºè°ƒç”¨å¤§æ¨¡å‹è¦èŠ±é’±ï¼Œæ¯å¤©èƒ½éªŒè¯/ç”Ÿæˆçš„æ¬¡æ•°æœ‰é™ï¼ˆ<b>100 credits/day</b>ï¼‰ã€‚<br>
            ä½ ä¹Ÿå¯ä»¥é€šè¿‡ Ko-fi æ”¯æŒæˆ‘ï¼š<b>$5 â†’ 1000 credits/dayï¼ˆæŒç»­ 1 ä¸ªæœˆï¼‰</b>ã€‚
            </p>
          `,
          tldrTitle: 'TL;DR â€” 3 æ­¥å¼€å§‹',
          home: 'æ¬¢è¿',
          insight: 'æ´å¯Ÿ',
          craft: 'åˆ¶ä½œ',
          library: 'è¯åº“',
          world: 'ä¸–ç•Œ',
          chat: 'èŠå¤©',
          credits: (used, limit) => {
            const left = Math.max(0, limit - used);
            return `é¢åº¦ï¼š${left}/${limit}`;
          },
          supportCode: 'æ”¯æŒç ',
          clickToCopy: 'ï¼ˆç‚¹å‡»å¤åˆ¶ UIDï¼‰',
          supportOnKofi: 'â˜• å» Ko-fi æ”¯æŒ',
        },
      };

      let currentLang = localStorage.getItem('lang') || 'en';
      window.currentLang = currentLang;

      function setLang(lang) {
        currentLang = lang === 'zh' ? 'zh' : 'en';
        localStorage.setItem('lang', currentLang);

        // 1) Home page content (you need a container)
        const home = document.getElementById('home-content');
        if (home) home.innerHTML = I18N[currentLang].homeHTML;

        // 2) Tabs text (if you want)
        const t0 = document.getElementById('tab-header0');
        const t1 = document.getElementById('tab-header1');
        const t2 = document.getElementById('tab-header2');
        const t3 = document.getElementById('tab-header3');
        const t4 = document.getElementById('tab-header4');
        if (t0) t0.textContent = I18N[currentLang].home;
        if (t1) t1.textContent = I18N[currentLang].craft;
        if (t2) t2.textContent = I18N[currentLang].library;
        if (t3) t3.textContent = I18N[currentLang].world;
        if (t4) t4.textContent = I18N[currentLang].chat;

        // 3) If you render quota badge text, refresh it
        refreshQuotaBadge?.();

        const wrap = document.getElementById('lang-toggle');
        const btn = document.getElementById('lang-btn');

        // when setting language:
        document.getElementById('lang-en')?.classList.toggle('active', currentLang === 'en');
        document.getElementById('lang-zh')?.classList.toggle('active', currentLang === 'zh');

        refreshBasicTooltips?.();
        if (network) network.redraw();

        refreshI18nImages();
        document.body.classList.toggle('lang-zh', currentLang === 'zh');
      }

      function getLang() {
        return typeof currentLang === 'string' && (currentLang === 'zh' || currentLang === 'en')
          ? currentLang
          : 'en';
      }

      function tSymbolLabels(elemIdTrue, isDynamic) {
        const lang = getLang();
        return (SYMBOL_LABELS[lang]?.[elemIdTrue]?.[Number(isDynamic)] || []).slice();
      }

      function tSymbolTitle(i) {
        const lang = getLang();
        return SYMBOL_TITLES[lang]?.[i] || SYMBOL_TITLES.en?.[i] || '';
      }

      function refreshBasicTooltips() {
        if (!nodes) return;

        const updates = [];
        for (const id of basicNodeIds) {
          const n = nodes.get(id);
          if (!n) continue;

          const idx = n._baseIndex;
          if (idx == null) continue;

          updates.push({
            id,
            title: tSymbolTitle(idx),
          });
        }

        if (updates.length) nodes.update(updates);

        // vis sometimes caches; redraw helps
        if (network) network.redraw();
      }

      function refreshI18nImages() {
        const lang = currentLang === 'zh' ? 'zh' : 'en';
        document.querySelectorAll('img.i18n-img').forEach((img) => {
          const next = img.getAttribute(`data-src-${lang}`);
          if (next && img.src !== next) img.src = next;
        });
      }

      document.addEventListener('click', (e) => {
        const btn = e.target.closest('#lang-btn');
        if (!btn) return;

        e.stopPropagation();
        const wrap = btn.closest('#lang-toggle');
        if (!wrap) return;

        wrap.classList.toggle('open');
      });

      // ç‚¹å‡»å…¶å®ƒåœ°æ–¹è‡ªåŠ¨å…³é—­
      document.addEventListener('click', (e) => {
        const wrap = document.getElementById('lang-toggle');
        if (!wrap) return;

        // ç‚¹åˆ° toggle å†…éƒ¨ä¸å…³
        if (e.target.closest('#lang-toggle')) return;

        wrap.classList.remove('open');
      });

      document.addEventListener('click', (e) => {
        const en = e.target.closest('#lang-en');
        const zh = e.target.closest('#lang-zh');
        if (!en && !zh) return;

        e.stopPropagation(); // avoid triggering the "click outside to close" logic early

        setLang(en ? 'en' : 'zh'); // âœ… switch language
        document.getElementById('lang-toggle')?.classList.remove('open'); // close menu
      });

      const tabHeaders = [
        document.getElementById('tab-header0'),
        document.getElementById('tab-header1'),
        document.getElementById('tab-header2'),
        document.getElementById('tab-header3'),
        document.getElementById('tab-header4'),
      ];

      let tabHeadersActivated = [false, false, false, false, false];
      let activeTabInterval = null;
      let marqueeChatEnabled = false;
      let marqueeCraftEnabled = false;
      let worldData = null;
      let worldRendered = false;
      let worldPanningEnabled = false;
      let worldSelectionEnabled = false;

      // Switching between tabs
      window.showTab = function (tabIndex) {
        // Clear alpha animation
        clearInterval(activeTabInterval);
        tabHeaders.forEach((h) => h.classList.remove('tab-active'));

        // Hide all tab content
        const contents = document.querySelectorAll('.tab-content');
        contents.forEach((content) => content.classList.remove('active'));

        // Show the selected tab content
        const activeContent = document.getElementById(`tab${tabIndex}`);
        activeContent.classList.add('active');

        if (tabIndex === 3) {
          // Load world map
          enableWorldPanning();
          renderWorld();
          enableIslandSelection();
        }

        if (tabIndex === 1 && !marqueeCraftEnabled) {
          enableMarqueeSelection({
            canvasEl: document.getElementById('craftCanvas'),
            itemSelector: '.symbol',
            ignoreSelector:
              '#palette, .wheel, .button, .label-input, .label-textarea, .submit-button',
            clearSelection: () => {
              const activeTab = document.querySelector('.tab-content.active');
              const existingInput = activeTab?.querySelector('.label-input');
              if (!existingInput) {
                clearAllSymbolSelection();
              }
            },
            onSelect: (el) => {
              el.classList.add('framed');
              selectedSymbols.add(el);
              el.selected = true;
            },
          });
          marqueeCraftEnabled = true;
        }

        if (tabIndex === 4 && !marqueeChatEnabled) {
          enableMarqueeSelection({
            canvasEl: document.getElementById('chatCanvas'),
            itemSelector: '.symbol, .symbol-label',
            ignoreSelector: '.wheel, .button, .label-input, .label-textarea, .submit-button',
            clearSelection: () => {
              clearAllSymbolSelection();
              clearAllEmojiSelection();
            },
            onSelect: (el) => {
              if (el.classList.contains('symbol')) {
                el.classList.add('framed');
                selectedSymbols.add(el);
              } else if (el.classList.contains('symbol-label')) {
                el.classList.add('active');
                selectedEmojis.add(el);
              }
              el.selected = true;
            },
          });

          marqueeChatEnabled = true;
        }

        // if have not selected an island, cannot open the chat
        if (tabIndex === 4 && !selectedIsland) {
          return;
        }

        for (let i = 0; i < 5; i++) {
          if (i === tabIndex) {
            tabHeaders[i].style.opacity = 1;
            tabHeadersActivated[i] = true;
          } else {
            tabHeaders[i].style.opacity = 0.5;
            tabHeadersActivated[i] = false;
          }
        }
      };

      // Initialize the first tab as active
      showTab(0);
      const tab0 = document.getElementById('tab0');
      const tab1 = document.getElementById('tab1');
      const tab2 = document.getElementById('tab2');
      const tab3 = document.getElementById('tab3');
      const tab4 = document.getElementById('tab4');

      const chatCanvas = () => document.getElementById('chatCanvas');
      const chatControls = () => document.getElementById('chatControls');
      const craftCanvas = () => document.getElementById('craftCanvas');
      const craftControls = () => document.getElementById('craftControls');

      function appendToChatCanvas(el) {
        chatCanvas()?.appendChild(el);
      }

      function appendToChatControls(el) {
        chatControls()?.appendChild(el);
      }

      function appendToCraftCanvas(el) {
        craftCanvas()?.appendChild(el);
      }

      function appendToCraftControls(el) {
        craftControls()?.appendChild(el);
      }

      let activeSymbol = null;
      let activeEmoji = null;
      let selectedSymbols = new Set();
      let selectedEmojis = new Set();
      let dragGroup = null; // Map<elem, {dx, dy}>
      let dragLeader = null; // activeSymbol or activeEmoji
      let isGenerating = false;
      let readyActive = null;
      let readyActiveSide = null;
      let readyTarget = null;
      let readyTargetSide = null;
      let clickOnlySymbol = null;
      let clickOnlyEmoji = null;
      let selectionClickHandled = false;

      // Import Firebase modules
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
      import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInAnonymously,
        onAuthStateChanged,
      } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
      import {
        getFirestore,
        collection,
        addDoc,
        getDocs,
        setDoc,
        getDoc,
        updateDoc,
        doc,
        deleteDoc,
        arrayRemove,
        serverTimestamp,
        arrayUnion,
      } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

      const firebaseConfig = {
        apiKey: 'AIzaSyDcnYVyHx8ZgE_kKquLctcA3Q5LuSagZUE',
        authDomain: 'divinatoryconlang.firebaseapp.com',
        projectId: 'divinatoryconlang',
        storageBucket: 'divinatoryconlang.firebasestorage.app',
        messagingSenderId: '939674998709',
        appId: '1:939674998709:web:bbf228a108e046c8006bfc',
        measurementId: 'G-GLFVN6M297',
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      let currentRoomId = 'default'; // default room (or null)

      const objsColRef = (roomId = currentRoomId) => collection(db, 'rooms', roomId, 'objs');

      const objDocRef = (id, roomId = currentRoomId) => doc(db, 'rooms', roomId, 'objs', id);

      // Function to Save Emoji
      async function saveObj(type, content, x, y) {
        const ownerUid = currentUser?.uid || null; // must have signed in already
        const docRef = await addDoc(objsColRef(), {
          type,
          content,
          x,
          y,
          ownerUid, // âœ… NEW
          createdAt: serverTimestamp?.(), // optional, if you already import it
        });
        return docRef.id;
      }

      async function updateObjPosition(id, x, y) {
        if (!id || !currentRoomId) {
          return;
        }
        try {
          await updateDoc(objDocRef(id), { x, y });
        } catch (e) {
          if (e.code === 'not-found') return; // doc å·²è¢«åˆ /åˆ‡æˆ¿é—´å¯¼è‡´ï¼Œå¿½ç•¥
          throw e;
        }
      }

      async function updateSymbolAngle(id, angle) {
        try {
          await updateDoc(objDocRef(id), { 'content.angle': angle });
        } catch (e) {
          if (e.code === 'not-found') return;
          throw e;
        }
      }

      async function updateSymbolElemId(id, elemId) {
        try {
          await updateDoc(objDocRef(id), { 'content.elemId': elemId });
        } catch (e) {
          if (e.code === 'not-found') return;
          throw e;
        }
      }

      async function persistLink(aId, aSide, bId, bSide) {
        if (!tabHeadersActivated[4]) return;

        // store on both documents
        const aRef = objDocRef(aId);
        const bRef = objDocRef(bId);

        await updateDoc(aRef, {
          links: arrayUnion({ otherId: bId, mySide: aSide, otherSide: bSide }),
        });
        await updateDoc(bRef, {
          links: arrayUnion({ otherId: aId, mySide: bSide, otherSide: aSide }),
        });
      }

      // Remove link on both docs: A -- B
      async function removeLink(aId, aSide, bId, bSide) {
        await updateDoc(objDocRef(aId), {
          links: arrayRemove({ otherId: bId, mySide: aSide, otherSide: bSide }),
        }).catch(() => {});

        await updateDoc(objDocRef(bId), {
          links: arrayRemove({ otherId: aId, mySide: bSide, otherSide: aSide }),
        }).catch(() => {});
      }

      async function removeLinksBeforeDelete(symbolId) {
        const ref = objDocRef(symbolId);
        const snap = await getDoc(ref);
        if (!snap.exists()) return;

        const data = snap.data();
        const links = data.links || [];

        // Remove reverse link from each neighbor
        for (const lk of links) {
          const otherRef = objDocRef(lk.otherId);

          // Reverse record on neighbor: mySide/otherSide swap
          await updateDoc(otherRef, {
            links: arrayRemove({
              otherId: symbolId,
              mySide: lk.otherSide,
              otherSide: lk.mySide,
            }),
          }).catch(() => {});
        }
      }

      // Load emojis on page load
      window.onload = loadObj;

      function generateColor(uid) {
        let hash = 0;
        for (let i = 0; i < uid.length; i++) {
          hash = uid.charCodeAt(i) + ((hash << 5) - hash);
        }
        const color = `hsl(${hash % 360}, 70%, 60%)`; // Hue varies, but saturation & lightness are fixed
        return color;
      }

      // Initialize Firebase Authentication
      const auth = getAuth();
      let currentUser = null;

      await setPersistence(auth, browserLocalPersistence);

      // Function to sign in anonymously & store user ID
      async function signInAnonymouslyPersistent() {
        try {
          const userCredential = await signInAnonymously(auth);
          currentUser = userCredential.user;

          // Store user ID in local storage
          localStorage.setItem('anonymousUID', currentUser.uid);

          console.log('Signed in as a guest:', currentUser.uid);
        } catch (error) {
          console.error('Error with anonymous sign-in:', error);
        }
      }

      let signingIn = false;

      function waitForAuth() {
        return new Promise((resolve, reject) => {
          const unsub = onAuthStateChanged(
            auth,
            async (user) => {
              if (user) {
                currentUser = user;
                console.log('User is signed in:', user.uid);
                await refreshQuotaBadge();
                unsub();
                resolve(user);
                return;
              }

              // user ä¸º nullï¼šå°è¯•åŒ¿åç™»å½•ï¼ˆåªåšä¸€æ¬¡ï¼Œé¿å…å¾ªç¯ï¼‰
              if (signingIn) return;
              signingIn = true;

              try {
                const cred = await signInAnonymously(auth); // âœ… ç›´æ¥ç”¨å®˜æ–¹æ–¹æ³•
                currentUser = cred.user;
                console.log('Signed in anonymously:', currentUser.uid);

                // âœ… è¿™é‡Œç›´æ¥ resolveï¼Œä¸å¿…ç­‰ä¸‹ä¸€æ¬¡ onAuthStateChanged
                unsub();
                resolve(currentUser);
              } catch (e) {
                unsub();
                reject(e);
              }
            },
            (err) => {
              reject(err);
            },
          );
        });
      }

      // Function to restore previous session or sign in a new user
      async function restoreAnonymousSession() {
        return waitForAuth();
      }

      async function boot() {
        await restoreAnonymousSession();

        // âœ… set language BEFORE initNodes
        currentLang = localStorage.getItem('lang') || 'en';
        setLang(currentLang);

        // âœ… now init nodes (symbolData must already exist by this line)
        await initNodes();

        // âœ… sync titles again (safe)
        refreshBasicTooltips?.();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', boot);
      } else {
        boot(); // âœ… load å·²ç»è¿‡äº†å°±ç›´æ¥è·‘
      }

      // Function to assign and store color if not already assigned
      async function assignUserColor() {
        const userRef = doc(db, 'users', currentUser.uid); // Reference to user's Firestore document
        const userSnap = await getDoc(userRef);

        if (userSnap.exists()) {
          return userSnap.data().color; // Return existing color
        } else {
          const newColor = generateColor(currentUser.uid);
          await setDoc(userRef, { color: newColor });
          return newColor;
        }
      }

      function canEditElement(el) {
        const me = currentUser?.uid;
        if (!me) return false;

        const owner = el?.dataset?.ownerUid;

        // ğŸ”‘ Not yet saved â†’ treat as mine
        if (!owner) return true;

        return owner === me;
      }

      function getEditableSelectedSymbols() {
        return Array.from(selectedSymbols).filter((s) => canEditElement(s));
      }

      function getEditableSelectedEmojis() {
        return Array.from(selectedEmojis).filter((e) => canEditElement(e));
      }

      // Keep this map at module scope if you want
      let symbolById = new Map();

      // Function to Load emojis and symbols
      async function loadObj() {
        const querySnapshot = await getDocs(objsColRef());

        // Clear maps (important when switching rooms)
        symbolById = new Map();

        // 1) First pass: create DOM elements and register them
        for (const docSnap of querySnapshot.docs) {
          const data = docSnap.data();

          if (data.type === 'emoji') {
            const el = await createEmoji(data.content, data.x, data.y, docSnap.id);
            el.dataset.ownerUid = data.ownerUid || '';
            continue;
          }

          if (data.type === 'symbol') {
            const symbol = await createSymbolCopy(
              null,
              null,
              data.content.elemId,
              data.content.elemIdTrue,
              data.x,
              data.y,
              data.content.color,
              data.content.angle,
              docSnap.id,
            );

            symbol.dataset.ownerUid = data.ownerUid || '';

            // Register in id -> element map
            symbolById.set(docSnap.id, symbol);

            // IMPORTANT: ensure it exists in currentGraph with empty adjacency list
            currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

            // Restore dot if exists
            if (data.content.dotX !== null) {
              symbol.isDynamic = true;
              const dot = document.createElement('div');
              dot.innerHTML = dotData;
              dot.classList.add('dot');
              symbol.dot = dot;
              dot.parent = symbol;
              dot.style.left = `${data.content.dotX}px`;
              dot.style.top = `${data.content.dotY}px`;
              appendToChatCanvas(dot);
            }
          }
        }

        // 2) Second pass: rebuild links in currentGraph
        for (const docSnap of querySnapshot.docs) {
          const data = docSnap.data();
          if (data.type !== 'symbol') continue;

          const a = symbolById.get(docSnap.id);
          if (!a) continue;

          const links = data.links || [];
          for (const lk of links) {
            const b = symbolById.get(lk.otherId);
            if (!b) continue; // neighbor not loaded (should be rare)

            // Avoid duplicates: only add one direction using id ordering
            if (docSnap.id < lk.otherId) {
              const aConns = currentGraph.getSymbolConnections(a);
              const bConns = currentGraph.getSymbolConnections(b);
              if (!aConns || !bConns) continue;

              aConns[lk.mySide].push([b, lk.otherSide]);
              bConns[lk.otherSide].push([a, lk.mySide]);
            }
          }
        }
      }

      // Function to delete a document
      async function deleteObj(roomId, docId) {
        try {
          await deleteDoc(doc(db, 'rooms', roomId, 'objs', docId));
          console.log(`Document with ID ${docId} deleted successfully.`);
        } catch (error) {
          console.error('Error deleting document:', error);
        }
      }

      class PatternGraph {
        constructor() {
          this.nodes = []; // [{elemIdTrue,isDynamic,angle}]
          this.adj = []; // adj[i][side] = [[j, jSide], ...]
        }

        addNode(info) {
          const idx = this.nodes.length;
          this.nodes.push(info);
          this.adj.push([[], [], [], [], [], []]);
          return idx;
        }

        addEdge(i, side, j, jSide) {
          this.adj[i][side].push([j, jSide]);
        }

        size() {
          return this.nodes.length;
        }
      }

      function serializePatternGraph(pattern) {
        if (!pattern) return null;

        // pattern can be a PatternGraph instance or a plain object with same shape
        const nodes = Array.isArray(pattern.nodes)
          ? pattern.nodes.map((n) => ({
              elemIdTrue: n.elemIdTrue ?? null,
              isDynamic: !!n.isDynamic,
              angle: n.angle ?? 0,
            }))
          : [];

        const edges = [];

        // pattern.adj[i][side] = [[j, jSide], ...]
        const adj = Array.isArray(pattern.adj) ? pattern.adj : [];
        for (let i = 0; i < adj.length; i++) {
          const sides = Array.isArray(adj[i]) ? adj[i] : [];
          for (let side = 0; side < sides.length; side++) {
            const list = Array.isArray(sides[side]) ? sides[side] : [];
            for (const pair of list) {
              if (!Array.isArray(pair) || pair.length < 2) continue;
              const [j, jSide] = pair;

              edges.push({
                from: i,
                fromSide: side,
                to: j,
                toSide: jSide,
              });
            }
          }
        }

        return { nodes, edges };
      }

      function deserializePatternGraph(raw) {
        if (!raw || !Array.isArray(raw.nodes)) return null;

        const pg = new PatternGraph();

        for (const n of raw.nodes) {
          pg.addNode({
            elemIdTrue: n.elemIdTrue,
            isDynamic: !!n.isDynamic,
            angle: n.angle ?? 0,
          });
        }

        if (Array.isArray(raw.edges)) {
          for (const e of raw.edges) {
            if (
              typeof e?.from !== 'number' ||
              typeof e?.fromSide !== 'number' ||
              typeof e?.to !== 'number' ||
              typeof e?.toSide !== 'number'
            )
              continue;

            // Optional bounds check
            if (e.from < 0 || e.from >= pg.nodes.length) continue;
            if (e.to < 0 || e.to >= pg.nodes.length) continue;
            if (e.fromSide < 0 || e.fromSide > 5) continue;
            if (e.toSide < 0 || e.toSide > 5) continue;

            pg.addEdge(e.from, e.fromSide, e.to, e.toSide);
          }
        }

        return pg;
      }

      class SymbolGraph {
        constructor() {
          this.map = new Map(); // Maps symbol to its adjacency list
        }

        addSymbol(symbol, connections) {
          this.map.set(symbol, connections); // connections = [[], [], (n, j), [], [], []]
        }

        getSymbolConnections(symbol) {
          return this.map.get(symbol) || null; // Return connections or null if not found
        }

        getSymbols() {
          return Array.from(this.map.keys()); // Return all symbols in the graph
        }

        hasSymbol(symbol) {
          return this.map.has(symbol);
        }

        // âœ… åˆ é™¤èŠ‚ç‚¹ + æ¸…ç†æ‰€æœ‰å¼•ç”¨å®ƒçš„è¾¹
        removeSymbol(symbol) {
          if (!this.map.has(symbol)) return;

          // 1) å…ˆä»æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„é‚»æ¥è¡¨ä¸­ç§»é™¤æŒ‡å‘ symbol çš„è¾¹
          for (const [node, conns] of this.map.entries()) {
            if (node === symbol) continue;
            for (let side = 0; side < 6; side++) {
              const arr = conns[side];
              if (!Array.isArray(arr) || arr.length === 0) continue;

              // æ¯ä¸ªå…ƒç´ å½¢å¦‚ [neighbor, neighborSide]
              conns[side] = arr.filter(([nbr, _nbrSide]) => nbr !== symbol);
            }
            this.map.set(node, conns);
          }

          // 2) å†åˆ é™¤ symbol è‡ªå·±
          this.map.delete(symbol);
        }

        // âœ… å¯é€‰ï¼šæ‰¹é‡æ¸…ç†å·²ä¸åœ¨ DOM ä¸­çš„èŠ‚ç‚¹ï¼ˆé˜²å¾¡æ€§ï¼‰
        pruneDetachedSymbols() {
          for (const sym of this.map.keys()) {
            if (!sym || !sym.isConnected) {
              this.removeSymbol(sym);
            }
          }
        }

        doesMatch(storedGraph, currSymbol, matchedSymbols) {
          if (matchedSymbols.size === storedGraph.map.size) return true; // Full match found

          for (let [storedSymbol] of storedGraph.map.entries()) {
            if (matchedSymbols.has(storedSymbol)) continue; // Already matched

            if (this.isSymbolMatch(currSymbol, storedSymbol)) {
              console.log(`Matching: ${currSymbol.elemIdTrue} â†” ${storedSymbol.elemIdTrue}`);
              matchedSymbols.set(storedSymbol, currSymbol);

              let isValid = true;

              // Check all six sides
              for (let i = 0; i < 6; i++) {
                let storedNeighbors = storedGraph.map.get(storedSymbol)[i] || [];
                let currNeighbors = this.map.get(currSymbol)?.[i] || [];

                if (storedNeighbors.length > currNeighbors.length) {
                  console.log(
                    'Stored neighbor:' + storedNeighbors + ' Current neighbor:' + currNeighbors,
                  );
                  console.log(`Mismatch at side ${i}: Not enough neighbors`);
                  isValid = false;
                  break;
                }

                let foundAll = true;
                for (let [storedNeighbor, storedSide] of storedNeighbors) {
                  let foundMatch = false;

                  for (let [currNeighbor, currSide] of currNeighbors) {
                    if (
                      currSide === storedSide &&
                      this.isSymbolMatch(currNeighbor, storedNeighbor)
                    ) {
                      if (
                        matchedSymbols.has(currNeighbor) ||
                        this.doesMatch(storedGraph, currNeighbor, matchedSymbols)
                      ) {
                        foundMatch = true;
                        break;
                      }
                    }
                  }

                  if (!foundMatch) {
                    console.log(`Neighbor mismatch: ${storedNeighbor.elemIdTrue} not found`);
                    foundAll = false;
                    break;
                  }
                }

                if (!foundAll) {
                  isValid = false;
                  break;
                }
              }

              if (isValid) return true;
              matchedSymbols.delete(storedSymbol); // Backtrack
            }
          }
          return false;
        }

        isSymbolMatch(currSymbol, storedSymbol) {
          return (
            currSymbol &&
            storedSymbol &&
            currSymbol.elemIdTrue === storedSymbol.elemIdTrue &&
            currSymbol.isDynamic === storedSymbol.isDynamic &&
            currSymbol.angle === storedSymbol.angle
          );
        }
      }

      function snapshotSelectionAsPattern(fullGraph, selectedSymbols) {
        const g = new PatternGraph();
        const indexOf = new Map(); // DOM symbol -> node index

        // 1) èŠ‚ç‚¹
        for (const sym of selectedSymbols) {
          indexOf.set(
            sym,
            g.addNode({
              elemIdTrue: sym.elemIdTrue,
              isDynamic: !!sym.isDynamic,
              angle: sym.angle,
            }),
          );
        }

        // 2) è¾¹ï¼ˆåªä¿ç•™é€‰ä¸­å†…éƒ¨çš„è¾¹ï¼‰
        for (const sym of selectedSymbols) {
          const i = indexOf.get(sym);
          const conns = fullGraph.getSymbolConnections(sym);
          if (!conns) continue;

          for (let side = 0; side < 6; side++) {
            for (const [nbr, nbrSide] of conns[side]) {
              if (!selectedSymbols.has(nbr)) continue;
              const j = indexOf.get(nbr);
              g.addEdge(i, side, j, nbrSide);
            }
          }
        }

        return g;
      }

      function matchPatternOnSelection(selectedSymbols, pattern) {
        // æŠŠ selectedSymbols å˜æˆæ•°ç»„ï¼Œæ–¹ä¾¿ç”¨ index è¡¨ç¤º
        const sel = [...selectedSymbols];
        const n = sel.length;
        const m = pattern.nodes.length;
        if (m === 0 || n < m) return null;

        // å»ºä¸€ä¸ªå¿«é€Ÿé‚»æ¥æŸ¥è¯¢ï¼šselAdj[i][side] = [[j, jSide], ...]ï¼ˆåªåœ¨é€‰ä¸­å†…éƒ¨ï¼‰
        const indexOf = new Map(sel.map((s, i) => [s, i]));
        const selAdj = sel.map(() => [[], [], [], [], [], []]);

        for (let i = 0; i < n; i++) {
          const conns = currentGraph.getSymbolConnections(sel[i]) || [[], [], [], [], [], []];
          for (let side = 0; side < 6; side++) {
            for (const [nbr, nbrSide] of conns[side]) {
              if (!indexOf.has(nbr)) continue;
              selAdj[i][side].push([indexOf.get(nbr), nbrSide]);
            }
          }
        }

        const usedSel = new Array(n).fill(false);
        const mapPtoS = new Array(m).fill(-1); // pattern node -> selected index

        function nodeMatch(si, pi) {
          const s = sel[si];
          const p = pattern.nodes[pi];
          return (
            s &&
            s.elemIdTrue === p.elemIdTrue &&
            !!s.isDynamic === !!p.isDynamic &&
            s.angle === p.angle
          );
        }

        function backtrack(pi) {
          if (pi === m) return true;

          for (let si = 0; si < n; si++) {
            if (usedSel[si]) continue;
            if (!nodeMatch(si, pi)) continue;

            // å°è¯•æŠŠ pattern pi æ˜ å°„åˆ° selected si
            mapPtoS[pi] = si;
            usedSel[si] = true;

            // æ ¡éªŒï¼špattern pi å·²ç»æŒ‡å‘çš„é‚»å±…ï¼ˆé‚£äº›å·²è¢«æ˜ å°„çš„ï¼‰å¿…é¡»åœ¨ selAdj é‡Œå­˜åœ¨
            let ok = true;
            for (let side = 0; side < 6 && ok; side++) {
              for (const [pj, pjSide] of pattern.adj[pi][side]) {
                const sj = mapPtoS[pj];
                if (sj === -1) continue; // è¿˜æ²¡æ˜ å°„åˆ°å…·ä½“ symbolï¼Œå…ˆä¸æ£€æŸ¥

                // è¦æ±‚ si çš„ side ä¸Šå­˜åœ¨ (sj, pjSide)
                const arr = selAdj[si][side];
                if (!arr.some(([nbrIndex, nbrSide]) => nbrIndex === sj && nbrSide === pjSide)) {
                  ok = false;
                  break;
                }
              }
            }

            if (ok && backtrack(pi + 1)) return true;

            // å›æº¯
            usedSel[si] = false;
            mapPtoS[pi] = -1;
          }
          return false;
        }

        if (!backtrack(0)) return null;

        // è¿”å›åŒ¹é…åˆ°çš„ DOM symbols é›†åˆ
        const matched = new Set();
        for (let pi = 0; pi < m; pi++) matched.add(sel[mapPtoS[pi]]);
        return matched;
      }

      const currentGraph = new SymbolGraph();
      const library = new Map();
      const scale = 0.75;
      const SNAP_DISTANCE = 30 * scale; // Pixel distance for snapping
      const UNSNAP_DISTANCE = 40 * scale; // can beï¼š+4 / +8
      let dragSnapLock = null; // { targetId, targetSide, activeSide }

      function setDragSnapLock(v, reason = '') {
        if (v) {
          console.warn('[SET dragSnapLock]', reason, v);
          console.trace();
        } else {
          console.warn('[CLR dragSnapLock]', reason);
        }
        dragSnapLock = v;
      }

      let groupDragActive = false;
      let pendingSnapDelta = null; // {dx, dy}
      let snapCooldownUntil = 0; // ms, prevents immediate re-snap after unlock

      let longPressStartedAt = 0;
      let longPressFired = false;

      let acc = 0;
      let moleculeString = '';
      let selectedColor = null;
      const positions = [2, 1, 0, 7, 3, 4, 5, 6]; // Angle 0 = to the right
      // Circle layout parameters
      const radius = 150; // Radius of the circle
      const centerX = 450; // Center of the canvas (half of canvas width)
      const centerY = 200; // Center of the canvas (half of canvas height)

      const symbolScale = 0.75;
      const symbolWidth = 156;
      const symbolHeight = 67;

      const calX = 1;
      const calY = 6.7 * symbolScale;
      const calInvY = 7 * symbolScale;
      const calCan1 = 4 * symbolScale;
      const calCan2 = 3.5 * symbolScale;

      // Long press variables
      let progress = 0;
      let interval;
      let ring = null;
      let circle = null;
      const pressDuration = 1000; // 1 second to complete the bar
      const totalSteps = pressDuration / 10;

      // Set the x and y coordinates dynamically using JavaScript
      const logo = document.getElementById('logo');

      const palette = document.getElementById('palette');
      palette.style.left = `685px`;
      palette.style.top = `55px`;

      const SYMBOL_LABELS = {
        en: [
          [
            ['empty', 'medium', 'place'],
            ['still', 'calm', 'fixed'],
          ],
          [
            ['protect', 'constrain', 'cover', 'limit'],
            ['come', 'pull', 'retreat'],
          ],
          [
            [
              'center',
              'middle',
              'inner',
              'occupy',
              'point',
              'individual',
              'barrier',
              'obstacle',
              'unit',
            ],
            ['separate', 'source', 'spread', 'explode', 'radiate'],
          ],
          [
            ['unsupported', 'supple', 'bloated'],
            ['decay', 'leak', 'discard', 'shed', 'loosen', 'let go'],
          ],
          [
            ['base', 'carry', 'load', 'deep'],
            ['go', 'push', 'advance'],
          ],
          [
            ['gap', 'contain', 'enclosure', 'shell', 'surround'],
            ['join', 'combine', 'close', 'squeeze', 'attach'],
          ],
          [
            [
              'heap',
              'pile',
              'hill',
              'stub',
              'incomplete',
              'cavity',
              'blade',
              'sharp',
              'shallow',
              'exposed',
              'broken',
            ],
            ['depart', 'give', 'express'],
          ],
          [
            ['full', 'substance', 'complete', 'large', 'multiple'],
            [
              'chaotic',
              'turmoil',
              'unrest',
              'hustle',
              'activity',
              'bustle',
              'dynamic',
              'vibrancy',
            ],
          ],
          [
            ['monotonous', 'homogeneous', 'same', 'normal', 'substance'],
            ['complex', 'system', 'order', 'organic', 'intricate', 'variegated'],
          ],
        ],

        zh: [
          [
            ['ç©º', 'è™š', 'æ— ', 'å¤„æ‰€'],
            ['é™', 'å®‰', 'å®š'],
          ],
          [
            ['ä¿', 'æŠ¤', 'é™', 'è¦†'],
            ['æ¥', 'ç‰µ', 'é€€', 'å‘å'],
          ],
          [
            ['ä¸­', 'å¿ƒ', 'å†…', 'å ', 'ç‚¹', 'é˜»', 'éšœ'],
            ['åˆ†', 'æº', 'æ•£', 'çˆ†', 'è¾å°„'],
          ],
          [
            ['è™š', 'æµ®', 'æŸ”', 'èƒ€'],
            ['è…', 'æ¼', 'èˆå»', 'è„±', 'æ”¾'],
          ],
          [
            ['åŸº', 'è½½', 'æ·±', 'æ‰¿'],
            ['è¡Œ', 'æ¨', 'è¿›', 'å‘å‰'],
          ],
          [
            ['éš™', 'å®¹', 'çº³', 'å›´', 'å£³', 'å¤–'],
            ['åˆ', 'å¹¶', 'è´´', 'æŒ¤', 'é™„', 'ä¾'],
          ],
          [
            ['å †', 'ä¸˜', 'ç¼º', 'åˆƒ', 'é”', 'æµ…', 'éœ²'],
            ['ç¦»', 'äºˆ', 'è¿°', 'å‘', 'å‡º'],
          ],
          [
            ['æ»¡', 'å®', 'å…¨', 'å¤§', 'å¤š', 'ä¸°å¯Œ'],
            ['ä¹±', 'è¡', 'å–§', 'ç¹', 'æ´»', 'åŠ¨', 'ç”Ÿ'],
          ],
          [
            ['é½', 'åŒ', 'å¸¸', 'åŒ€'],
            ['å¤', 'ç³»ç»Ÿ', 'æœ‰æœº', 'ç¹', 'æ‚'],
          ],
        ],
      };

      const SYMBOL_TITLES = {
        en: [
          'Based on Trigram Kun â˜·. Empty and still.',
          'Based on Trigram Gen â˜¶. Constrain and fall.',
          'Based on Trigram Kan â˜µ. Occupy and radiate.',
          'Based on Trigram Xun â˜´. Airy and leak.',
          'Based on Trigram Zhen â˜³. Load and rise.',
          'Based on Trigram Li â˜². Contain and attach.',
          'Based on Trigram Dui â˜±. Broken and express.',
          'Based on Trigram Qian â˜°. Multiple and vibrant.',
          'A uniquely ÃtÃ­ symbol. It is always balancing all elements, so it can be either monotonous or filled with variegated order.',
        ],
        zh: [
          'å–è±¡è‡ªå¤å¦ â˜·ï¼šç©ºè™šã€å®‰é™ã€‚',
          'å–è±¡è‡ªè‰®å¦ â˜¶ï¼šè¦†ç›–ã€ä¸‹é™ã€‚',
          'å–è±¡è‡ªåå¦ â˜µï¼šé˜»éš”ã€åˆ†ç¦»ã€‚',
          'å–è±¡è‡ªå·½å¦ â˜´ï¼šè™šæµ®ã€æ³„æ¼ã€‚',
          'å–è±¡è‡ªéœ‡å¦ â˜³ï¼šæ‰¿è½½ã€ä¸Šå‡ã€‚',
          'å–è±¡è‡ªç¦»å¦ â˜²ï¼šå®¹çº³ã€ä¾é™„ã€‚',
          'å–è±¡è‡ªå…‘å¦ â˜±ï¼šç ´ç¼ºã€å‘å‡ºã€‚',
          'å–è±¡è‡ªä¹¾å¦ â˜°ï¼šä¸°å¯Œã€æ´»åŠ¨ã€‚',
          'ÃtÃ­ çš„ç‰¹æ®Šç¬¦å·ï¼ˆå¤ªæï¼‰ï¼šåœ¨è¯¸å…ƒç´ ä¹‹é—´ç»´æŒå¹³è¡¡ï¼Œå› æ­¤æ—¢å¯èƒ½â€œå•è°ƒâ€ï¼Œä¹Ÿå¯èƒ½å‘ˆç°â€œç¹å¤çš„ç§©åºâ€ã€‚',
        ],
      };

      const EXTRA = {
        en: {
          rightSide: ['right side'],
          leftSide: ['left side'],
          gravity: ['gravity', 'fall', 'descend'],
          roof: ['top', 'roof', 'high', 'aloft'],
          aerial: ['aerial', 'suspend', 'tall', 'float'],
          ascend: ['ascend', 'rise', 'climb'],
          ground: ['low', 'ground', 'platform'],
        },
        zh: {
          rightSide: ['å³'],
          leftSide: ['å·¦'],
          gravity: ['é‡', 'å ', 'è½', 'ä¸‹'],
          roof: ['ä¸Šæ–¹', 'é¡¶', 'é«˜'],
          aerial: ['æ‚¬ç©º', 'è™š', 'æµ®'],
          ascend: ['ä¸Š', 'å‡'],
          ground: ['ä½', 'ä¸‹æ–¹', 'åœ°', 'å¹³å°'],
        },
      };

      function extra(key) {
        return EXTRA[getLang()]?.[key] || EXTRA.en[key] || [];
      }

      // Symbol data (position on circle)
      const symbolData = [
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000;stroke-width:1.02897" d="M15.362 16.96v-1.28H49.92v2.56H15.362Z"></path><path d="M0 5.371v-1.28h34.56v2.56H0z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h38.08V4.48h2.56v13.76H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h23.68V4.48h2.56v11.2h23.68v2.56H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><a transform="translate(0 -12)"><path style="fill:#000" d="M0 31.52c0-1.28 0-1.28 16.31-1.28 8.438 0 12.956-.003 14.768.024 1.676.024.91-.928.319-1.77-6.312-9.011 4.424-20.08 13.641-14.065 5.795 3.782 5.914 12.549.223 16.464-2.752 1.894-2.823 1.899-25.021 1.903C0 32.8 0 32.8 0 31.52m43.461-2.46c6.384-3.947 3.578-13.7-3.941-13.7-8.426 0-10.362 11.492-2.437 14.458 1.796.672 4.604.338 6.378-.759"></path><path d="M-.007 31.517v-1.28h16.31s20.052 2.554 3.93 2.557l-20.24.003z" style="fill:#000"></path></a></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h38.08v2.56H9.28Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h26.24V4.48h2.56v13.76H9.28z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M49.915 19.513c0-1.28 0-1.28-16.31-1.28-8.438 0-12.955-.003-14.768.023-1.675.025-.909-.927-.318-1.77 6.312-9.01-4.424-20.08-13.642-14.065-5.795 3.782-5.913 12.55-.223 16.465 2.752 1.893 2.824 1.899 25.021 1.903 20.24.004 20.24.004 20.24-1.276M6.454 17.052c-6.384-3.947-3.578-13.7 3.941-13.7 8.426 0 10.363 11.493 2.437 14.459-1.796.672-4.604.338-6.378-.76"></path><path d="M49.922 19.51v-1.28h-16.31s-20.052 2.553-3.93 2.556l20.24.004z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M21.856 20.468c-3.226-1.115-6.05-3.957-6.641-6.684-.226-1.04-.226-1.04-7.72-1.04-7.495 0-7.495 0-7.495-1.28s0-1.28 7.348-1.28c4.823 0 6.48 0 7.148-.385.35-.201.427-.508.547-.975 2.649-10.367 17.185-10.367 19.834 0 .348 1.36.348 1.36 7.695 1.36s7.348 0 7.348 1.28 0 1.28-7.495 1.28c-7.494 0-7.494 0-7.72 1.04-1.093 5.04-7.683 8.47-12.85 6.684m5.74-2.465c6.55-2.232 6.55-11.806 0-14.039-7.822-2.664-13.768 6.713-7.883 12.43 2.026 1.966 5.032 2.58 7.882 1.61"></path><path d="M35.224 10.185H49.92v2.56h-7.494m-34.928.003H.003v-2.56h14.695" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h49.92v2.56H0Zm8-11.2V4.48h33.92v2.56H8Z"></path></svg>`,
      ];

      const dotData = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="5" fill="red"/></svg>`;
      const dotDataMini = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="2" cy="2" r="2" fill="red"/></svg>`;
      const dotOffsetXData = [0, 45, 0, 46, -45, 0, -46, 0, 0];
      const dotOffsetYData = [0, 0, 0, -8, 0, 0, -8, -8, 0];

      async function rotateSymbol(symbol, addAngle, inChat = false) {
        detachSymbol(symbol);

        symbol.angle = (symbol.angle + addAngle) % 360;
        if (symbol.elemId === 1) {
          if (symbol.angle === 90) {
            symbol.elemId = 4;
            symbol.innerHTML = symbolData[4];
          }
          if (symbol.angle === 270) {
            symbol.elemId = 4;
            symbol.innerHTML = symbolData[4];
          }
        } else if (symbol.elemId === 3) {
          if (symbol.angle === 90) {
            symbol.elemId = 6;
            symbol.innerHTML = symbolData[6];
          }
          if (symbol.angle === 270) {
            symbol.elemId = 6;
            symbol.innerHTML = symbolData[6];
          }
        } else if (symbol.elemId === 4) {
          if (symbol.angle === 90) {
            symbol.elemId = 1;
            symbol.innerHTML = symbolData[1];
          }
          if (symbol.angle === 270) {
            symbol.elemId = 1;
            symbol.innerHTML = symbolData[1];
          }
        } else if (symbol.elemId === 6) {
          if (symbol.angle === 90) {
            symbol.elemId = 3;
            symbol.innerHTML = symbolData[3];
          }
          if (symbol.angle === 270) {
            symbol.elemId = 3;
            symbol.innerHTML = symbolData[3];
          }
        }
        // symbol.querySelector('svg').setAttribute('width', '100%');
        // symbol.querySelector('svg').setAttribute('height', '100%');
        symbol.style.transform = `rotate(${symbol.angle}deg)`;
        dyeColor(symbol, symbol.color);

        if (inChat) {
          if (symbol.isDynamic && symbol.dot) {
            updateDotPositionLocal(symbol.dot); // instant UI update
            await persistDotPosition(symbol.dot); // one DB write
          }
          await updateSymbolAngle(symbol.dataset.id, symbol.angle);
          await updateSymbolElemId(symbol.dataset.id, symbol.elemId);
        }
      }

      const turnButton = document.createElement('div');
      turnButton.classList.add('button');
      turnButton.style.width = `149px`;
      turnButton.style.height = `142px`;
      turnButton.style.backgroundImage = "url('./icons/turn.png')";
      turnButton.style.left = `40px`;
      turnButton.style.top = `30px`;
      turnButton.addEventListener('click', async (e) => {
        if (selectedSymbols.size != 0) {
          // Increment the angle by 90 degrees
          for (const selectedSymbol of selectedSymbols) {
            await rotateSymbol(selectedSymbol, 90);
          }
        }

        if (eyeButton.isActivated) {
          eyeButton.isActivated = false;
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });
      appendToCraftControls(turnButton);

      const turnButton2 = turnButton.cloneNode(true);
      turnButton2.addEventListener('click', async (e) => {
        if (selectedSymbols.size !== 0) {
          for (const selectedSymbol of selectedSymbols) {
            if (!canEditElement(selectedSymbol)) continue; // skip others
            await rotateSymbol(selectedSymbol, 90, true);
          }
        }

        if (eyeButton.isActivated) {
          eyeButton.isActivated = false;
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });
      appendToChatControls(turnButton2);

      const dotButton = document.createElement('div');
      dotButton.classList.add('button');
      dotButton.style.width = `143px`;
      dotButton.style.height = `94px`;
      dotButton.style.backgroundImage = "url('./icons/dot.png')";
      dotButton.style.left = `200px`;
      dotButton.style.top = `55px`;

      dotButton.addEventListener('mouseup', async (e) => {
        if (selectedSymbols.size != 0) {
          // Increment the angle by 90 degrees
          for (const selectedSymbol of selectedSymbols) {
            selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
            if (selectedSymbol.isDynamic) {
              const dot = document.createElement('div');
              dot.innerHTML = dotData;
              dot.classList.add('dot');
              selectedSymbol.dot = dot;
              dot.parent = selectedSymbol;
              updateDotPositionLocal(dot);
              await persistDotPosition(dot);
              appendToCraftCanvas(dot);
            } else {
              selectedSymbol.dot.remove();
              selectedSymbol.dot = null;
            }
          }
        }

        if (eyeButton.isActivated) {
          eyeButton.isActivated = false;
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });

      appendToCraftControls(dotButton);

      const dotButton2 = dotButton.cloneNode(true);
      dotButton2.addEventListener('mouseup', async (e) => {
        if (selectedSymbols.size !== 0) {
          for (const selectedSymbol of selectedSymbols) {
            if (!canEditElement(selectedSymbol)) continue; // skip others

            selectedSymbol.isDynamic = !selectedSymbol.isDynamic;

            if (selectedSymbol.isDynamic) {
              const dot = document.createElement('div');
              dot.innerHTML = dotData;
              dot.classList.add('dot');
              selectedSymbol.dot = dot;
              dot.parent = selectedSymbol;

              updateDotPositionLocal(dot);
              appendToChatCanvas(dot);

              await persistDotPosition(dot);
            } else {
              if (tabHeadersActivated[4]) {
                await updateDoc(objDocRef(selectedSymbol.dataset.id), {
                  'content.dotX': null,
                  'content.dotY': null,
                });
              }

              selectedSymbol.dot?.remove();
              selectedSymbol.dot = null;
            }
          }
        }

        if (eyeButton.isActivated) {
          eyeButton.isActivated = false;
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });
      appendToChatControls(dotButton2);

      async function updateDotPositionLocal(dot) {
        const symbol = dot.parent;

        const canvas = getCanvasForElem(symbol);
        if (!canvas) return;

        const canvasRect = canvas.getBoundingClientRect();
        const rect = symbol.getBoundingClientRect();

        // æŠŠè§†å£åæ ‡ -> canvas å±€éƒ¨åæ ‡
        const symLeft = rect.left - canvasRect.left;
        const symTop = rect.top - canvasRect.top;
        const symRight = rect.right - canvasRect.left;
        const symBottom = rect.bottom - canvasRect.top;

        let x, y;

        switch (symbol.angle) {
          case 0:
            x = symLeft + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5;
            y = symTop + dotOffsetYData[symbol.elemId] * symbolScale - 12;
            break;
          case 90:
            x = symRight - dotOffsetYData[symbol.elemId] * symbolScale;
            y = symTop + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 10;
            break;
          case 180:
            x = symRight - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5;
            y = symBottom - dotOffsetYData[symbol.elemId] * symbolScale - 7;
            break;
          case 270:
            x = symLeft + dotOffsetYData[symbol.elemId] * symbolScale - 10;
            y = symBottom - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 7;
            break;
        }

        dot.style.left = `${x}px`;
        dot.style.top = `${y}px`;
      }

      async function persistDotPosition(dot) {
        const symbol = dot.parent;
        if (!tabHeadersActivated[4]) return;

        const x = parseFloat(dot.style.left);
        const y = parseFloat(dot.style.top);

        const id = symbol.dataset?.id;
        if (!id) return;

        await updateDoc(objDocRef(id), {
          'content.dotX': x,
          'content.dotY': y,
        });
      }

      function countConnectedComponentsInSelection(selectedSymbols, graph) {
        const sel = selectedSymbols instanceof Set ? selectedSymbols : new Set(selectedSymbols);
        if (sel.size === 0) return 0;

        const visited = new Set();
        let components = 0;

        for (const start of sel) {
          if (visited.has(start)) continue;

          components++;
          // BFS
          const queue = [start];
          visited.add(start);

          while (queue.length) {
            const node = queue.pop();
            const conns = graph.getSymbolConnections(node);
            if (!conns) continue;

            for (let side = 0; side < 6; side++) {
              const neighbors = conns[side] || [];
              for (const [nbr, _nbrSide] of neighbors) {
                if (!sel.has(nbr)) continue; // searching scope is limited to the selected symbols
                if (visited.has(nbr)) continue;
                visited.add(nbr);
                queue.push(nbr);
              }
            }
          }
        }

        return components;
      }

      function isSelectionConnected(selectedSymbols, graph) {
        return countConnectedComponentsInSelection(selectedSymbols, graph) <= 1;
      }

      const eyeButton = document.createElement('div');
      eyeButton.isActivated = false;
      eyeButton.classList.add('button');
      eyeButton.style.width = `150px`;
      eyeButton.style.height = `106px`;
      eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
      eyeButton.style.left = `510px`;
      eyeButton.style.top = `40px`;

      eyeButton.addEventListener('mouseup', (e) => {
        eyeButton.isActivated = !eyeButton.isActivated;
        if (eyeButton.isActivated) {
          eyeButton.style.backgroundImage = "url('./icons/eye_blue.png')";
          if (selectedSymbols.size !== 0) {
            const [foundIds, elimBasic, representatives, hasDuplicateExpression] =
              showSimpleLabel();

            if (isSelectionConnected(selectedSymbols, currentGraph)) {
              showInput(foundIds, elimBasic, representatives, hasDuplicateExpression);
            }
          }
        } else {
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });

      appendToCraftControls(eyeButton);

      const eyeButton2 = eyeButton.cloneNode(true);

      eyeButton2.addEventListener('mouseup', (e) => {
        eyeButton2.isActivated = !eyeButton2.isActivated;
        if (eyeButton2.isActivated) {
          eyeButton2.style.backgroundImage = "url('./icons/eye_blue.png')";
          if (selectedSymbols.size !== 0) {
            const [foundIds, elimBasic, representatives, hasDuplicateExpression] =
              showSimpleLabel();
          }
        } else {
          eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });
      appendToChatControls(eyeButton2);

      const removeButton = document.createElement('div');
      removeButton.isActivated = false;
      removeButton.classList.add('button');
      removeButton.style.width = `168.75px`;
      removeButton.style.height = `119.25px`;
      removeButton.style.backgroundImage = "url('./icons/astray.png')";
      removeButton.style.left = `340px`;
      removeButton.style.top = `40px`;

      removeButton.addEventListener('mouseup', (e) => {
        if (selectedSymbols.size != 0) {
          for (const selectedSymbol of selectedSymbols) {
            currentGraph.removeSymbol(selectedSymbol);
            if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
            selectedSymbol.remove();
          }
          selectedSymbols.clear();
        }
        if (eyeButton.isActivated) {
          eyeButton.isActivated = false;
          eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });

      appendToCraftControls(removeButton);

      const removeButton2 = removeButton.cloneNode(true);

      removeButton2.addEventListener('mouseup', async (e) => {
        e.stopPropagation();
        e.preventDefault();

        // ----- Symbols: delete only mine -----
        if (selectedSymbols.size > 0) {
          const toDelete = getEditableSelectedSymbols(); // only editable symbols

          for (const selectedSymbol of toDelete) {
            currentGraph.removeSymbol(selectedSymbol);

            const id = selectedSymbol.dataset.id;
            if (id) {
              // 1) remove links on neighbors
              await removeLinksBeforeDelete(id);

              // 2) delete the symbol doc
              await deleteObj(currentRoomId, id);
            }

            // UI cleanup
            if (selectedSymbol.isDynamic) selectedSymbol.dot?.remove();
            selectedSymbol.remove();

            // keep Set in sync
            selectedSymbols.delete(selectedSymbol);
            selectedSymbol.selected = false;
          }
        }

        // ----- Emojis: delete only mine -----
        if (selectedEmojis.size > 0) {
          const toDeleteE = getEditableSelectedEmojis(); // only editable emojis

          for (const selectedEmoji of toDeleteE) {
            const id = selectedEmoji.dataset.id;
            if (id) {
              await deleteObj(currentRoomId, id);
            }
            selectedEmoji.remove();

            selectedEmojis.delete(selectedEmoji);
            selectedEmoji.selected = false;
          }
        }

        if (eyeButton2.isActivated) {
          eyeButton2.isActivated = false;
          eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
          removeLabelInputs();
        }
      });

      appendToChatControls(removeButton2);

      const removeNodeButton = document.createElement('div');
      removeNodeButton.isActivated = false;
      removeNodeButton.classList.add('button');
      removeNodeButton.style.width = `168.75px`;
      removeNodeButton.style.height = `119.25px`;
      removeNodeButton.style.backgroundImage = "url('./icons/astray.png')";
      removeNodeButton.style.left = `40px`;
      removeNodeButton.style.top = `30px`;
      tab2.appendChild(removeNodeButton);
      removeNodeButton.addEventListener('pointerup', async (e) => {
        e.stopPropagation();
        e.preventDefault();

        const selectedNodeIds = network.getSelectedNodes(); // array of node IDs

        if (selectedNodeIds.length === 0) {
          alert('No node selected!');
          return;
        }

        for (const nodeId of selectedNodeIds) {
          const node = nodes.get(nodeId);
          if (!node) continue;

          // 1) Prevent deleting basic nodes (use ID-based check)
          if (basicNodeIds.has(nodeId)) {
            continue;
          }

          // 2) Remove from in-memory library (semantic layer)
          if (node.word) {
            library.delete(node.word);
          }

          // 3) Remove connected edges (visual + data layer)
          const connectedEdges = edges.get({
            filter: (edge) => edge.from === nodeId || edge.to === nodeId,
          });
          edges.remove(connectedEdges);

          // 4) Remove node from vis dataset
          nodes.remove(nodeId);
        }

        // 6) Clear selection after deletion
        network.unselectAll();

        // Persist the new full graph state (single-doc storage)
        await saveLibraryGraphForUser();
      });

      function dyeColor(symbol, color) {
        const svgElement = symbol.querySelector('svg');
        const paths = svgElement.querySelectorAll('path'); // Get the first shape inside the SVG
        paths.forEach((path) => {
          path.setAttribute('style', 'fill:' + color); // Change the fill attribute
        });
        symbol.color = color;
      }

      // Handle color selection
      palette.addEventListener('click', (e) => {
        if (e.target.classList.contains('color')) {
          selectedColor = e.target.style.backgroundColor; // Set the selected color
          if (selectedSymbols.size != 0) {
            selectedSymbols.forEach((selectedSymbol) => {
              dyeColor(selectedSymbol, selectedColor);
            });
          }
          console.log(`Selected color: ${selectedColor}`);
        }
      });

      const wheel = document.createElement('div'); // Your wheel sprite
      wheel.classList.add('wheel');
      wheel.style.left = `50px`; // Set the x position
      wheel.style.bottom = `40px`; // Set the y position
      wheel.style.width = `290.67px`;
      wheel.style.height = `292.33px`;
      wheel.style.backgroundImage = "url('./icons/wheel/wheel.png')";
      let wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2; // right x
      let wheelCenterY =
        window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
      console.log(
        `wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY} ${window.innerHeight} ${parseFloat(wheel.style.bottom)}`,
      );
      const centerRadius = 36; // Define center circle radius

      wheel.addEventListener('mousedown', async (e) => {
        const mouseX = e.clientX;
        const mouseY = e.clientY;

        // Calculate the distance from the center
        const dx = mouseX - wheelCenterX;
        const dy = mouseY - wheelCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < centerRadius) {
          wheel.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
          await createSymbolCopy(mouseX, mouseY, 8);
          return; // Center circle detected
        }

        // Calculate the angle in degrees (0Â° at the right, counterclockwise)
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
        angle = angle % 360;
        if (angle < 0) angle += 360; // Convert negative angles

        // Determine sector (each is 45Â°)
        let sectorIndex = Math.floor(angle / 45);
        if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
        wheel.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
        if (!isGenerating) {
          isGenerating = true;
          await createSymbolCopy(mouseX, mouseY, sectorIndex);
        }
      });

      wheel.addEventListener('mouseup', (event) => {
        wheel.style.backgroundImage = 'url(./icons/wheel/wheel.png)';
      });

      appendToCraftControls(wheel);

      const wheel2 = wheel.cloneNode(true);
      wheel2.addEventListener('mousedown', async (e) => {
        document.body.classList.add('no-text-select'); // prevent textbox selection

        const mouseX = e.clientX;
        const mouseY = e.clientY;

        // Calculate the distance from the center
        const dx = mouseX - wheelCenterX;
        const dy = mouseY - wheelCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < centerRadius) {
          console.log('Clicked center!');
          wheel2.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
          await createSymbolCopy(mouseX, mouseY, 8);
          return; // Center circle detected
        }

        // Calculate the angle in degrees (0Â° at the right, counterclockwise)
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
        angle = angle % 360;
        if (angle < 0) angle += 360; // Convert negative angles

        // Determine sector (each is 45Â°)
        let sectorIndex = Math.floor(angle / 45);
        if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
        wheel2.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
        if (!isGenerating) {
          isGenerating = true;
          const symbol = await createSymbolCopy(mouseX, mouseY, sectorIndex);
        }
      });

      wheel2.addEventListener('mouseup', (event) => {
        document.body.classList.remove('no-text-select');
        wheel2.style.backgroundImage = 'url(./icons/wheel/wheel.png)';
      });
      appendToChatControls(wheel2);

      // Function to handle the message when Enter is pressed
      async function handleMessage() {
        const messageBox = document.getElementById('message-input');
        const userInput = messageBox.value;

        if (userInput === '') {
          return;
        }

        messageBox.value = '';

        try {
          const response = await fetch('https://divinatory-conlang.zhouyt-tony2018.workers.dev/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              type: 'emoji',
              uid: currentUser?.uid || null,
              text: userInput,
              lang: currentLang,
            }),
          });

          const data = await response.json();

          console.warn('[client] usage', data.usage);

          if (typeof data.used === 'number' && typeof data.limit === 'number') {
            updateQuotaBadge(data.used, data.limit);
          }

          if (data.code === 'RATE_LIMITED') {
            alert(data.message);
            return;
          }

          if (data.ok === false && data.code === 'QUOTA_EXCEEDED') {
            showFeedback(data.message || "You have reached today's quota.", true);
            return;
          }

          await createEmoji(data.result);
        } catch (error) {
          console.error(error);
          alert('Emoji generation failed.');
        }
      }

      // Add event listener to the input box for the Enter key
      document.getElementById('message-input').addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
          handleMessage();
        }
      });

      function floatLabel(label) {
        const maxDistance = 20; // Maximum distance from the original position
        const originX = 0,
          originY = 0; // Store original position
        let x = 0,
          y = 0;

        setInterval(() => {
          let xDelta = getRandomFloat(-2, 2);
          let yDelta = getRandomFloat(-2, 2);

          // Calculate new position
          let newX = x + xDelta;
          let newY = y + yDelta;

          // Check if the new position is within the allowed distance
          let distance = Math.sqrt(newX ** 2 + newY ** 2);
          if (distance <= maxDistance) {
            x = newX;
            y = newY;
            label.style.transform = `translate(${x}px, ${y}px)`;
          }
        }, 100);
      }

      function buildDragGroupSet(draggedEl) {
        const isSelected = selectedSymbols.has(draggedEl) || selectedEmojis.has(draggedEl);

        if (!isSelected) return new Set([draggedEl]);

        // âœ… å¹¶é›†ï¼šæ‰€æœ‰è¢«é€‰ä¸­çš„ç¬¦å· + emoji
        const group = new Set();
        selectedSymbols.forEach((s) => group.add(s));
        selectedEmojis.forEach((em) => group.add(em));

        // å¦‚æœä½ ä¸æƒ³æŠŠâ€œç©ºé›†åˆâ€æ‹–æˆç©ºï¼Œå…œåº•ï¼š
        if (group.size === 0) group.add(draggedEl);
        return group;
      }

      async function createEmoji(emojiResponse, emojiX = null, emojiY = null, emojiId = null) {
        const emoji = document.createElement('div');
        emoji.classList.add('symbol-label');
        // Position the label near the symbol
        if (emojiX) {
          emoji.x = emojiX;
          emoji.y = emojiY;
        } else {
          emoji.x = getRandomFloat(window.innerWidth / 5, (window.innerWidth * 4) / 5);
          emoji.y = getRandomFloat(window.innerHeight / 5, (window.innerHeight * 4) / 5);
        }

        emoji.style.left = `${emoji.x}px`;
        emoji.style.top = `${emoji.y}px`;
        emoji.selected = false;

        // Add pressing event listener to the emoji
        emoji.addEventListener('mousedown', (e) => {
          const totalSelected = selectedSymbols.size + selectedEmojis.size;
          const inSelection = selectedEmojis.has(emoji);
          const wantsGroupDrag = inSelection && totalSelected > 1;

          // record click-vs-drag
          emoji._downClientX = e.clientX;
          emoji._downClientY = e.clientY;
          emoji._dragged = false;
          emoji._downWasSelected = selectedEmojis.has(emoji);
          emoji._downWasInMulti = wantsGroupDrag;
          emoji._downTotalSelected = selectedSymbols.size + selectedEmojis.size;

          // UI off
          if (eyeButton.isActivated) {
            eyeButton.isActivated = false;
            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
          if (eyeButton2.isActivated) {
            eyeButton2.isActivated = false;
            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }

          // Selection on mousedown:
          // If not selected, make it the only selection.
          if (!inSelection) {
            clearAllSymbolSelection();
            clearAllEmojiSelection();
            emoji.selected = true;
            emoji.classList.add('active');
            selectedEmojis.add(emoji);
          }

          // dragging is owner-only (selection still allowed)
          if (!canEditElement(emoji)) {
            emoji.style.cursor = 'not-allowed';
            clickOnlyEmoji = emoji;
            return;
          }

          emoji.style.cursor = 'grabbing';

          const canvas = getCanvasForElem(emoji);
          const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

          if (wantsGroupDrag) {
            dragLeader = emoji;
            dragGroup = new Map();

            setDragSnapLock(null, 'start drag');
            pendingSnapDelta = null;
            readyActive = readyTarget = null;
            readyActiveSide = readyTargetSide = null;
            dragGroupStarted = false;
            dragGroupSet = null;

            const groupSet = buildDragGroupSet(dragLeader);
            for (const el of groupSet) {
              if (!canEditElement(el)) continue; // can't drag others' items

              const l = parseFloat(el.style.left) || 0;
              const t = parseFloat(el.style.top) || 0;
              const dx = l - localX;
              const dy = t - localY;
              dragGroup.set(el, { dx, dy, dx0: dx, dy0: dy });
            }

            activeEmoji = emoji; // leader remains active
          } else {
            dragLeader = null;
            dragGroup = null;

            activeEmoji = emoji;

            const left = parseFloat(emoji.style.left) || 0;
            const top = parseFloat(emoji.style.top) || 0;
            emoji.offsetX = localX - left;
            emoji.offsetY = localY - top;
          }
        });

        appendToChatCanvas(emoji);
        emoji.textContent = emojiResponse; // Default text
        floatLabel(emoji);

        if (emojiId !== null) {
          emoji.dataset.id = emojiId;
        } else {
          // after you created the DOM element `symbol`
          emoji.dataset.id = ''; // not ready yet
          emoji._pendingIdPromise = (async () => {
            const docId = await saveObj('emoji', emojiResponse, emoji.x, emoji.y);
            emoji.dataset.id = docId;
            return docId;
          })();
        }

        return emoji;
      }

      window.addEventListener('resize', () => {
        wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2; // right x
        wheelCenterY =
          window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
        console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY}`);
      });

      function removeLabelInputs() {
        const labels = document.querySelectorAll('.symbol-label.removable');
        labels.forEach((label) => label.remove());
        const inputs = document.querySelectorAll('.label-input.removable');
        inputs.forEach((input) => input.remove());
        const textareas = document.querySelectorAll('.label-textarea.removable');
        textareas.forEach((textarea) => textarea.remove());
        const buttons = document.querySelectorAll('.submit-button.removable');
        buttons.forEach((button) => button.remove());
        const outputBoxes = document.querySelectorAll('.typing-effect.removable');
        outputBoxes.forEach((outputBox) => outputBox.remove());
      }

      function hideLabelInputs() {
        const labels = document.querySelectorAll('.symbol-label');
        labels.forEach((label) => label.classList.remove('active'));
        const inputs = document.querySelectorAll('input');
        inputs.forEach((input) => input.classList.remove('active'));
        const textareas = document.querySelectorAll('textarea');
        textareas.forEach((textarea) => textarea.classList.remove('active'));
        const buttons = document.querySelectorAll('.submit-button');
        buttons.forEach((button) => button.classList.remove('active'));
      }

      function showLabelInputs() {
        const labels = document.querySelectorAll('.symbol-label');
        labels.forEach((label) => label.classList.add('active'));
        const inputs = document.querySelectorAll('input');
        inputs.forEach((input) => input.classList.add('active'));
        const textareas = document.querySelectorAll('textarea');
        textareas.forEach((textarea) => textarea.add.remove('active'));
        const buttons = document.querySelectorAll('.submit-button');
        buttons.forEach((button) => button.classList.add('active'));
      }

      function clientToLocal(container, clientX, clientY) {
        const r = container.getBoundingClientRect();
        return { x: clientX - r.left, y: clientY - r.top };
      }

      function getCanvasForElem(el) {
        // å¦‚æœç¬¦å·/emoji è¢« append åˆ°å“ªä¸ª canvasï¼Œå°±ç”¨å“ªä¸ª canvas
        return el.closest('#craftCanvas, #chatCanvas');
      }

      let dragGroupStarted = false; // æœ¬æ¬¡ç¾¤æ‹–æ˜¯å¦å·²æ‰§è¡Œè¿‡â€œå¤–éƒ¨æ–­é“¾â€
      let dragGroupSet = null; // æ–¹ä¾¿åˆ¤æ–­ç»„å†…æˆå‘˜ï¼ˆSetï¼‰

      function cutConnectionsOutside(sym, groupSet) {
        const conns = currentGraph.getSymbolConnections(sym);
        if (!conns) return;

        const aId = sym.dataset?.id; // sym id once

        for (let side = 0; side < conns.length; side++) {
          const entryLst = conns[side] || [];
          if (!entryLst.length) continue;

          const remain = [];
          for (const [nbr, nbrSide] of entryLst) {
            if (groupSet.has(nbr)) {
              // âœ… Keep internal connection
              remain.push([nbr, nbrSide]);
            } else {
              // âœ… Cut external connection (memory)
              const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
              if (currentGraph.getSymbolConnections(nbr)) {
                currentGraph.getSymbolConnections(nbr)[nbrSide] = back.filter(([x]) => x !== sym);
              }

              // âœ… Cut external connection (Firestore) â€” IMPORTANT
              const bId = nbr?.dataset?.id;
              if (aId && bId) {
                removeLink(aId, side, bId, nbrSide).catch(console.error);
              }
            }
          }
          conns[side] = remain; // keep only internal links
        }
      }

      function detachSymbolLocal(symbol) {
        const conns = currentGraph.getSymbolConnections(symbol);
        if (!conns) return;

        for (let side = 0; side < conns.length; side++) {
          const lst = conns[side] || [];
          for (const [nbr, nbrSide] of lst) {
            // remove back-edge on neighbor
            const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
            currentGraph.getSymbolConnections(nbr)[nbrSide] = back.filter(([x]) => x !== symbol);
          }
          conns[side] = [];
        }
      }

      // Firestore removal (optional but recommended)
      async function detachSymbolRemote(symbol) {
        const aId = symbol.dataset?.id;
        if (!aId) return;

        const conns = currentGraph.getSymbolConnections(symbol);
        if (!conns) return;

        // removeLink(aId, side, bId, nbrSide) ä½ ä¹‹å‰å·²ç»æœ‰
        for (let side = 0; side < conns.length; side++) {
          const lst = conns[side] || [];
          for (const [nbr, nbrSide] of lst) {
            const bId = nbr.dataset?.id;
            if (bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
          }
        }
      }

      /** Detach immediately in memory, then best-effort in Firestore */
      function detachSymbol(symbol) {
        // remember old connections first (because local detach will clear the list)
        const snapshot = (currentGraph.getSymbolConnections(symbol) || []).map((arr) =>
          arr.slice(),
        );

        // local detach
        detachSymbolLocal(symbol);

        // remote detach (best-effort, no await to avoid UI stutter)
        const aId = symbol.dataset?.id;
        if (!aId) return;

        for (let side = 0; side < snapshot.length; side++) {
          for (const [nbr, nbrSide] of snapshot[side] || []) {
            const bId = nbr.dataset?.id;
            if (bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
          }
        }

        readyActive = null;
        readyTarget = null;
        readyActiveSide = null;
        readyTargetSide = null;
      }

      function cancelDraggingState() {
        activeSymbol = null;
        activeEmoji = null;

        dragGroup = null;
        dragLeader = null;

        dragGroupStarted = false;
        dragGroupSet = null;

        // âœ… also reset group-drag runtime flags to avoid lingering behavior
        groupDragActive = false;
        pendingSnapDelta = null;
        setDragSnapLock(null, 'cancel drag');

        // optional but usually correct: clear snap candidate
        readyActive = readyTarget = null;
        readyActiveSide = readyTargetSide = null;
      }

      function applyDeltaToGroup(dx, dy) {
        if (!dragGroup) return;

        for (const [el, off] of dragGroup.entries()) {
          if (!canEditElement(el)) continue;

          // âœ… Persist the delta into the stored offsets
          off.dx += dx;
          off.dy += dy;

          // Optional: update style immediately (not strictly necessary because render uses off.* next)
          const left = (parseFloat(el.style.left) || 0) + dx;
          const top = (parseFloat(el.style.top) || 0) + dy;
          el.style.left = `${left}px`;
          el.style.top = `${top}px`;
        }
      }

      document.addEventListener('mousemove', async (e) => {
        if (clickOnlySymbol && !clickOnlySymbol._dragged) {
          const dx = e.clientX - (clickOnlySymbol._downClientX ?? e.clientX);
          const dy = e.clientY - (clickOnlySymbol._downClientY ?? e.clientY);
          if (dx * dx + dy * dy > 16) clickOnlySymbol._dragged = true;
        }
        if (clickOnlyEmoji && !clickOnlyEmoji._dragged) {
          const dx = e.clientX - (clickOnlyEmoji._downClientX ?? e.clientX);
          const dy = e.clientY - (clickOnlyEmoji._downClientY ?? e.clientY);
          if (dx * dx + dy * dy > 16) clickOnlyEmoji._dragged = true;
        }

        // mark as dragged (for click-vs-drag toggle)
        if (activeSymbol && !activeSymbol._dragged) {
          const dx = e.clientX - (activeSymbol._downClientX ?? e.clientX);
          const dy = e.clientY - (activeSymbol._downClientY ?? e.clientY);
          if (dx * dx + dy * dy > 16) activeSymbol._dragged = true; // 4px
        }

        if (activeEmoji && !activeEmoji._dragged) {
          const dx = e.clientX - (activeEmoji._downClientX ?? e.clientX);
          const dy = e.clientY - (activeEmoji._downClientY ?? e.clientY);
          if (dx * dx + dy * dy > 16) activeEmoji._dragged = true; // 4px
        }

        if (dragGroup && dragLeader) {
          if (!canEditElement(dragLeader)) {
            cancelDraggingState();
            return;
          }

          // --- DEBUG throttle (log at most every 120ms) ---
          if (!window.__dbg) window.__dbg = {};
          const now = performance.now();
          if (!window.__dbg.t) window.__dbg.t = 0;
          const DBG = now - window.__dbg.t > 120;
          if (DBG) window.__dbg.t = now;

          groupDragActive = true;
          pendingSnapDelta = null;

          const canvas = getCanvasForElem(dragLeader);

          const pt = clientToLocal(canvas, e.clientX, e.clientY);
          if (!pt) {
            cancelDraggingState();
            return;
          }

          let localX = pt.x;
          let localY = pt.y;

          if (dragSnapLock) {
            localX = dragSnapLock.localX0;
            localY = dragSnapLock.localY0;
          }

          // âœ… ç¬¬ä¸€æ¬¡è¿›å…¥ç¾¤æ‹–ï¼šæŠŠç»„å†…æ‰€æœ‰ symbol ä¸â€œç»„å¤–â€æ–­å¼€ï¼ˆä¿ç•™ç»„å†…ï¼‰
          if (!dragGroupStarted) {
            dragGroupStarted = true;
            dragGroupSet = new Set(dragGroup.keys()); // å½“å‰è¢«æ‹–åŠ¨çš„æ‰€æœ‰å…ƒç´ ï¼ˆsymbol+emojiï¼‰

            for (const el of dragGroupSet) {
              if (el.classList?.contains('symbol')) {
                cutConnectionsOutside(el, dragGroupSet);
                el.moving = true; // è¡¨ç¤ºè¿™æ¬¡æ‹–æ‹½å·²ç»å¤„ç†è¿‡æ–­é“¾ï¼ˆé¿å…ä½ å…¶å®ƒé€»è¾‘é‡å¤ cutï¼‰
              }
            }
          }

          // Unlock by mouse travel (client distance)
          if (dragSnapLock) {
            const mdx = e.clientX - dragSnapLock.clientX0;
            const mdy = e.clientY - dragSnapLock.clientY0;
            const mouseDist = Math.hypot(mdx, mdy);

            if (mouseDist > UNSNAP_DISTANCE) {
              // Jump the whole group under the current cursor BEFORE unlocking.
              // This prevents the "cursor far away from objects after unlock" problem.
              const jumpDx = pt.x - dragSnapLock.localX0;
              const jumpDy = pt.y - dragSnapLock.localY0;
              applyDeltaToGroup(jumpDx, jumpDy);

              setDragSnapLock(null, 'unlock');

              for (const [el, off] of dragGroup.entries()) {
                off.dx = off.dx0;
                off.dy = off.dy0;
              }

              snapCooldownUntil = performance.now() + 150;
            }
          }

          for (const [el, off] of dragGroup.entries()) {
            const stillSelected = selectedSymbols.has(el) || selectedEmojis.has(el);
            if (!stillSelected) continue;

            if (!canEditElement(el)) continue;

            el.style.left = `${localX + off.dx}px`;
            el.style.top = `${localY + off.dy}px`;
          }

          if (
            dragLeader &&
            dragLeader.classList?.contains('symbol') &&
            !dragSnapLock &&
            performance.now() > snapCooldownUntil
          ) {
            pendingSnapDelta = null;
            readyActive = readyTarget = null;
            readyActiveSide = readyTargetSide = null;

            checkConnections(dragLeader);
          }

          if (pendingSnapDelta) {
            applyDeltaToGroup(pendingSnapDelta.dx, pendingSnapDelta.dy);
            pendingSnapDelta = null;

            if (!dragSnapLock) {
              setDragSnapLock(
                {
                  clientX0: e.clientX,
                  clientY0: e.clientY,
                  localX0: pt.x,
                  localY0: pt.y,
                  activeSide: readyActiveSide,
                  targetSide: readyTargetSide,
                  targetEl: readyTarget,
                },
                'snap applied',
              );
            }
          }

          for (const [el] of dragGroup.entries()) {
            if (el.classList?.contains('symbol') && el.isDynamic && el.dot) {
              updateDotPositionLocal(el.dot);
            }
          }

          // âœ… åªå¯¹ leaderï¼ˆè‹¥æ˜¯ symbolï¼‰æ‰§è¡Œä½ åŸæ¥çš„â€œæ–­é“¾/æ£€æŸ¥è¿æ¥â€é€»è¾‘
          if (activeSymbol) {
            const x = parseFloat(activeSymbol.style.left) || 0;
            const y = parseFloat(activeSymbol.style.top) || 0;

            if (activeSymbol.labels) {
              activeSymbol.labels.forEach((label) => {
                label.style.left = `${x + label.offsetX}px`;
                label.style.top = `${y + label.offsetY}px`;
              });
            }
            if (activeSymbol.input) {
              activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
              activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
            }
            if (activeSymbol.textarea) {
              activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
              activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
            }
            if (activeSymbol.submitButton) {
              const tTop = parseFloat(activeSymbol.textarea.style.top) || 0;
              activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
              activeSymbol.submitButton.style.top = `${tTop + 8 + activeSymbol.textarea.scrollHeight}px`;
            }
            if (activeSymbol.pElement) {
              const tTop = parseFloat(activeSymbol.textarea.style.top) || 0;
              activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
              activeSymbol.pElement.style.top = `${tTop - 10 + activeSymbol.textarea.scrollHeight}px`;
            }
            if (activeSymbol.doneButton) {
              activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
              activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
            }

            endLongPress();
            activeSymbol.classList.add('framed');
          }

          groupDragActive = false;
          return;
        }

        if (activeEmoji) {
          // ğŸš« not mine â†’ do nothing (still selected)
          if (!canEditElement(activeEmoji)) {
            cancelDraggingState();
            return;
          }
          const canvas = getCanvasForElem(activeEmoji);
          const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

          let x = localX - activeEmoji.offsetX;
          let y = localY - activeEmoji.offsetY;

          activeEmoji.style.left = `${x}px`;
          activeEmoji.style.top = `${y}px`;
          activeEmoji.selected = true;
        }

        if (activeSymbol) {
          endLongPress();

          // ğŸš« not mine â†’ do nothing (still selected)
          if (!canEditElement(activeSymbol)) {
            cancelDraggingState();
            return;
          }

          const canvas = getCanvasForElem(activeSymbol);
          const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

          let x = localX - activeSymbol.offsetX;
          let y = localY - activeSymbol.offsetY;
          activeSymbol.style.left = `${x}px`;
          activeSymbol.style.top = `${y}px`;
          activeSymbol.selected = true;

          // hideLabelInputs();
          if (activeSymbol.labels) {
            activeSymbol.labels.forEach((label) => {
              label.style.left = `${x + label.offsetX}px`;
              label.style.top = `${y + label.offsetY}px`;
            });
          }
          if (activeSymbol.input) {
            activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
            activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
          }
          if (activeSymbol.textarea) {
            activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
            activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
          }
          if (activeSymbol.submitButton) {
            activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
            activeSymbol.submitButton.style.top = `${parseFloat(activeSymbol.textarea.style.top) + 8 + activeSymbol.textarea.scrollHeight}px`;
          }
          if (activeSymbol.pElement) {
            activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
            activeSymbol.pElement.style.top = `${parseFloat(activeSymbol.textarea.style.top) - 10 + activeSymbol.textarea.scrollHeight}px`;
          }
          if (activeSymbol.doneButton) {
            activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
            activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
          }

          checkConnections(activeSymbol);

          const snappedCandidate = readyActive === activeSymbol && readyTarget != null;
          if (!activeSymbol.moving && !snappedCandidate) {
            // Cut connections
            const conns = currentGraph.getSymbolConnections(activeSymbol) || [];
            for (let i = 0; i < conns.length; i++) {
              const entryLst = conns[i] || [];
              if (entryLst.length) {
                for (let j = 0; j < entryLst.length; j++) {
                  const [nbr, nbrSide] = entryLst[j];
                  const targetEntry = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
                  currentGraph.getSymbolConnections(nbr)[nbrSide] = targetEntry.filter(
                    (sub) => sub[0] !== activeSymbol,
                  );

                  const aId = activeSymbol.dataset.id;
                  const bId = nbr.dataset.id;
                  if (aId && bId) removeLink(aId, i, bId, nbrSide).catch(console.error);
                }
                conns[i] = [];
              }
            }
            activeSymbol.moving = true;
          }

          if (!activeSymbol.classList.contains('framed')) {
            activeSymbol.classList.add('framed');
          }

          if (activeSymbol?.isDynamic && activeSymbol.dot) {
            updateDotPositionLocal(activeSymbol.dot);
          }
        }
      });

      function cleanupDetachedLinksFor(symbol, breakDist = 10) {
        const conns = currentGraph.getSymbolConnections(symbol);
        if (!conns) return;

        for (let side = 0; side < conns.length; side++) {
          const lst = conns[side] || [];
          // iterate backwards because we may splice
          for (let i = lst.length - 1; i >= 0; i--) {
            const [nbr, nbrSide] = lst[i];
            if (!nbr) continue;

            const aJ = getAbsJunctions(symbol)?.[side];
            const bJ = getAbsJunctions(nbr)?.[nbrSide];
            if (!aJ || !bJ) continue;

            const d = getDist(aJ.x, aJ.y, bJ.x, bJ.y);
            if (d <= breakDist) continue;

            // remove from symbol side
            lst.splice(i, 1);

            // remove reverse edge
            const back = currentGraph.getSymbolConnections(nbr)?.[nbrSide] || [];
            currentGraph.getSymbolConnections(nbr)[nbrSide] = back.filter(
              ([x, s]) => !(x === symbol && s === side),
            );

            // optional: removeLink(...) if you persist links
            const aId = symbol.dataset?.id;
            const bId = nbr.dataset?.id;
            if (aId && bId) removeLink(aId, side, bId, nbrSide).catch(console.error);
          }
        }
      }

      let lastPointerDownTarget = null;

      document.addEventListener(
        'pointerdown',
        (e) => {
          lastPointerDownTarget = e.target;
        },
        true,
      );

      function isBlankCanvasClick(e) {
        const content = document.querySelector('.content');
        if (!content) {
          return false;
        }

        // 1) Must click inside the content viewport (where you scroll)
        const cr = content.getBoundingClientRect();
        const inContent =
          e.clientX >= cr.left &&
          e.clientX <= cr.right &&
          e.clientY >= cr.top &&
          e.clientY <= cr.bottom;

        if (!inContent) {
          return false;
        }

        // 2) Only handle when Craft or Chat tab is active (otherwise don't clear)
        // Adjust these indices if yours differ
        const inCraft = !!document.querySelector('#tab1.active');
        const inChat = !!document.querySelector('#tab4.active');
        if (!inCraft && !inChat) {
          return false;
        }

        // 3) Find the real element under pointer (often .content in your scrolled-empty area)
        const el = document.elementFromPoint(e.clientX, e.clientY) || e.target;

        // 4) Clicked an item? then NOT blank
        const hitItem = !!el?.closest?.('.symbol, .symbol-label');

        // 5) Clicked UI? then NOT blank
        const hitUI = !!el?.closest?.(
          '#palette, .wheel, #chatControls, .vertical-bar, .tab, .button, .label-input, .label-textarea, .submit-button, .symbol-label',
        );

        return !hitItem && !hitUI;
      }

      function commitLink(a, aSide, b, bSide) {
        const aConns = currentGraph.getSymbolConnections(a);
        const bConns = currentGraph.getSymbolConnections(b);
        if (!aConns || !bConns) return;

        if (!aConns[aSide].some(([nbr, s]) => nbr === b && s === bSide))
          aConns[aSide].push([b, bSide]);
        if (!bConns[bSide].some(([nbr, s]) => nbr === a && s === aSide))
          bConns[bSide].push([a, aSide]);
      }

      function violatesConflicts(target, targetSide) {
        const conns = currentGraph.getSymbolConnections(target) || [];
        const conflicts = SIDE_CONFLICTS.get(targetSide) || [];
        for (const s of conflicts) {
          if ((conns[s]?.length || 0) > 0) return true;
        }
        return false;
      }

      document.addEventListener('mouseup', async (e) => {
        selectionClickHandled = false;

        if (marqueeActive || marqueeJustDidSelect) {
          marqueeJustDidSelect = false; // clear after using marquee box
          return; // don't run isBlankCanvasClick and don't clear selection
        }

        const activeTab = document.querySelector('.tab-content.active');
        const existingInput = activeTab?.querySelector('.label-input');

        endLongPress(true);
        wheel.style.backgroundImage = 'url(./icons/wheel/wheel.png)';
        wheel2.style.backgroundImage = 'url(./icons/wheel/wheel.png)';

        if (activeSymbol) {
          const released = activeSymbol;
          activeSymbol = null;
          released.style.cursor = 'grab';

          // --- 1) Decide final selection state for this mouseup ---
          // Default: keep selected
          let shouldBeSelected = true;

          // Click (no drag) toggles if:
          // - started from multi-selection (marquee), OR
          // - started as single selection (only 1 selected on mousedown)
          const clickToggle =
            !longPressFired &&
            !released._dragged &&
            (released._downWasInMulti || released._downWasSelected);

          if (clickToggle) {
            selectionClickHandled = true;
            shouldBeSelected = !selectedSymbols.has(released);
          } else {
            shouldBeSelected = true; // drag or normal press keeps it selected
          }

          // --- 2) Apply selection state ONCE (sync property + class + Set) ---
          released.selected = shouldBeSelected;
          if (shouldBeSelected) {
            released.classList.add('framed');
            selectedSymbols.add(released);
          } else {
            if (clickToggle) cancelDraggingState();
            released.classList.remove('framed');
            selectedSymbols.delete(released);

            // Turn off UI modes when deselecting (optional but matches your behavior)
            if (eyeButton.isActivated) {
              eyeButton.isActivated = false;
              eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
              removeLabelInputs();
            }
            if (eyeButton2.isActivated) {
              eyeButton2.isActivated = false;
              eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
              removeLabelInputs();
            }
          }

          // --- 3) Commit link ONLY if the released symbol is selected and is the snap candidate ---
          if (shouldBeSelected && readyActive && readyTarget && readyActive === released) {
            if (violatesConflicts(readyTarget, readyTargetSide)) {
              console.warn('[COMMIT BLOCKED] conflict', {
                targetElem: readyTarget.elemIdTrue,
                targetSide: readyTargetSide,
              });
            } else {
              commitLink(readyActive, readyActiveSide, readyTarget, readyTargetSide);

              // Persist only if both ids exist
              const aId = readyActive.dataset?.id;
              const bId = readyTarget.dataset?.id;
              if (aId && bId) {
                persistLink(aId, readyActiveSide, bId, readyTargetSide).catch(console.error);
              }
            }

            // Clear candidate after using it (avoid accidental re-commit)
            readyActive = readyTarget = null;
            readyActiveSide = readyTargetSide = null;
          }

          // --- 4) Persist position / dot only for single drag (not group drag) ---
          if (!dragGroup) {
            const x = parseFloat(released.style.left);
            const y = parseFloat(released.style.top);

            (async () => {
              let id = released.dataset?.id;
              if (!id && released._pendingIdPromise) id = await released._pendingIdPromise;
              if (id) await updateObjPosition(id, x, y);
            })().catch(console.error);

            if (released.isDynamic && released.dot) {
              updateDotPositionLocal(released.dot);
              persistDotPosition(released.dot).catch(console.error);
            }
          }

          // --- 5) Reset per-drag flags ---
          released.moving = false;
          isGenerating = false;
        }

        if (activeEmoji) {
          const released = activeEmoji;
          activeEmoji = null;
          released.style.cursor = 'grab';

          const clickToggle =
            !released._dragged && (released._downWasInMulti || released._downWasSelected);

          if (clickToggle) {
            selectionClickHandled = true;
            if (selectedEmojis.has(released)) {
              cancelDraggingState();
              released.selected = false;
              released.classList.remove('active');
              selectedEmojis.delete(released);
            } else {
              // turning ON
              clearAllSymbolSelection();
              clearAllEmojiSelection();

              released.selected = true;
              released.classList.add('active');
              selectedEmojis.add(released);
            }
          } else {
            // drag or normal press keeps it selected
            released.selected = true;
            released.classList.add('active');
            selectedEmojis.add(released);
          }

          // Persist position only if this wasn't a group drag
          if (!dragGroup) {
            const x = parseFloat(released.style.left);
            const y = parseFloat(released.style.top);

            (async () => {
              let id = released.dataset?.id;
              if (!id && released._pendingIdPromise) id = await released._pendingIdPromise;
              if (id) await updateObjPosition(id, x, y);
            })().catch(console.error);
          }
        }

        if (clickOnlySymbol) {
          const s = clickOnlySymbol;

          if (!s._dragged) {
            selectionClickHandled = true;

            // Same toggle rule as activeSymbol:
            // click toggles only if it was already selected at mousedown OR in multi-selection
            const clickToggle = s._downWasInMulti || s._downWasSelected;

            if (clickToggle) {
              // toggle off/on
              if (selectedSymbols.has(s)) {
                s.selected = false;
                s.classList.remove('framed');
                selectedSymbols.delete(s);
              } else {
                clearAllSymbolSelection();
                clearAllEmojiSelection();
                s.selected = true;
                s.classList.add('framed');
                selectedSymbols.add(s);
              }
            } else {
              // first-time click: keep it selected (single-select)
              clearAllSymbolSelection();
              clearAllEmojiSelection();
              s.selected = true;
              s.classList.add('framed');
              selectedSymbols.add(s);
            }
          }

          clickOnlySymbol = null;
        }

        if (clickOnlyEmoji) {
          const em = clickOnlyEmoji;

          if (!em._dragged) {
            selectionClickHandled = true;

            const clickToggle = em._downWasInMulti || em._downWasSelected;

            if (clickToggle) {
              if (selectedEmojis.has(em)) {
                em.selected = false;
                em.classList.remove('active');
                selectedEmojis.delete(em);
              } else {
                clearAllSymbolSelection();
                clearAllEmojiSelection();
                em.selected = true;
                em.classList.add('active');
                selectedEmojis.add(em);
              }
            } else {
              clearAllSymbolSelection();
              clearAllEmojiSelection();
              em.selected = true;
              em.classList.add('active');
              selectedEmojis.add(em);
            }
          }

          clickOnlyEmoji = null;
        }

        if (selectionClickHandled) return;

        if (dragGroup) {
          for (const el of dragGroup.keys()) {
            const id = el.dataset?.id;
            const x = parseFloat(el.style.left);
            const y = parseFloat(el.style.top);
            if (id) updateObjPosition(id, x, y).catch(console.error);

            if (el.isDynamic && el.dot) {
              updateDotPositionLocal(el.dot);
              persistDotPosition(el.dot).catch(console.error);
            }
          }

          // After group drag ends, reset per-symbol drag flags
          if (dragGroupSet) {
            for (const el of dragGroupSet) {
              if (el.classList?.contains('symbol')) {
                el.moving = false;
                cleanupDetachedLinksFor(el, 10);
              }
            }
          }
          dragGroup = null;
          dragLeader = null;
          dragGroupStarted = false;
          dragGroupSet = null;
          groupDragActive = false;
          pendingSnapDelta = null;
          setDragSnapLock(null, 'end drag');
          readyActive = readyTarget = null;
          readyActiveSide = readyTargetSide = null;
        }

        let rect;

        // waiting for an explanation input, so input boxes aren't fragile (i.e. disappear when canvas is clicked)
        if (!existingInput && isBlankCanvasClick(e)) {
          // clear symbols safely
          for (const s of Array.from(selectedSymbols)) {
            s.classList.remove('framed');
            s.selected = false;
          }
          selectedSymbols.clear();

          // clear emojis safely
          for (const em of Array.from(selectedEmojis)) {
            em.classList.remove('active');
            em.selected = false;
          }
          selectedEmojis.clear();

          if (eyeButton.isActivated) {
            eyeButton.isActivated = false;
            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
          if (eyeButton2.isActivated) {
            eyeButton2.isActivated = false;
            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
        }

        longPressFired = false;
      });

      let marqueeActive = false; // å½“å‰æ˜¯å¦åœ¨æ¡†é€‰æ‰‹åŠ¿ä¸­
      let marqueeJustDidSelect = false; // è¿™ä¸€è½® pointerup æ˜¯å¦åˆšåšè¿‡æ¡†é€‰é€‰æ‹©

      function enableMarqueeSelection({
        canvasEl,
        itemSelector,
        ignoreSelector = '',
        clearSelection,
        onSelect,
      }) {
        let isDown = false;
        let isDragging = false;
        let downOnItem = false;

        let startClientX = 0,
          startClientY = 0;
        let box = null;

        function shouldIgnoreTarget(target) {
          if (!ignoreSelector) return false;
          return !!target.closest(ignoreSelector);
        }

        function ensureBox() {
          if (box) return box;
          box = document.createElement('div');
          box.className = 'marquee-box';
          // å…³é”®ï¼šä¸è¦è®©è“æ¡†åƒæ‰äº‹ä»¶
          box.style.position = 'absolute';
          box.style.pointerEvents = 'none';
          box.style.display = 'none';
          canvasEl.appendChild(box);
          return box;
        }

        function showBox(clientX1, clientY1, clientX2, clientY2) {
          const r = canvasEl.getBoundingClientRect();
          const x1 = Math.min(clientX1, clientX2) - r.left;
          const y1 = Math.min(clientY1, clientY2) - r.top;
          const x2 = Math.max(clientX1, clientX2) - r.left;
          const y2 = Math.max(clientY1, clientY2) - r.top;

          const b = ensureBox();
          b.style.left = `${x1}px`;
          b.style.top = `${y1}px`;
          b.style.width = `${x2 - x1}px`;
          b.style.height = `${y2 - y1}px`;
          b.style.display = 'block';
        }

        function hideBox() {
          if (!box) return;
          box.style.display = 'none';
        }

        // ç”¨è§†å£åæ ‡åšç›¸äº¤åˆ¤æ–­ï¼šselectionRect ä¸ itemRect éƒ½æ˜¯ viewport coords
        function selectInRect(clientX1, clientY1, clientX2, clientY2) {
          const selLeft = Math.min(clientX1, clientX2);
          const selTop = Math.min(clientY1, clientY2);
          const selRight = Math.max(clientX1, clientX2);
          const selBottom = Math.max(clientY1, clientY2);

          // åªåœ¨ canvas å†…æ‰¾ itemsï¼ˆé¿å…æ‰«åˆ°åˆ«çš„ tabï¼‰
          const items = canvasEl.querySelectorAll(itemSelector);

          clearSelection?.();

          items.forEach((el) => {
            const rect = el.getBoundingClientRect();
            const intersects =
              rect.right >= selLeft &&
              rect.left <= selRight &&
              rect.bottom >= selTop &&
              rect.top <= selBottom;

            if (intersects) onSelect?.(el);
          });
        }

        // ç”¨ pointer äº‹ä»¶æ›´ç¨³ï¼ˆé¼ æ ‡ç§»å‡ºä¹Ÿä¸ä¸¢ï¼‰
        canvasEl.addEventListener('pointerdown', (e) => {
          if (e.button !== 0) return; // åªå·¦é”®
          if (shouldIgnoreTarget(e.target)) return;

          downOnItem = !!e.target.closest(itemSelector);

          isDown = true;
          isDragging = false;
          startClientX = e.clientX;
          startClientY = e.clientY;

          // æ•è· pointerï¼Œé¿å…æ‹–å‡º canvas åæ–­æ‰
          canvasEl.setPointerCapture?.(e.pointerId);
        });

        canvasEl.addEventListener('pointermove', (e) => {
          if (!isDown) return;

          if (downOnItem) return;

          const dx = e.clientX - startClientX;
          const dy = e.clientY - startClientY;
          const dist2 = dx * dx + dy * dy;

          // å°äºé˜ˆå€¼ä¸ç®—æ‹–æ‹½ï¼Œé¿å…ç‚¹ä¸€ä¸‹ä¹Ÿç”»æ¡†
          if (!isDragging && dist2 < 16) return;

          if (!isDragging) {
            isDragging = true;
            marqueeActive = true;
          }

          showBox(startClientX, startClientY, e.clientX, e.clientY);
          e.preventDefault();
        });

        canvasEl.addEventListener('pointerup', (e) => {
          if (!isDown) return;
          isDown = false;

          if (isDragging) {
            selectInRect(startClientX, startClientY, e.clientX, e.clientY);
            marqueeJustDidSelect = true;
          }

          hideBox();
          isDragging = false;
          downOnItem = false;
          marqueeActive = false;
        });

        canvasEl.addEventListener('pointercancel', () => {
          isDown = false;
          isDragging = false;
          downOnItem = false;
          marqueeActive = false;
          hideBox();
        });
      }

      function clearAllSymbolSelection() {
        // Remove frames from ALL selected symbols (mine + others)
        for (const s of Array.from(selectedSymbols)) {
          s.selected = false;
          s.classList.remove('framed');
        }
        selectedSymbols.clear();
      }

      function clearAllEmojiSelection() {
        for (const e of Array.from(selectedEmojis)) {
          e.selected = false;
          e.classList.remove('active');
        }
        selectedEmojis.clear();
      }

      function getRandomSubset(words, count) {
        return words.sort(() => Math.random() - 0.5).slice(0, count);
      }
      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }

      function areSetsEqual(set1, set2) {
        if (!set1 || !set2) return false; // guard against null values
        if (set1.size !== set2.size) return false; // Different sizes â†’ not equal
        for (let elem of set1) {
          if (!set2.has(elem)) return false; // If set2 is missing an element â†’ not equal
        }
        return true;
      }

      function buildSubgraphFromSelection(fullGraph, selectedSymbols) {
        const subGraph = new SymbolGraph();

        // add every selected symbol to the subgraph
        for (const symbol of selectedSymbols) {
          const connections = fullGraph.getSymbolConnections(symbol);
          if (!connections) continue;

          // deep-copy connection structure to avoid polluting the original graph
          subGraph.addSymbol(
            symbol,
            connections.map((side) => side.filter(([neighbor]) => selectedSymbols.has(neighbor))),
          );
        }

        return subGraph;
      }

      // Function to create labels for selected symbols
      function showSimpleLabel() {
        let labelData = [];

        selectedSymbols.forEach((selectedSymbol) => {
          // Check if label already exists
          if (!selectedSymbol.querySelector('.symbol-label')) {
            const words = tSymbolLabels(selectedSymbol.elemIdTrue, selectedSymbol.isDynamic);

            if (getDir(selectedSymbol) === 0 && !selectedSymbol.isDynamic) {
              if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 3)
                words.push(...extra('rightSide'));
              if (selectedSymbol.elemIdTrue === 4 || selectedSymbol.elemIdTrue === 6)
                words.push(...extra('leftSide'));
            }

            if (getDir(selectedSymbol) === 1) {
              if (selectedSymbol.elemIdTrue === 1) {
                if (selectedSymbol.isDynamic) {
                  words.push(...extra('gravity'));
                } else {
                  words.push(...extra('roof'));
                }
              }
              if (selectedSymbol.elemIdTrue === 3) {
                if (!selectedSymbol.isDynamic) {
                  words.push(...extra('aerial'));
                }
              }
              if (selectedSymbol.elemIdTrue === 4) {
                if (selectedSymbol.isDynamic) {
                  // console.log('fly highhhhh');
                  words.push(...extra('ascend'));
                } else {
                  words.push(...extra('ground'));
                }
              }
            }

            let subset = getRandomSubset(words, 2);

            // âœ… è§†å£åæ ‡ -> canvas å±€éƒ¨åæ ‡
            const rect = selectedSymbol.getBoundingClientRect();
            const canvas = getCanvasForElem(selectedSymbol);
            const canvasRect = canvas ? canvas.getBoundingClientRect() : { left: 0, top: 0 };

            const cx = rect.left - canvasRect.left + rect.width / 2;
            const cy = rect.top - canvasRect.top + rect.height / 2;

            for (const word of subset) {
              labelData.push([word, cx, cy, selectedSymbol]);
            }
          }
        });

        const foundIds = new Set();
        const elimBasic = new Set(); // we don't want basic-level symbols to connect to symbols that are much advanced than them
        const representatives = new Map();
        let hasDuplicateExpression = false;

        const selectionGraph = buildSubgraphFromSelection(currentGraph, selectedSymbols);

        for (const [storedWord, [storedId, storedGraph]] of library) {
          let foundMatching = matchPatternOnSelection(selectedSymbols, storedGraph);
          if (areSetsEqual(foundMatching, selectedSymbols)) hasDuplicateExpression = true;

          if (foundMatching != null) {
            let avgX = 0,
              avgY = 0;
            let lastSymbol;

            // å–ä»»æ„ä¸€ä¸ª symbol æ‰¾åˆ°å…±åŒ canvas
            const first = foundMatching.values().next().value;
            const canvas = getCanvasForElem(first);
            const canvasRect = canvas.getBoundingClientRect();

            for (const symbol of foundMatching) {
              const rect = symbol.getBoundingClientRect();

              // âœ… è§†å£åæ ‡ -> canvas å±€éƒ¨åæ ‡
              const cx = rect.left - canvasRect.left + rect.width / 2;
              const cy = rect.top - canvasRect.top + rect.height / 2;

              avgX += cx;
              avgY += cy;
              lastSymbol = symbol;
            }

            representatives.set(lastSymbol, storedWord);
            avgX /= foundMatching.size;
            avgY /= foundMatching.size;

            labelData.push([storedWord, avgX, avgY, lastSymbol]);
            foundIds.add(storedId);

            for (const symbol of foundMatching) {
              elimBasic.add(symbol);
            }
          }
        }

        labelData.forEach((labelDataSub) => {
          const label = document.createElement('div');
          label.classList.add('symbol-label', 'removable');
          // Position the label near the symbol
          label.x = labelDataSub[1] + getRandomFloat(-100, 20);
          label.y = labelDataSub[2] + getRandomFloat(-30, 0);

          if (labelDataSub[3].labels === undefined) {
            labelDataSub[3].labels = new Set([label]);
          } else {
            labelDataSub[3].labels.add(label);
          }
          label.offsetX = label.x - parseFloat(labelDataSub[3].style.left);
          label.offsetY = label.y - parseFloat(labelDataSub[3].style.top);
          label.style.left = `${label.x}px`;
          label.style.top = `${label.y}px`;

          // 1) avoid triggering global logic when clicked on labels
          label.addEventListener(
            'pointerdown',
            (e) => {
              e.stopPropagation();
            },
            true,
          );

          // 2) remove label on pointerup
          label.addEventListener('pointerup', (e) => {
            e.stopPropagation();
            label.remove();
          });

          if (tabHeadersActivated[1]) appendToCraftCanvas(label);
          if (tabHeadersActivated[4]) appendToChatCanvas(label);
          label.textContent = labelDataSub[0]; // Default text
          floatLabel(label);
        });
        return [foundIds, elimBasic, representatives, hasDuplicateExpression];
      }

      function updateQuotaBadge(used, limit) {
        const el = document.getElementById('quota-badge');
        if (!el) return;

        const remaining = Math.max(0, limit - used);

        // short code for display, full UID copied
        const uid = currentUser?.uid || '';
        const code = uid ? uid.slice(0, 10) : 'â€¦';

        const kofiUrl = 'https://ko-fi.com/ukiriz'; // æ¢æˆä½ çš„ Ko-fi é“¾æ¥

        const t = I18N[currentLang];

        el.innerHTML = `
            <div><strong>${t.credits(used, limit)}</strong></div>

            <div style="margin-top:4px; font-size:12px;">
            ${t.supportCode}:
            <span id="support-code" style="text-decoration: underline; cursor: pointer;">${code}</span>
            <span style="opacity:0.8;">${t.clickToCopy}</span>
            </div>

            <div style="margin-top:6px; font-size:12px;">
            <a id="kofi-link" href="${kofiUrl}" target="_blank" rel="noopener noreferrer"
                style="text-decoration: underline; color: inherit;">
                ${t.supportOnKofi}
            </a>
            </div>
        `;

        const sc = document.getElementById('support-code');
        if (sc && uid) {
          sc.onclick = async () => {
            const text = `UID:${uid}`;

            try {
              // modern clipboard API
              await navigator.clipboard.writeText(text);
              console.log('[copy] clipboard API success:', text);
            } catch (err) {
              console.warn('[copy] clipboard API failed, fallback:', err);

              // fallback
              const ta = document.createElement('textarea');
              ta.value = text;
              ta.style.position = 'fixed';
              ta.style.left = '-9999px';
              ta.style.top = '-9999px';
              document.body.appendChild(ta);
              ta.focus();
              ta.select();

              const ok = document.execCommand('copy');
              document.body.removeChild(ta);

              console.log('[copy] execCommand result:', ok, text);

              if (!ok) {
                // last resort: prompt user
                window.prompt('Copy this UID:', text);
              }
            }

            // visual feedback
            const old = sc.textContent;
            sc.textContent = `${old} âœ“`;
            setTimeout(() => (sc.textContent = old), 1200);
          };
          sc.onmousedown = (e) => e.stopPropagation();
          sc.onmouseup = (e) => e.stopPropagation();
        }

        const kofi = document.getElementById('kofi-link');
        if (kofi) {
          kofi.onmousedown = (e) => e.stopPropagation();
          kofi.onmouseup = (e) => e.stopPropagation();
          kofi.onclick = (e) => e.stopPropagation();
        }
      }

      function getSupportCode() {
        const uid = currentUser?.uid || '';
        return uid ? uid.slice(0, 10) : '';
      }

      async function refreshQuotaBadge() {
        if (!currentUser?.uid) return;
        try {
          const resp = await fetch('https://divinatory-conlang.zhouyt-tony2018.workers.dev/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'quotaStatus', uid: currentUser.uid }),
          });
          const data = await resp.json();
          if (data.ok && typeof data.used === 'number' && typeof data.limit === 'number') {
            updateQuotaBadge(data.used, data.limit);
          }
        } catch (e) {
          console.warn('refreshQuotaBadge failed', e);
        }
      }

      let rightMost;
      let topMost;

      // Function to create a text input near the symbol
      function showInput(foundIds, elimBasic, representatives, hasDuplicateExpression) {
        function computeSelectionBoundsLocal() {
          const first = selectedSymbols.values().next().value;
          if (!first) return null;

          const canvas = first.closest('#craftCanvas, #chatCanvas');
          if (!canvas) return null;

          const canvasRect = canvas.getBoundingClientRect();

          let rightMost = -Infinity;
          let topMost = Infinity;

          for (const s of selectedSymbols) {
            const r = s.getBoundingClientRect();
            const right = r.right - canvasRect.left; // canvas-local
            const top = r.top - canvasRect.top; // canvas-local
            if (right > rightMost) rightMost = right;
            if (top < topMost) topMost = top;
          }

          return { canvas, rightMost, topMost };
        }

        const inputParent = selectedSymbols.values().next().value;
        if (!inputParent) return;

        const parentLeft = parseFloat(inputParent.style.left) || 0;
        const parentTop = parseFloat(inputParent.style.top) || 0;

        const bounds = computeSelectionBoundsLocal();
        if (!bounds) return;

        const { canvas, rightMost, topMost } = bounds;

        const input = document.createElement('input');
        input.classList.add('label-input', 'removable');
        input.type = 'text';
        input.placeholder = 'What word is this?';
        input.maxLength = 22;

        // locate input in the canvas-local coordinate system
        input.x = rightMost + 5;
        input.y = topMost - 2;

        input.offsetX = input.x - parentLeft;
        input.offsetY = input.y - parentTop;

        input.style.position = 'absolute';
        input.style.left = `${input.x}px`;
        input.style.top = `${input.y}px`;

        inputParent.input = input;
        input.focus();

        appendToCraftCanvas(input);

        const textarea = document.createElement('textarea');
        textarea.classList.add('label-textarea', 'removable');
        textarea.placeholder = 'Why?';
        textarea.maxLength = 100;

        // Position the textarea near the symbol
        textarea.x = rightMost + 5;
        textarea.y = topMost + 35;

        textarea.offsetX = textarea.x - parentLeft;
        textarea.offsetY = textarea.y - parentTop;

        textarea.style.position = 'absolute';
        textarea.style.left = `${textarea.x}px`;
        textarea.style.top = `${textarea.y}px`;

        inputParent.textarea = textarea;

        textarea.focus();

        // Adjust height dynamically as user types
        textarea.addEventListener('input', function () {
          textarea.style.height = 'auto'; // Reset height first
          textarea.style.height = `${textarea.scrollHeight}px`; // Set new height based on content
          submitButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
          cancelButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
        });

        appendToCraftCanvas(textarea);

        // Create the submit button
        const submitButton = document.createElement('button');
        submitButton.classList.add('submit-button', 'removable');
        submitButton.innerHTML = 'âœ”'; // Check mark icon

        submitButton.x = rightMost + 5;
        submitButton.y = topMost + 43 + textarea.scrollHeight;

        submitButton.offsetX = submitButton.x - parentLeft;
        submitButton.offsetY = submitButton.y - parentTop;
        submitButton.style.left = `${submitButton.x}px`; // Position to the right of the textbox
        submitButton.style.top = `${submitButton.y}px`;

        inputParent.submitButton = submitButton;

        appendToCraftCanvas(submitButton);

        // Create the cancel button
        const cancelButton = document.createElement('button');
        cancelButton.classList.add('submit-button', 'removable');
        cancelButton.innerHTML = 'âœ˜'; // X mark icon

        cancelButton.x = rightMost + 40;
        cancelButton.y = topMost + 43 + textarea.scrollHeight;

        cancelButton.offsetX = cancelButton.x - parentLeft;
        cancelButton.offsetY = cancelButton.y - parentTop;
        cancelButton.style.left = `${cancelButton.x}px`; // Position to the right of the textbox
        cancelButton.style.top = `${cancelButton.y}px`;

        inputParent.cancelButton = cancelButton;

        appendToCraftCanvas(cancelButton);

        let word;
        let definition;
        let justification;

        // Handle button click event
        submitButton.onclick = async function () {
          word = input.value;

          // Recalculate the molecule to incorporate the advanced vocabulary

          // If the user has only selected one symbol
          if (selectedSymbols.size === 1) {
            moleculeString = getMoleculeChar(selectedSymbols.values().next().value);
          } else if (selectedSymbols.size > 1) {
            triggerLongPress(selectedSymbols.values().next().value, representatives);
          }

          definition = moleculeString;
          justification = textarea.value;

          console.log(`word ${word} definition ${definition} justification ${justification}`); // Handle submission logic here
          //input.remove();
          //textarea.remove();

          submitButton.remove();
          cancelButton.remove();
          input.readOnly = true;
          textarea.readOnly = true;

          if (!word || !definition || !justification) {
            showFeedback('Please fill in all fields!', true);
            return;
          }
          console.warn('[submit] library size =', library?.size);
          console.warn('[submit] library has word?', word, library?.has(word));
          console.warn('[submit] library keys =', [...(library?.keys?.() || [])]);
          if (library.has(word)) {
            showFeedback('You have already defined the word!', true);
            return;
          }

          if (hasDuplicateExpression) {
            showFeedback('You have already used this expression for defining another word!', true);
            return;
          }

          try {
            const response = await fetch(
              'https://divinatory-conlang.zhouyt-tony2018.workers.dev/',
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  type: 'conlang',
                  uid: currentUser?.uid || null,
                  word,
                  definition,
                  justification,
                  lang: currentLang,
                }),
              },
            );

            const data = await response.json();

            console.warn('[client] usage', data.usage);
            console.warn('[client] lang', data.debugLang);

            if (typeof data.used === 'number' && typeof data.limit === 'number') {
              updateQuotaBadge(data.used, data.limit);
            }

            if (data.code === 'RATE_LIMITED') {
              alert(data.message);
              return;
            }

            if (data.ok === false && data.code === 'QUOTA_EXCEEDED') {
              showFeedback(data.message || "You have reached today's quota.", true);
              return;
            }

            showFeedback(data.result || data.error || 'No response', false);
          } catch (error) {
            console.error(error);
            alert('Validation failed.');
          }
        };

        cancelButton.onclick = function () {
          if (eyeButton.isActivated) {
            eyeButton.isActivated = false;
            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
        };

        function endsWithLatinLetter(s) {
          if (!s) return false;
          // get last non-newline char
          const t = s.replace(/\n+$/, '');
          const last = t.slice(-1);
          return /[A-Za-z]$/.test(last);
        }

        function showFeedback(feedback, manualFailed = false) {
          console.log(`foundIds init ${foundIds}`);
          // Create the div element
          const outputBox = document.createElement('div');
          outputBox.classList.add('typing-effect', 'removable');

          const bounds = computeSelectionBoundsLocal();
          if (!bounds) return;

          const { canvas, rightMost } = bounds; // ä½ è¿™é‡Œåªç”¨ rightMost ä¹Ÿè¡Œ

          // Create the p element
          const pElement = document.createElement('p');
          pElement.x = rightMost + 5;
          pElement.y = parseFloat(textarea.style.top) - 10 + textarea.scrollHeight;
          console.log(`scroll ${textarea.scrollHeight}`);

          pElement.offsetX = pElement.x - parentLeft;
          pElement.offsetY = pElement.y - parentTop;
          pElement.style.left = `${pElement.x}px`; // Position to the right of the textbox
          pElement.style.top = `${pElement.y}px`;

          inputParent.pElement = pElement;

          // Create a span element to hold the text (so the cursor stays at the end)
          const textSpan = document.createElement('span');
          textSpan.id = 'typingText';
          pElement.appendChild(textSpan);

          // Create a cursor span element
          const cursorSpan = document.createElement('span');
          cursorSpan.id = 'cursor';
          cursorSpan.textContent = '|'; // Cursor symbol
          pElement.appendChild(cursorSpan);

          // Append the p element to the div element
          outputBox.appendChild(pElement);

          // Append the div element to the body of the document
          if (tabHeadersActivated[1]) appendToCraftCanvas(outputBox);
          if (tabHeadersActivated[4]) appendToChatCanvas(outputBox);

          const text = feedback;
          let index = 0;
          const speed = 10; // Speed of typing in milliseconds

          const maxLineLen = currentLang === 'zh' ? 20 : 24;
          console.warn('maxlinelen', maxLineLen);
          let lineIndex = 0;
          let passed;
          function type(onComplete) {
            const span = document.getElementById('typingText');
            if (!span) return;

            if (index < text.length) {
              const len = span.textContent.length;

              if (len > 0 && len % maxLineLen === 0) {
                // If the current line ends with a Latin letter, add hyphen before newline
                if (endsWithLatinLetter(span.textContent)) {
                  span.textContent += '-';
                }
                span.textContent += '\n';
                lineIndex++;
              }

              // append next char
              span.textContent += text.charAt(index);
              index++;

              setTimeout(() => type(onComplete), speed);
            } else {
              const firstToken = (text || '')
                .trim()
                .split(/\s+/)[0]
                .replace(/[^A-Za-z]/g, '');

              passed = firstToken === 'Yes';
              if (onComplete) onComplete(passed);
            }
          }

          function showDoneButton(passed) {
            console.log(`foundIds ${foundIds}`);

            const doneButton = document.createElement('button');
            doneButton.classList.add('submit-button', 'removable');
            if (passed) {
              doneButton.innerHTML = 'âœ”'; // Check mark icon
            } else {
              doneButton.innerHTML = 'âœ˜'; // X mark icon
            }

            doneButton.x = rightMost + 5; // Position to the right of the textbox

            // Make sure the paragraph has laid out with all typed text
            const pTop = parseFloat(pElement.style.top) || 0;

            // Use actual rendered height instead of estimating with lineIndex
            const textHeight = pElement.scrollHeight;
            // or: const textHeight = pElement.getBoundingClientRect().height;

            doneButton.answerHeight = textHeight + 22; // small gap
            doneButton.y = pTop + doneButton.answerHeight;

            doneButton.offsetX = doneButton.x - parentLeft;
            doneButton.offsetY = doneButton.y - parentTop;
            doneButton.style.left = `${doneButton.x}px`; // Position to the right of the textbox
            doneButton.style.top = `${doneButton.y}px`;

            inputParent.doneButton = doneButton;
            console.log(doneButton.style.left);
            console.log(doneButton.style.top);

            if (tabHeadersActivated[1]) appendToCraftCanvas(doneButton);
            if (tabHeadersActivated[4]) appendToChatCanvas(doneButton);

            doneButton.onclick = async function () {
              if (passed && !manualFailed) {
                clearInterval(activeTabInterval);

                tabHeaders[2].classList.add('tab-active');

                activeTabInterval = setInterval(() => {
                  tabHeaders[2].classList.toggle('tab-active');
                }, 1000); // Adjust timing as needed (1s cycle: 0.5s fade in, 0.5s fade out)

                const pattern = snapshotSelectionAsPattern(currentGraph, selectedSymbols);
                let id = await synthNode(
                  selectedSymbols,
                  word,
                  justification,
                  foundIds,
                  elimBasic,
                  pattern,
                );
                library.set(word, [id, pattern]);
                console.log('library');
                console.log(library);
              }
              if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
              }
            };
          }

          type(showDoneButton);
        }
      }

      function startLongPress(left, top, width, height, symbol = null, node = null) {
        longPressStartedAt = performance.now();
        longPressFired = false;

        ring = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        // Append the circle to the SVG
        ring.appendChild(circle);
        if (tabHeadersActivated[1]) appendToCraftCanvas(ring);
        if (tabHeadersActivated[4]) appendToChatCanvas(ring);

        const symbolCenterX = left + width / 2;
        const symbolCenterY = top + height / 2;

        // Create the SVG element with the desired attributes

        ring.style.left = symbolCenterX - 25;
        ring.style.top = symbolCenterY - 25;
        ring.setAttribute('class', 'progress-ring');
        ring.setAttribute('width', '50');
        ring.setAttribute('height', '50');
        ring.setAttribute('viewBox', `${symbolCenterX - 27} ${symbolCenterY - 27} 54 54`);

        // Create the circle element

        circle.setAttribute('cx', symbolCenterX.toString());
        circle.setAttribute('cy', symbolCenterY.toString());

        if (symbol === null) {
          circle.setAttribute('r', width.toString());
        } else {
          circle.setAttribute('r', '25');
        }
        circle.setAttribute('stroke-width', '5');

        ring.style.visibility = 'visible';

        circle.style.stroke = '#00B0F0';
        progress = 0;
        circle.style.strokeDashoffset = 157; // Reset
        interval = setInterval(() => {
          progress += 1;
          const offset = 157 * (1 - progress / totalSteps); // More precise calculation
          circle.style.strokeDashoffset = offset;

          if (progress >= totalSteps) {
            clearInterval(interval);
            longPressFired = true;
            if (symbol === null) {
              triggerLongPressNode(node);
            } else {
              triggerLongPress(symbol);
            }
          }
        }, 10);
      }

      function endLongPress(force = false) {
        if (!force && performance.now() - longPressStartedAt < 80) return;

        if (ring !== null && circle !== null) {
          clearInterval(interval);
          ring.style.visibility = 'hidden';
          circle.style.strokeDashoffset = 157;
          circle.style.stroke = 'transparent';
          ring = null;
          circle = null;
        }
      }

      function triggerLongPress(symbol, representatives = null) {
        if (circle !== null) {
          circle.style.stroke = '#FFC000';
        }
        moleculeString = '';

        clearAllSymbolSelection();
        dragGroup = null;
        dragLeader = null;

        let results = getMolecule(symbol, new Set([]), (representatives = representatives));
        selectedSymbols.clear();
        results.visited.forEach((s) => selectedSymbols.add(s));
        if (results.leftStr !== '') moleculeString += results.leftStr + ' - ';
        moleculeString += results.centerStrs.join(' & ');
        if (results.rightStr !== '') moleculeString += ' - ' + results.rightStr;
        console.log(
          `resultssss left ${results.leftStr} center ${results.centerStrs} right ${results.rightStr}`,
        );

        selectedSymbols.forEach((selectedSymbol) => {
          selectedSymbol.selected = true;
          selectedSymbol.classList.add('framed');
        });
        console.log(`molecule ${moleculeString}`);
      }

      const Side = {
        START: 0, // start
        END: 1, // end
        MID_TOP: 2, // top / left middle
        MID_BOT: 3, // bottom / right middle
        PAR_TOP: 4, // top parallel
        PAR_BOT: 5, // bottom parallel
      };

      const SINGLE_OCCUPANCY = new Set([Side.MID_TOP, Side.MID_BOT, Side.PAR_TOP, Side.PAR_BOT]);

      const MULTI_OCCUPANCY = new Set([Side.START, Side.END]);

      // Create a new copy of the symbol being clicked
      async function createSymbolCopy(
        mouseX,
        mouseY,
        elemId = null,
        elemIdTrue = null,
        symbolX = null,
        symbolY = null,
        symbolColor = null,
        symbolAngle = null,
        symbolId = null,
      ) {
        const { x, y } = clientToLocal(craftCanvas(), mouseX, mouseY);
        let offsetX = (symbolWidth * symbolScale) / 2;
        let offsetY = (symbolHeight * symbolScale) / 2;

        // Create the copy
        const symbol = document.createElement('div');
        symbol.ondragstart = (e) => e.preventDefault();
        symbol.selected = false;
        symbol.moving = false;
        symbol.angle = symbolAngle ? symbolAngle : 0;
        symbol.isDynamic = false;
        symbol.classList.add('symbol');
        symbol.elemId = elemId;

        elemIdTrue = elemIdTrue ? elemIdTrue : elemId;
        symbol.elemIdTrue = elemIdTrue;
        symbol.innerHTML = symbolData[symbol.elemId];

        if (symbolX === null) symbol.accId = acc; // newly created

        if (symbolX !== null) {
          symbol.style.left = `${symbolX}px`;
          symbol.style.top = `${symbolY}px`;
        } else {
          symbol.style.left = `${x - offsetX}px`;
          symbol.style.top = `${y - offsetY}px`;
        }
        if (symbolColor !== null) {
          // loaded in the chat interface
          dyeColor(symbol, symbolColor);
        } else if (tabHeadersActivated[4]) {
          // newly created in the chat interface
          symbolColor = await assignUserColor();
          dyeColor(symbol, symbolColor);
        } // otherwise, newly created in the craft interface

        if (symbolAngle !== null) {
          symbol.style.transform = `rotate(${symbolAngle}deg)`;
        }
        symbol.dot = null;

        // Add pressing event listener to the symbol
        symbol.addEventListener('mousedown', (e) => {
          const totalSelected = selectedSymbols.size + selectedEmojis.size;
          const inSelection = selectedSymbols.has(symbol);
          const wantsGroupDrag = inSelection && totalSelected > 1;

          // record click-vs-drag
          symbol._downClientX = e.clientX;
          symbol._downClientY = e.clientY;
          symbol._dragged = false;
          symbol._downWasSelected = selectedSymbols.has(symbol);
          symbol._downWasInMulti = wantsGroupDrag; // remember state at down time
          symbol._downTotalSelected = selectedSymbols.size + selectedEmojis.size;

          // UI off
          if (eyeButton.isActivated) {
            eyeButton.isActivated = false;
            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
          if (eyeButton2.isActivated) {
            eyeButton2.isActivated = false;
            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }

          // âœ… Selection on mousedown:
          // If it was not selected, make it the only selection (single-select).
          // If it was already selected, keep selection as-is for now (toggle happens on mouseup if no drag).
          if (!inSelection) {
            clearAllSymbolSelection();
            clearAllEmojiSelection();
            symbol.selected = true;
            symbol.classList.add('framed');
            selectedSymbols.add(symbol);
          }

          // long press ok
          startLongPress(
            parseFloat(symbol.style.left),
            parseFloat(symbol.style.top),
            symbolWidth * symbolScale,
            symbolHeight * symbolScale,
            symbol,
          );

          // owner-only drag
          if (!canEditElement(symbol)) {
            symbol.style.cursor = 'not-allowed';
            // allow click-to-toggle selection for others
            clickOnlySymbol = symbol;
            return; // no dragging
          }

          symbol.style.cursor = 'grabbing';
          symbol.moving = false;

          const canvas = getCanvasForElem(symbol);
          const { x: localX, y: localY } = clientToLocal(canvas, e.clientX, e.clientY);

          if (wantsGroupDrag) {
            dragLeader = symbol;
            dragGroup = new Map();

            setDragSnapLock(null, 'start drag');
            pendingSnapDelta = null;
            readyActive = readyTarget = null;
            readyActiveSide = readyTargetSide = null;
            dragGroupStarted = false;
            dragGroupSet = null;

            const groupSet = buildDragGroupSet(dragLeader);
            for (const el of groupSet) {
              if (!canEditElement(el)) continue; // can't drag others' items

              const left = parseFloat(el.style.left) || 0;
              const top = parseFloat(el.style.top) || 0;
              const dx = left - localX;
              const dy = top - localY;

              dragGroup.set(el, { dx, dy, dx0: dx, dy0: dy });
            }

            activeSymbol = symbol; // leader remains active
          } else {
            dragLeader = null;
            dragGroup = null;

            activeSymbol = symbol;
            const left = parseFloat(symbol.style.left) || 0;
            const top = parseFloat(symbol.style.top) || 0;
            symbol.offsetX = localX - left;
            symbol.offsetY = localY - top;
          }
        });

        /* if horizontal: left, right, top perpendicular, bottom perpendicular, top parallel, bottom parallel */
        /* if vertical: top, down, left perpendicular, right perpendicular, left parallel, right parallel */
        currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

        if (tabHeadersActivated[1]) appendToCraftCanvas(symbol);
        if (tabHeadersActivated[4] || symbolX !== null) appendToChatCanvas(symbol);

        if (selectedSymbols.size !== 0) {
          selectedSymbols.forEach((selectedSymbol) => {
            selectedSymbol.selected = false;
            selectedSymbol.classList.remove('framed');
            selectedSymbols.delete(selectedSymbol);
          });
          if (eyeButton.isActivated) {
            eyeButton.isActivated = false;
            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
          if (eyeButton2.isActivated) {
            eyeButton2.isActivated = false;
            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
            removeLabelInputs();
          }
        }
        if (symbolX === null) {
          activeSymbol = symbol;
        }
        symbol.offsetX = offsetX;
        symbol.offsetY = offsetY;

        if (tabHeadersActivated[4] || symbolX !== null) {
          // Get div attributes
          const symbolPacket = {
            elemId: elemId,
            elemIdTrue: elemIdTrue,
            color: symbolColor,
            angle: 0,
            dotX: null,
            dotY: null,
          };

          if (symbolId !== null) {
            symbol.dataset.id = symbolId;
          } else {
            // after you created the DOM element `symbol`
            symbol.dataset.id = ''; // not ready yet
            symbol._pendingIdPromise = (async () => {
              const docId = await saveObj(
                'symbol',
                symbolPacket,
                parseFloat(symbol.style.left),
                parseFloat(symbol.style.top),
              );
              symbol.dataset.id = docId;
              return docId;
            })();
          }
        }

        return symbol;
      }

      // Find all the symbols that are connected to one symbol
      function getMolecule(currentSymbol, visited, representatives = null) {
        visited.add(currentSymbol);

        console.log(`visit`);
        console.log(visited);
        console.log(currentSymbol);
        let leftStr = '';
        let centerStrs = [getMoleculeChar(currentSymbol)];
        console.log(`representatives`);
        console.log(representatives);
        if (representatives != null && representatives.has(currentSymbol)) {
          centerStrs.push(representatives.get(currentSymbol));
        }

        let rightStr = '';
        for (let i = 0; i < currentGraph.getSymbolConnections(currentSymbol).length; i++) {
          // every magnet point
          for (const entry of currentGraph.getSymbolConnections(currentSymbol)[i]) {
            // entry = [every other symbol connected to my magnet point, its magnet point]
            if (!visited.has(entry[0])) {
              let results = getMolecule(entry[0], visited, (representatives = representatives));
              visited = results.visited;
              console.log(`entry[0] ${entry[0].elemId} entry[1] ${entry[1]}`);
              if (entry[1] > 1 || i > 1) {
                if (leftStr !== '' && results.leftStr !== '') {
                  leftStr = '(' + leftStr + ') & (' + results.leftStr + ')';
                } else if (leftStr == '') {
                  leftStr = results.leftStr;
                }
                centerStrs.push(...results.centerStrs);
                if (rightStr !== '' && results.rightStr !== '') {
                  rightStr = '(' + rightStr + ') & (' + results.rightStr + ')';
                } else if (rightStr == '') {
                  rightStr = results.rightStr;
                }
                console.log(
                  `me ${currentSymbol.elemId} entry[0] ${entry[0].elemId} centerStrs ${centerStrs.join(' & ')}`,
                );
              } else {
                if (i === 0) {
                  if (results.leftStr !== '') leftStr += results.leftStr + ' - ';
                  leftStr += results.centerStrs.join(' & ');
                  if (results.rightStr !== '') leftStr += ' - ' + results.rightStr;
                  console.log(
                    `me ${currentSymbol.elemId} left entry[0] ${leftStr} centerStrs ${centerStrs.join(' & ')}`,
                  );
                } else if (i === 1) {
                  if (results.leftStr !== '') rightStr += results.leftStr + ' - ';
                  rightStr += results.centerStrs.join(' & ');
                  if (results.rightStr !== '') rightStr += ' - ' + results.rightStr;
                  console.log(
                    `me ${currentSymbol.elemId} right entry[0] ${rightStr} centerStrs ${centerStrs.join(' & ')}`,
                  );
                }
              }
            }
          }
        }
        console.log(`me ${currentSymbol.elemId}`);
        console.log(`left ${leftStr} center ${centerStrs.join(' & ')} right ${rightStr}`);
        console.log(`visited ${visited.size}`);
        return { visited: visited, leftStr: leftStr, centerStrs: centerStrs, rightStr: rightStr };
      }

      function getMoleculeChar(symbol) {
        const table = [
          'Ä¡',
          'Ä‹',
          'g',
          'c',
          'r',
          'l',
          'v',
          'f',
          'd',
          't',
          'b',
          'p',
          's',
          'z',
          'á¹¡',
          'Å¼',
          'n',
          'm',
        ];
        let char = table[symbol.elemIdTrue * 2 + Number(symbol.isDynamic)];
        if (
          char === 'g' ||
          char === 'c' ||
          char === 'v' ||
          char === 'd' ||
          char === 't' ||
          char === 's'
        ) {
          if (symbol.angle === 0 || symbol.angle === 180) {
            char += ' horizontal';
          } else {
            char += ' vertical';
          }
        }
        return char;
      }

      // Check for snapping connections
      function checkConnections(active) {
        let targetX;
        let targetY;
        readyActive = null;
        readyTarget = null;
        readyActiveSide = null;
        readyTargetSide = null;
        for (const target of currentGraph.getSymbols()) {
          // Skip the active symbol itself
          if (target === active) continue;
          // During group drag, ignore targets inside the dragged group
          if (groupDragActive && dragGroupSet && dragGroupSet.has(target)) continue;

          const activeJunctions = getAbsJunctions(active);
          const targetJunctions = getAbsJunctions(target);

          targetJunctions.forEach((targetCoord, index) => {
            switch (index) {
              case 0: // connected at the left / top start
                if (getDir(active) === getDir(target)) {
                  // active right >=< target left
                  snapToSymbol(
                    active,
                    target,
                    activeJunctions[1].x,
                    activeJunctions[1].y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.END,
                    Side.START,
                  );
                } else {
                  const [first, second, , fourth] = activeJunctions; // valid coordinates for connecting
                  snapToSymbol(
                    active,
                    target,
                    first.x,
                    first.y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.START,
                    Side.START,
                    'å§‹',
                  );
                  if (getDir(active) === 0) {
                    // target
                    snapToSymbol(
                      active,
                      target,
                      second.x,
                      second.y,
                      targetCoord.x,
                      targetCoord.y,
                      Side.END,
                      Side.START,
                      'å§‹',
                    );
                  } else {
                    snapToSymbol(
                      active,
                      target,
                      second.x,
                      second.y,
                      targetCoord.x,
                      targetCoord.y + calY,
                      Side.END,
                      Side.START,
                      'heihei',
                    );
                  }
                  snapToSymbol(
                    active,
                    target,
                    fourth.x,
                    fourth.y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.MID_BOT,
                    Side.START,
                    'å§‹',
                  );
                }
                break;
              case 1: // connected at the right / bottom end
                if (getDir(active) === getDir(target)) {
                  snapToSymbol(
                    active,
                    target,
                    activeJunctions[0].x,
                    activeJunctions[0].y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.START,
                    Side.END,
                    'snap to the right',
                  );
                } else {
                  const [first, second, third] = activeJunctions.slice(0, 3); // valid coordinates for connecting
                  if (getDir(active) === 1) {
                    snapToSymbol(
                      active,
                      target,
                      first.x,
                      first.y,
                      targetCoord.x,
                      targetCoord.y,
                      Side.START,
                      Side.END,
                      'æœ«',
                    );
                  } else {
                    snapToSymbol(
                      active,
                      target,
                      first.x,
                      first.y,
                      targetCoord.x,
                      targetCoord.y - calY,
                      Side.START,
                      Side.END,
                      'meimei',
                    );
                  }
                  snapToSymbol(
                    active,
                    target,
                    second.x,
                    second.y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.END,
                    Side.END,
                    'æœ«',
                  );
                  snapToSymbol(
                    active,
                    target,
                    third.x,
                    third.y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.MID_TOP,
                    Side.END,
                    'æœ«',
                  );
                }
                break;
              case 2: // perpendicular: inserted at the top / left middle
                if (getDir(active) !== getDir(target)) {
                  if (getDir(active) === 0) {
                    // horizontal active inserted on vertical target ä¸Š
                    snapToSymbol(
                      active,
                      target,
                      activeJunctions[1].x,
                      activeJunctions[1].y,
                      targetCoord.x,
                      targetCoord.y,
                      Side.END,
                      Side.MID_TOP,
                      'åœ',
                    );
                  } else {
                    snapToSymbol(
                      active,
                      target,
                      activeJunctions[1].x,
                      activeJunctions[1].y,
                      targetCoord.x,
                      targetCoord.y,
                      Side.END,
                      Side.MID_TOP,
                      'ä¸Š',
                    );
                  }
                }
                break;
              case 3: // perpendicular: inserted at bottom / right middle ä¸‹
                if (getDir(active) !== getDir(target)) {
                  snapToSymbol(
                    active,
                    target,
                    activeJunctions[0].x,
                    activeJunctions[0].y,
                    targetCoord.x,
                    targetCoord.y,
                    Side.START,
                    Side.MID_BOT,
                    'ä¸‹',
                  );
                }
                break;
            }
          });

          if (getDir(active) === getDir(target)) {
            // parallel
            if (getDir(active) === 0) {
              targetX = parseFloat(target.style.left);
              targetY = parseFloat(target.style.top) - (symbolHeight - 7) * symbolScale;
              if (currentGraph.getSymbolConnections(target)[Side.PAR_TOP].length === 0) {
                snapToSymbol(
                  active,
                  target,
                  parseFloat(active.style.left),
                  parseFloat(active.style.top),
                  targetX,
                  targetY,
                  Side.PAR_BOT,
                  Side.PAR_TOP,
                );
              }
              targetY = parseFloat(target.style.top) + (symbolHeight - 4) * symbolScale;
              if (currentGraph.getSymbolConnections(target)[Side.PAR_BOT].length === 0) {
                snapToSymbol(
                  active,
                  target,
                  parseFloat(active.style.left),
                  parseFloat(active.style.top),
                  targetX,
                  targetY,
                  Side.PAR_TOP,
                  Side.PAR_BOT,
                );
              }
            }
            if (getDir(active) === 1) {
              targetX = parseFloat(target.style.left) - (symbolHeight - 7) * symbolScale;
              targetY = parseFloat(target.style.top);
              if (currentGraph.getSymbolConnections(target)[Side.PAR_TOP].length === 0) {
                snapToSymbol(
                  active,
                  target,
                  parseFloat(active.style.left),
                  parseFloat(active.style.top),
                  targetX,
                  targetY,
                  Side.PAR_BOT,
                  Side.PAR_TOP,
                );
              }
              targetX = parseFloat(target.style.left) + (symbolHeight - 4) * symbolScale;
              if (currentGraph.getSymbolConnections(target)[Side.PAR_BOT].length === 0) {
                snapToSymbol(
                  active,
                  target,
                  parseFloat(active.style.left),
                  parseFloat(active.style.top),
                  targetX,
                  targetY,
                  Side.PAR_TOP,
                  Side.PAR_BOT,
                );
              }
            }
          }
        }
      }

      // Get the offset for the symbol when connected to another symbol (side 0 = left, 1 = right)
      function getRelJunctions(symbol) {
        let junctions; // [start, end, middle_1, middle_2]
        switch (symbol.elemId) {
          case 0:
            junctions = [
              { x: 1, y: 13 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 13 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
          case 1:
            junctions = [
              { x: 1, y: 49 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 50 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
          case 2:
            junctions = [
              { x: 1, y: 49 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 14 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
          case 3:
            junctions = [
              { x: 1, y: 57 },
              { x: symbolWidth - calX, y: 57 },
              { x: symbolWidth / 2, y: 56 },
              { x: symbolWidth / 2, y: 64 },
            ];
            break;
          case 4:
            junctions = [
              { x: 1, y: 49 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 50 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
          case 5:
            junctions = [
              { x: 1, y: 49 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 50 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
          case 6:
            junctions = [
              { x: 1, y: 57 },
              { x: symbolWidth - calX, y: 57 },
              { x: symbolWidth / 2, y: 56 },
              { x: symbolWidth / 2, y: 64 },
            ];
            break;
          case 7:
            junctions = [
              { x: 1, y: 32 },
              { x: symbolWidth - calX, y: 32 },
              { x: symbolWidth / 2, y: 3 },
              { x: symbolWidth / 2, y: 64 },
            ];
            break;
          case 8:
            junctions = [
              { x: 1, y: 49 },
              { x: symbolWidth - calX, y: 49 },
              { x: symbolWidth / 2, y: 13 },
              { x: symbolWidth / 2, y: 56 },
            ];
            break;
        }
        return junctions;
      }

      function getAbsJunctions(symbol) {
        const relJunctions = getRelJunctions(symbol);
        const rect = symbol.getBoundingClientRect();
        let absJunctions;
        if (symbol.angle === 0) {
          absJunctions = [
            {
              x: rect.left + relJunctions[0].x * symbolScale,
              y: rect.top + relJunctions[0].y * symbolScale,
            },
            {
              x: rect.left + relJunctions[1].x * symbolScale,
              y: rect.top + relJunctions[1].y * symbolScale,
            },
            {
              x: rect.left + relJunctions[2].x * symbolScale,
              y: rect.top + relJunctions[2].y * symbolScale,
            },
            {
              x: rect.left + relJunctions[3].x * symbolScale,
              y: rect.top + relJunctions[3].y * symbolScale,
            },
          ];
        }
        if (symbol.angle === 180) {
          absJunctions = [
            {
              x: rect.right - relJunctions[1].x * symbolScale,
              y: rect.bottom - relJunctions[1].y * symbolScale - calInvY,
            },
            {
              x: rect.right - relJunctions[0].x * symbolScale,
              y: rect.bottom - relJunctions[0].y * symbolScale - calInvY,
            },
            {
              x: rect.right - relJunctions[3].x * symbolScale,
              y: rect.bottom - relJunctions[3].y * symbolScale,
            },
            {
              x: rect.right - relJunctions[2].x * symbolScale,
              y: rect.bottom - relJunctions[2].y * symbolScale,
            },
          ];
        }
        if (symbol.angle === 90) {
          absJunctions = [
            {
              x: rect.right - relJunctions[0].y * symbolScale,
              y: rect.top + relJunctions[0].x * symbolScale,
            },
            {
              x: rect.right - relJunctions[1].y * symbolScale,
              y: rect.top + relJunctions[1].x * symbolScale,
            },
            {
              x: rect.right - relJunctions[3].y * symbolScale,
              y: rect.top + relJunctions[3].x * symbolScale,
            },
            {
              x: rect.right - relJunctions[2].y * symbolScale,
              y: rect.top + relJunctions[2].x * symbolScale,
            },
          ];
        }
        if (symbol.angle === 270) {
          absJunctions = [
            {
              x: rect.left + relJunctions[1].y * symbolScale + calInvY,
              y: rect.bottom - relJunctions[1].x * symbolScale,
            },
            {
              x: rect.left + relJunctions[0].y * symbolScale + calInvY,
              y: rect.bottom - relJunctions[0].x * symbolScale,
            },
            {
              x: rect.left + relJunctions[2].y * symbolScale,
              y: rect.bottom - relJunctions[2].x * symbolScale,
            },
            {
              x: rect.left + relJunctions[3].y * symbolScale,
              y: rect.bottom - relJunctions[3].x * symbolScale,
            },
          ];
        }
        if (symbol.elemId === 2) {
          if (symbol.angle === 0) {
            absJunctions[2].x += calCan1;
            absJunctions[3].x += calCan1;
          }
          if (symbol.angle === 270) {
            absJunctions[2].y -= calCan1;
            absJunctions[3].y -= calCan1;
          }
          if (symbol.angle === 90) {
            absJunctions[2].y -= calCan2;
            absJunctions[3].y -= calCan2;
          }
          if (symbol.angle === 180) {
            absJunctions[2].x += calCan2;
            absJunctions[3].x += calCan2;
          }
        }

        return absJunctions;
      }

      function getDist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }

      function getDir(symbol) {
        if (symbol.angle === 0 || symbol.angle === 180) {
          return 0; // horizontal
        }
        if (symbol.angle === 90 || symbol.angle === 270) {
          return 1; // vertical
        }
      }

      // Side conflict rules: prevent ugly overlaps (parallel vs mid insert)
      const SIDE_CONFLICTS = new Map([
        [Side.MID_TOP, [Side.PAR_TOP]],
        [Side.MID_BOT, [Side.PAR_BOT]],
        [Side.PAR_TOP, [Side.MID_TOP]],
        [Side.PAR_BOT, [Side.MID_BOT]],
      ]);

      // Snap active symbol to target
      function snapToSymbol(
        active,
        target,
        activeX,
        activeY,
        targetX,
        targetY,
        activeSide,
        targetSide,
        msg = '',
      ) {
        if (groupDragActive && dragGroupSet && dragGroupSet.has(target)) return;

        const tConns = currentGraph.getSymbolConnections(target)?.[targetSide] || [];

        // Treat "occupied" as: not myself AND not in my current drag group
        const isOther = (nbr) => nbr !== active && !(dragGroupSet && dragGroupSet.has(nbr));

        // ---- 1) Occupancy rules ----
        if (SINGLE_OCCUPANCY.has(targetSide)) {
          // Sides 2/3/4/5: only one occupant allowed (ignore self + group)
          if (tConns.some(([nbr]) => isOther(nbr))) return;
        } else {
          // Sides 0/1: multi-occupancy allowed, but prevent "overlap"
          for (const [nbr, nbrSide] of tConns) {
            if (!isOther(nbr)) continue; // ignore self + group members
            if (getDir(nbr) === getDir(active) && nbrSide === activeSide) return;
          }
        }

        // ---- 1.5) Visual overlap conflicts: block snap early (mousemove stage) ----
        // If the target side would conflict with existing attachments on the target, don't even snap.
        if (violatesConflicts(target, targetSide)) return;

        // (Optional) Also block if active side conflicts with existing attachments on active itself.
        // This prevents snapping into crowded areas on the moving symbol.
        if (violatesConflicts(active, activeSide)) return;

        // ---- 2) Distance check ----
        if (getDist(activeX, activeY, targetX, targetY) >= SNAP_DISTANCE) return;

        const oldX = parseFloat(active.style.left) || 0;
        const oldY = parseFloat(active.style.top) || 0;

        const dx = targetX - activeX;
        const dy = targetY - activeY;

        // Record candidate connection (mouse up will finalize)
        readyActive = active;
        readyTarget = target;
        readyActiveSide = activeSide;
        readyTargetSide = targetSide;

        // ---- 3) Group drag: request a delta for the whole group ----
        if (groupDragActive) {
          pendingSnapDelta = { dx, dy };
          return;
        }

        // ---- 4) Single drag: move immediately ----
        active.style.left = `${oldX + dx}px`;
        active.style.top = `${oldY + dy}px`;
      }

      // Add an event listener for clicks on the document
      document.addEventListener('click', (event) => {
        // Get the mouse coordinates
        const x = event.clientX; // X-coordinate relative to the viewport
        const y = event.clientY; // Y-coordinate relative to the viewport

        // Print the coordinates to the console
        console.log(`Mouse clicked at: X = ${x}, Y = ${y}`);
        console.log(currentGraph);
      });

      /* Library */
      let nodes = new vis.DataSet([]);
      let edges = new vis.DataSet([]);
      let network;
      let nodeTextBoxes = {};
      let container = document.getElementById('network');
      let data = { nodes: nodes, edges: edges };
      let basicNodeIds = new Set();
      let options = {
        nodes: {
          shape: 'circularImage',
          borderWidth: 3,
          color: {
            border: 'black',
            background: 'white',
            highlight: {
              border: 'black',
              background: '#f0f0f0', // Light gray on hover
            },
            hover: {
              border: 'black',
              background: '#e0e0e0', // Slightly darker gray on hover
            },
          },
          shapeProperties: { useBorderWithImage: true },
          size: 20,
        },
        edges: {
          smooth: false,
        },
        physics: {
          enabled: true,
          solver: 'barnesHut', // é»˜è®¤å°±æ˜¯å®ƒ
          barnesHut: {
            gravitationalConstant: -500, // æ•°å€¼è¶Šâ€œè´Ÿâ€(ç»å¯¹å€¼è¶Šå¤§) -> æ’æ–¥è¶Šå¼ºï¼›æŠŠç»å¯¹å€¼è°ƒå°ä¼šæ›´â€œæŒ¤â€
            springLength: 100, // è¾¹çš„ç†æƒ³é•¿åº¦ï¼›å°ä¸€ç‚¹ä¼šæ›´ç´§å‡‘
            springConstant: 0.02, // å¼¹ç°§å¼ºåº¦ï¼›å°ä¸€ç‚¹æ•´ä½“æ›´æ¾
            damping: 1, // é˜»å°¼ï¼›å¤§ä¸€ç‚¹æ›´å¿«åœã€æ›´ä¸æŠ–
            avoidOverlap: 0, // éœ€è¦é¿å…é‡å å¯è°ƒåˆ° 0.2~1
          },
          stabilization: {
            enabled: true,
            iterations: 600,
          },
        },
      };

      async function initNodes() {
        for (let i = 0; i < symbolData.length; i++) {
          const svgString = symbolData[i];
          const id = await generateUniqueId(svgString);
          nodes.add({
            id,
            shape: 'circularImage',
            image: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(scaleSVG(svgString)),
            word: '',
            title: tSymbolTitle(i),
            _baseIndex: i,
          });
          basicNodeIds.add(id);
        }

        network = new vis.Network(container, data, options);

        await loadLibraryGraphForUser();
        rebuildLibraryFromNodes();

        network.once('afterDrawing', function () {
          // Assuming 'container' is the DOM element where the network is rendered
          let containerWidth = container.offsetWidth;
          let containerHeight = container.offsetHeight;
          let scale = 1.5;
          console.log(containerWidth, containerHeight);
          network.moveTo({
            offset: {
              x: 0.5 * containerWidth * scale,
              y: 0.5 * containerHeight * scale,
            },
            scale: scale,
          });
        });
        network.on('dragEnd', () => scheduleSaveLibraryGraph());
      }

      function exportGraphState() {
        // nodes.get() returns fields in the dataset (x/y may be absent)
        const allNodes = nodes.get();
        const allEdges = edges.get();

        // Get current positions (if network not ready, skip)
        const pos = network ? network.getPositions(allNodes.map((n) => n.id)) : {};

        const exportNodes = allNodes.map((n) => ({
          id: n.id,
          word: n.word || '',
          title: n.title || '',
          svg: n._svg || null,
          x: pos[n.id]?.x ?? null,
          y: pos[n.id]?.y ?? null,
          pattern: n.pattern ? serializePatternGraph(n.pattern) : null,
        }));

        const exportEdges = allEdges.map((e) => ({
          id: e.id || `${e.from}->${e.to}`,
          from: e.from,
          to: e.to,
        }));

        return { nodes: exportNodes, edges: exportEdges };
      }

      async function saveLibraryGraphForUser() {
        if (!currentUser) return;

        const ref = doc(db, 'users', currentUser.uid, 'libraryGraph', 'state');
        const state = exportGraphState();

        await setDoc(
          ref,
          {
            nodes: state.nodes,
            edges: state.edges,
            updatedAt: serverTimestamp(),
          },
          { merge: true },
        );
      }

      async function loadLibraryGraphForUser() {
        if (!currentUser) return;

        const ref = doc(db, 'users', currentUser.uid, 'libraryGraph', 'state');
        const snap = await getDoc(ref);
        if (!snap.exists()) return;

        const { nodes: savedNodes = [], edges: savedEdges = [], view = null } = snap.data();

        // 1) add nodes if absent in dataset, otherwise update word/title/pos
        for (const sn of savedNodes) {
          // If the node already exists in the dataset, update it; otherwise add it.
          const exists = nodes.get(sn.id);

          // Deserialize pattern safely (supports old records without pattern)
          const parsedPattern = sn.pattern ? deserializePatternGraph(sn.pattern) : null;

          if (!exists) {
            // Synthesized nodes need svg to rebuild the image
            if (!sn.svg) continue;

            // Better debug (do not stringify via '+')
            console.warn('[load node]', {
              id: sn.id,
              word: sn.word,
              hasPattern: !!sn.pattern,
              parsedPattern,
            });

            nodes.add({
              id: sn.id,
              shape: 'circularImage',
              image: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(scaleSVG(sn.svg)),
              word: sn.word || '',
              title: sn.title || '',
              x: sn.x ?? undefined,
              y: sn.y ?? undefined,
              _svg: sn.svg,
              pattern: parsedPattern, // PatternGraph instance or null
            });
          } else {
            nodes.update({
              id: sn.id,
              word: sn.word || exists.word || '',
              title: sn.title || exists.title || '',
              ...(sn.x != null && sn.y != null ? { x: sn.x, y: sn.y } : {}),
              ...(sn.svg ? { _svg: sn.svg } : {}),
              // only overwrite pattern if saved data actually has one
              ...(sn.pattern !== undefined ? { pattern: parsedPattern } : {}),
            });
          }
        }

        // 2) add edges
        for (const se of savedEdges) {
          // avoid repeating edges
          const already = edges.get(se.id);
          if (already) continue;

          edges.add({
            id: se.id || `${se.from}__${se.to}`, // generate one if absent
            from: se.from,
            to: se.to,
            arrows: { to: { enabled: true } },
            color: { color: 'black' },
          });
        }
      }

      function rebuildLibraryFromNodes() {
        library.clear();

        for (const n of nodes.get()) {
          if (!n.word) continue;
          if (!n.pattern) continue; // basic nodes may not have pattern

          library.set(n.word, [n.id, n.pattern]); // n.pattern is PatternGraph (deserialized)
        }
      }

      async function deleteLibraryNodeForUser(uid, nodeId) {
        const ref = doc(db, 'users', uid, 'libraryNodes', nodeId);
        await deleteDoc(ref);
      }

      async function deleteLibraryEdgeForUser(uid, edgeId) {
        const ref = doc(db, 'users', uid, 'libraryEdges', edgeId);
        await deleteDoc(ref);
      }

      function capitalizeFirstLetter(val) {
        return String(val).charAt(0).toUpperCase() + String(val).slice(1);
      }

      function scaleSVG(svgString, targetSize = 40) {
        // Parse SVG string
        let parser = new DOMParser();
        let doc = parser.parseFromString(svgString, 'image/svg+xml');
        let svg = doc.documentElement;

        let viewBox = svg.getAttribute('viewBox');
        let width = parseFloat(svg.getAttribute('width'));
        let height = parseFloat(svg.getAttribute('height'));

        if (viewBox) {
          let [x, y, w, h] = viewBox.split(' ').map(parseFloat);
          width = w;
          height = h;
        }

        if (!width || !height) return svgString; // Fallback: return original SVG

        // Calculate scale factor
        let scale = (targetSize * 0.6) / Math.max(width, height);

        // Calculate translation to center the scaled content
        let translateX = (targetSize - width * scale) / 2;
        let translateY = (targetSize - height * scale) / 2;

        // Apply transform
        let transform = `translate(${translateX}, ${translateY}) scale(${scale})`;

        // Wrap everything inside a group <g> element to apply transformations
        let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('transform', transform);
        while (svg.firstChild) {
          group.appendChild(svg.firstChild);
        }
        svg.innerHTML = ''; // Clear original SVG
        svg.appendChild(group);

        // Set viewBox to match the target circle size
        svg.setAttribute('width', targetSize);
        svg.setAttribute('height', targetSize);
        svg.setAttribute('viewBox', `0 0 ${targetSize} ${targetSize}`);

        return new XMLSerializer().serializeToString(svg);
      }

      // Synthesize a node from its components and connect the component nodes to the synthesized node
      async function synthNode(components, word, justification, foundIds, elimBasic, pattern) {
        let leftMost = 2 * document.documentElement.scrollWidth;
        let rightMost = -document.documentElement.scrollWidth;
        let topMost = 2 * document.documentElement.scrollHeight;
        let bottomMost = -document.documentElement.scrollHeight;
        let rect;
        let svgString = '';
        components.forEach((symbol) => {
          rect = symbol.getBoundingClientRect();
          if (rect.left < leftMost) leftMost = rect.left;
          if (rect.right > rightMost) rightMost = rect.right;
          if (rect.top < topMost) topMost = rect.top;
          if (rect.bottom > bottomMost) bottomMost = rect.bottom;

          if (symbol.dot != null) {
            rect = symbol.dot.getBoundingClientRect();
            if (rect.left < leftMost) leftMost = rect.left;
            if (rect.right > rightMost) rightMost = rect.right;
            if (rect.top < topMost) topMost = rect.top;
            if (rect.bottom > bottomMost) bottomMost = rect.bottom;
          }
        });
        console.log(`left ${leftMost} right ${rightMost} top ${topMost} bottom ${bottomMost}`);
        const ratio = 49.92 / (symbolWidth * symbolScale);

        components.forEach((symbol) => {
          rect = symbol.getBoundingClientRect();
          let transX;
          let transY;
          switch (symbol.angle) {
            case 0:
              transX = rect.left;
              transY = rect.top;
              break;
            case 90:
              transX = rect.right;
              transY = rect.top;
              break;
            case 180:
              transX = rect.right;
              transY = rect.bottom;
              break;
            case 270:
              transX = rect.left;
              transY = rect.bottom;
              break;
          }
          svgString +=
            `<g transform="translate(` +
            ((transX - leftMost) * ratio).toString() +
            `, ` +
            ((transY - topMost) * ratio).toString() +
            `) rotate(` +
            symbol.angle.toString() +
            `)">` +
            symbol.querySelector('svg').innerHTML +
            `</g>\n`;

          if (symbol.dot != null) {
            console.log('added dot!');
            rect = symbol.dot.getBoundingClientRect();
            svgString +=
              `<g transform="translate(` +
              ((rect.left - leftMost) * ratio).toString() +
              `, ` +
              ((rect.top - topMost) * ratio).toString() +
              `)">` +
              dotDataMini +
              `</g>\n`;
          }
        });

        const widthStr = ((rightMost - leftMost) * ratio).toString();
        const heightStr = ((bottomMost - topMost) * ratio).toString();
        svgString =
          `<svg width="` +
          widthStr +
          `" height="` +
          heightStr +
          `" viewBox="0 0 ` +
          widthStr +
          ` ` +
          heightStr +
          `" xmlns="http://www.w3.org/2000/svg">\n` +
          svgString +
          `</svg>`;

        let id = await generateUniqueId(svgString);
        let hasDuplicate = false;
        nodes.forEach((node) => {
          if (node['id'] === id) {
            hasDuplicate = true;
          }
        });

        if (!hasDuplicate) {
          const serializedPattern = serializePatternGraph(pattern);
          let newNode = {
            id: id,
            shape: 'circularImage',
            image: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(scaleSVG(svgString)),
            word: word,
            title: capitalizeFirstLetter(word) + '. ' + capitalizeFirstLetter(justification),
            _svg: svgString,
            pattern: serializedPattern,
          };

          nodes.add(newNode); // Add node to dataset
          for (const symbol of selectedSymbols) {
            if (!elimBasic.has(symbol))
              addEdge(await generateUniqueId(symbolData[symbol.elemIdTrue]), id);
          }
          for (const foundId of foundIds) {
            addEdge(foundId, id);
          }
        }

        scheduleSaveLibraryGraph();
        return id;
      }

      let saveTimer = null;
      function scheduleSaveLibraryGraph() {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          saveLibraryGraphForUser().catch(console.error);
        }, 500);
      }

      function addEdge(sourceId, targetId) {
        // Get all existing edges
        const existingEdges = edges.get();

        // Check if the edge already exists between the two nodes, in either direction
        const edgeExists = existingEdges.some((edge) => {
          return (
            (edge.from === sourceId && edge.to === targetId) ||
            (edge.from === targetId && edge.to === sourceId)
          );
        });

        if (!edgeExists) {
          edges.add({
            from: sourceId,
            to: targetId,
            arrows: { to: { enabled: true } },
            color: { color: 'black' },
          });
          console.log(`link ${sourceId} ${targetId}`);
        }
      }

      async function generateUniqueId(svgString) {
        // Ensure consistent encoding
        const encoder = new TextEncoder();
        const data = encoder.encode(svgString.trim()); // Trim to avoid whitespace inconsistencies

        // Compute SHA-256 hash
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));

        // Convert hash to a base64 string (URL-safe)
        return (
          'svg-' +
          btoa(String.fromCharCode(...hashArray))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '') // Remove padding
            .substring(0, 16)
        ); // Trim for shorter ID
      }

      // immediately fetch regardless of the tab
      fetch('./world.json')
        .then((r) => r.json())
        .then((data) => {
          worldData = data.world;
          console.log('World data loaded');
        });

      function renderWorld() {
        if (worldRendered) return;
        if (!worldData) return; // data has not arrived yet

        const world = document.getElementById('world');
        const content = document.getElementById('worldContent');

        // Now the world is displayed, we can safely measure it
        const W = world.offsetWidth;
        const H = world.offsetHeight;

        worldData.islands.forEach((islandData) => {
          const islandSVG = createIslandSVG(islandData);
          islandSVG.style.left = islandData.x * W + 'px';
          islandSVG.style.top = islandData.y * H + 'px';
          content.appendChild(islandSVG);
        });

        worldRendered = true;
      }

      function createIslandSVG(islandData) {
        const blockSize = 20;
        const radius = 5; // ä½ è¦çš„ 5px åœ†è§’
        const strokeW = 2;
        const highlightExtra = 8;
        const highlightW = strokeW + highlightExtra;

        const maxStroke = Math.max(strokeW, highlightW);
        const pad = maxStroke / 2;

        const blocks = islandData.blocks;
        if (!blocks?.length) return null;

        // ====== 0) å¹³ç§»åˆ°æ­£åŒºé—´ ======
        const minX = Math.min(...blocks.map((b) => b.x));
        const minY = Math.min(...blocks.map((b) => b.y));
        const xs = blocks.map((b) => b.x - minX);
        const ys = blocks.map((b) => b.y - minY);
        const width = Math.max(...xs) + 1;
        const height = Math.max(...ys) + 1;

        // occupancy matrix
        const matrix = Array.from({ length: height }, () => Array(width).fill(false));
        blocks.forEach((b) => (matrix[b.y - minY][b.x - minX] = true));

        // ====== 1) edge cancellationï¼šåªä¿ç•™å¤–è¾¹ç•Œè¾¹ ======
        const edgeMap = new Map();
        const eKey = (x1, y1, x2, y2) => `${x1},${y1}->${x2},${y2}`;
        const eRev = (x1, y1, x2, y2) => `${x2},${y2}->${x1},${y1}`;

        function addEdge(x1, y1, x2, y2) {
          const rk = eRev(x1, y1, x2, y2);
          if (edgeMap.has(rk)) edgeMap.delete(rk);
          else edgeMap.set(eKey(x1, y1, x2, y2), { x1, y1, x2, y2 });
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            if (!matrix[y][x]) continue;
            addEdge(x, y, x + 1, y); // top
            addEdge(x + 1, y, x + 1, y + 1); // right
            addEdge(x + 1, y + 1, x, y + 1); // bottom
            addEdge(x, y + 1, x, y); // left
          }
        }

        const edges = Array.from(edgeMap.values());
        if (!edges.length) return null;

        // ====== 2) Trace closed loops directly from directed boundary edges ======
        // edgeMap currently stores directed outer boundary edges with consistent orientation.
        const parsePoint = (k) => {
          const [x, y] = k.split(',').map(Number);
          return { x, y };
        };

        const startKey = (e) => `${e.x1},${e.y1}`;
        const endKey = (e) => `${e.x2},${e.y2}`;
        const edgeKey = (e) => `${e.x1},${e.y1}->${e.x2},${e.y2}`;

        // Build "outgoing directed edges" index: startPoint -> [edge, edge, ...]
        const outgoing = new Map();
        for (const e of edges) {
          const sk = startKey(e);
          if (!outgoing.has(sk)) outgoing.set(sk, []);
          outgoing.get(sk).push(e);
        }

        // Optional but helpful: stable ordering (prevents random traversal differences)
        for (const arr of outgoing.values()) {
          arr.sort((a, b) => {
            // sort by end point
            if (a.x2 !== b.x2) return a.x2 - b.x2;
            return a.y2 - b.y2;
          });
        }

        const visitedDir = new Set();
        const loops = [];

        for (const e0 of edges) {
          const k0 = edgeKey(e0);
          if (visitedDir.has(k0)) continue;

          const loop = [];
          let cur = e0;

          // start point
          loop.push({ x: cur.x1, y: cur.y1 });

          let guard = 0;
          while (cur && guard++ < 200000) {
            visitedDir.add(edgeKey(cur));

            // append current edge end point
            loop.push({ x: cur.x2, y: cur.y2 });

            const nextStart = `${cur.x2},${cur.y2}`;

            // If we returned to the first point, loop closed
            const first = loop[0];
            if (cur.x2 === first.x && cur.y2 === first.y) break;

            const candidates = outgoing.get(nextStart) || [];

            // choose the first unvisited outgoing edge from this vertex
            // (for orthogonal pixel boundary, this is usually unique)
            let next = null;
            for (const e of candidates) {
              if (!visitedDir.has(edgeKey(e))) {
                next = e;
                break;
              }
            }

            // Fallback: if all are visited but not closed, data/traversal issue
            if (!next) break;

            cur = next;
          }

          // accept only closed loops
          if (loop.length >= 4) {
            const a = loop[0];
            const b = loop[loop.length - 1];
            if (a.x === b.x && a.y === b.y) {
              loops.push(loop);
            }
          }
        }

        // ====== 3) æ¸…ç†ï¼šå»æ‰å…±çº¿ç‚¹ï¼ˆä¿è¯ç›´çº¿ä»æ˜¯ç›´çº¿ï¼Œä¸â€œé’¢ç¬”åŒ–â€ï¼‰ ======
        function isCollinear(a, b, c) {
          // (b-a) x (c-b) == 0
          const abx = b.x - a.x,
            aby = b.y - a.y;
          const bcx = c.x - b.x,
            bcy = c.y - b.y;
          return abx * bcy - aby * bcx === 0;
        }

        function simplifyLoop(loop) {
          // loop æ˜¯é—­åˆçš„ï¼šæœ€åä¸€ä¸ªç‚¹==ç¬¬ä¸€ä¸ªç‚¹ï¼ˆæˆ‘ä»¬å…è®¸ä¸ä¸¥æ ¼ï¼Œå…ˆå¼ºåˆ¶é—­åˆï¼‰
          const first = loop[0];
          const last = loop[loop.length - 1];
          const closed = first.x === last.x && first.y === last.y ? loop : [...loop, { ...first }];

          // å»æ‰è¿ç»­é‡å¤ç‚¹
          const dedup = [closed[0]];
          for (let i = 1; i < closed.length; i++) {
            const p = closed[i],
              q = dedup[dedup.length - 1];
            if (p.x !== q.x || p.y !== q.y) dedup.push(p);
          }

          // å»å…±çº¿ç‚¹ï¼ˆä¿ç•™æ‹è§’ï¼‰
          const out = [];
          for (let i = 0; i < dedup.length; i++) {
            const prev = dedup[(i - 1 + dedup.length) % dedup.length];
            const cur = dedup[i];
            const next = dedup[(i + 1) % dedup.length];
            // ä¸åˆ é™¤é—­åˆç‚¹æœ¬èº«çš„å ä½ï¼šæœ€åä¸€ä¸ªç‚¹ç­‰äºç¬¬ä¸€ä¸ªç‚¹ï¼Œæœ€åå†å¤„ç†
            out.push(cur);
          }

          // out ä»å«é—­åˆé‡å¤ç‚¹ï¼Œå…ˆå»æ‰æœ€åä¸€ä¸ªé‡å¤ç‚¹
          if (out.length >= 2) {
            const a = out[0],
              b = out[out.length - 1];
            if (a.x === b.x && a.y === b.y) out.pop();
          }

          const simplified = [];
          for (let i = 0; i < out.length; i++) {
            const prev = out[(i - 1 + out.length) % out.length];
            const cur = out[i];
            const next = out[(i + 1) % out.length];
            if (!isCollinear(prev, cur, next)) simplified.push(cur);
          }

          // é‡æ–°é—­åˆ
          if (simplified.length >= 3) simplified.push({ ...simplified[0] });
          return simplified;
        }

        const simpleLoops = loops.map(simplifyLoop).filter((l) => l.length >= 4); // è‡³å°‘ä¸‰è§’å½¢+é—­åˆç‚¹

        // ====== 4) ç”Ÿæˆâ€œåªåœ¨ 90Â° æ‹è§’åœ†è§’â€çš„ pathï¼ˆå›ºå®šåŠå¾„ radius pxï¼‰ ======
        function roundedOrthogonalPath(loop, rPx, scalePx) {
          // loop: é—­åˆç‚¹åˆ—ï¼Œæœ€åä¸€ä¸ªç‚¹==ç¬¬ä¸€ä¸ªç‚¹ï¼›ç‚¹åæ ‡å•ä½=cell
          // åªå¯¹çœŸæ­£æ‹è§’ï¼ˆéå…±çº¿ï¼‰åšåœ†è§’ã€‚ç”±äºæˆ‘ä»¬å·² simplifyï¼Œæ‰€æœ‰ç‚¹éƒ½åº”æ˜¯æ‹è§’ã€‚
          if (loop.length < 4) return '';

          // å»æ‰æœ€åä¸€ä¸ªé‡å¤ç‚¹ç”¨äºç¯ç´¢å¼•
          const ring = loop.slice(0, -1);
          const n = ring.length;

          function v(a, b) {
            return { x: b.x - a.x, y: b.y - a.y };
          }
          function len(vv) {
            return Math.hypot(vv.x, vv.y);
          }
          function norm(vv) {
            const l = len(vv);
            return { x: vv.x / l, y: vv.y / l };
          }
          function cross(a, b) {
            return a.x * b.y - a.y * b.x;
          }

          let d = '';

          for (let i = 0; i < n; i++) {
            const p0 = ring[(i - 1 + n) % n];
            const p1 = ring[i];
            const p2 = ring[(i + 1) % n];

            const inVec = v(p1, p0); // p1 -> p0
            const outVec = v(p1, p2); // p1 -> p2

            const inLenPx = len(inVec) * scalePx;
            const outLenPx = len(outVec) * scalePx;

            // clampï¼šä¸èƒ½è¶…è¿‡ç›¸é‚»è¾¹çš„ä¸€åŠ
            const rr = Math.min(rPx, inLenPx / 2, outLenPx / 2);

            const uIn = norm(inVec);
            const uOut = norm(outVec);

            // åˆ‡ç‚¹
            const pIn = { x: p1.x + (uIn.x * rr) / scalePx, y: p1.y + (uIn.y * rr) / scalePx };
            const pOut = { x: p1.x + (uOut.x * rr) / scalePx, y: p1.y + (uOut.y * rr) / scalePx };

            if (i === 0) d += `M${pIn.x * scalePx},${pIn.y * scalePx} `;
            else d += `L${pIn.x * scalePx},${pIn.y * scalePx} `;

            // æ–¹å‘ï¼šç”¨è½¬å‘å†³å®š sweepï¼ˆSVG y è½´å‘ä¸‹ï¼‰
            // è‹¥ä½ å‘ç°åœ†å¼§â€œé¼“é”™æ–¹å‘â€ï¼ŒæŠŠ 0/1 å¯¹è°ƒå³å¯ï¼ˆsweep = crossSign < 0 ? 0 : 1ï¼‰
            const turn = cross(inVec, outVec);
            const sweep = turn < 0 ? 1 : 0;

            d += `A ${rr} ${rr} 0 0 ${sweep} ${pOut.x * scalePx} ${pOut.y * scalePx} `;
          }

          d += 'Z';
          return d;
        }

        let d = '';
        for (const loop of simpleLoops) {
          d += roundedOrthogonalPath(loop, radius, blockSize) + ' ';
        }

        // ====== 5) è¾“å‡º SVGï¼ˆé¿å… stroke è¢«è£åˆ‡ï¼‰ ======
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.classList.add('island');
        svg.dataset.islandId = islandData.id;
        svg.style.position = 'absolute';

        svg.setAttribute('width', width * blockSize + maxStroke);
        svg.setAttribute('height', height * blockSize + maxStroke);

        // é€‰ä¸­æè¾¹ï¼ˆæ›´ç²—ã€ä¸åŒé¢œè‰²ï¼‰ï¼Œé»˜è®¤éšè—
        const highlight = document.createElementNS(svgNS, 'path');
        highlight.setAttribute('d', d);
        highlight.setAttribute('fill', 'none');
        highlight.setAttribute('stroke', '#000000'); // ä½ æƒ³è¦çš„é€‰ä¸­é¢œè‰²
        highlight.setAttribute('stroke-width', String(highlightW)); // æ¯”åŸæ¥ç²—ä¸€ç‚¹
        highlight.setAttribute('stroke-linejoin', 'round');
        highlight.setAttribute('stroke-linecap', 'round');
        highlight.setAttribute('opacity', '0.9');
        highlight.setAttribute('transform', `translate(${pad},${pad})`);
        highlight.classList.add('island-highlight'); // ç”¨ class æ§åˆ¶æ˜¾ç¤º

        // åŸæœ¬çš„è½®å»“ï¼ˆä¿æŒä½ çš„é£æ ¼ï¼‰
        const base = document.createElementNS(svgNS, 'path');
        base.setAttribute('d', d);
        base.setAttribute('fill', 'white');
        base.setAttribute('stroke', 'black');
        base.setAttribute('stroke-width', String(strokeW));
        base.setAttribute('stroke-linejoin', 'round');
        base.setAttribute('stroke-linecap', 'round');
        base.setAttribute('transform', `translate(${pad},${pad})`);
        base.classList.add('island-base');

        svg.appendChild(highlight);
        svg.appendChild(base);

        return svg;
      }

      function initFoam(worldEl, worldContentEl, count = 60) {
        // Remove old foams to avoid duplicates
        worldContentEl.querySelectorAll('.foam').forEach((el) => el.remove());

        const W = worldEl.clientWidth;
        const H = worldEl.clientHeight;

        // We'll maintain a padded area around the viewport in content-coordinates
        const PAD = 600; // increase if you pan far/fast

        for (let i = 0; i < count; i++) {
          const f = document.createElement('div');
          f.className = 'foam';

          // Position in a big area centered around the initial viewport
          const x = Math.random() * (W + 2 * PAD) - PAD;
          const y = Math.random() * (H + 2 * PAD) - PAD;

          f.style.left = `${x}px`;
          f.style.top = `${y}px`;

          // Random animation params => not synced
          f.style.setProperty('--rise', `${6 + Math.random() * 18}px`);
          f.style.setProperty('--dur', `${1.2 + Math.random() * 2.2}s`);
          f.style.setProperty('--delay', `${Math.random() * 3.0}s`);
          f.style.opacity = `${0.45 + Math.random() * 0.55}`;

          // Store for wrap logic
          f._pad = PAD;

          worldContentEl.appendChild(f);
        }
      }

      function recycleFoam(worldEl, worldContentEl, offsetX, offsetY) {
        const W = worldEl.clientWidth;
        const H = worldEl.clientHeight;

        // Visible rect in content coords:
        // screenX = contentX + offsetX  => contentX = screenX - offsetX
        const vx0 = -offsetX;
        const vy0 = -offsetY;
        const vx1 = vx0 + W;
        const vy1 = vy0 + H;

        // how far outside viewport before we recycle
        const PAD = 600;

        const foams = worldContentEl.querySelectorAll('.foam');
        foams.forEach((f) => {
          let x = parseFloat(f.style.left) || 0;
          let y = parseFloat(f.style.top) || 0;

          // If too far left/right, wrap around
          if (x < vx0 - PAD) x = vx1 + Math.random() * PAD;
          else if (x > vx1 + PAD) x = vx0 - Math.random() * PAD;

          // If too far up/down, wrap around
          if (y < vy0 - PAD) y = vy1 + Math.random() * PAD;
          else if (y > vy1 + PAD) y = vy0 - Math.random() * PAD;

          f.style.left = `${x}px`;
          f.style.top = `${y}px`;
        });
      }

      function enableWorldPanning() {
        if (worldPanningEnabled) return;
        worldPanningEnabled = true;

        const world = document.getElementById('world');
        const content = document.getElementById('worldContent');
        const foamHost = content;

        initFoam(world, content, 80);

        let offsetX = 0,
          offsetY = 0;
        let dragging = false;
        let startX = 0,
          startY = 0;
        let startOffsetX = 0,
          startOffsetY = 0;

        function setTransform() {
          content.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

          recycleFoam(world, content, offsetX, offsetY);
        }

        world.addEventListener('pointerdown', (e) => {
          // å³é”®ä¸æ‹–
          if (e.button === 2) return;

          // å¦‚æœä½ å¸Œæœ›â€œç‚¹åˆ°å²›å±¿ä¹Ÿèƒ½æ‹–â€ï¼Œå°±ä¸åšä¸‹é¢è¿™ä¸ªåˆ¤æ–­
          // å¦‚æœä½ å¸Œæœ›â€œç‚¹å²›å±¿æ˜¯é€‰æ‹©ï¼Œä¸æ‹–â€ï¼Œå°±ä¿ç•™è¿™ä¸ªåˆ¤æ–­ï¼š
          // if (e.target.closest("svg")) return;

          dragging = true;
          world.classList.add('dragging');

          startX = e.clientX;
          startY = e.clientY;
          startOffsetX = offsetX;
          startOffsetY = offsetY;

          world.setPointerCapture(e.pointerId);
          e.preventDefault();
        });

        world.addEventListener('pointermove', (e) => {
          if (!dragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          offsetX = startOffsetX + dx;
          offsetY = startOffsetY + dy;
          setTransform();
        });

        function endDrag(e) {
          dragging = false;
          world.classList.remove('dragging');
          try {
            world.releasePointerCapture(e.pointerId);
          } catch {}
        }

        world.addEventListener('pointerup', endDrag);
        world.addEventListener('pointercancel', endDrag);

        // é˜²æ­¢å³é”®èœå•å½±å“ä½“éªŒï¼ˆå¯é€‰ï¼‰
        world.addEventListener('contextmenu', (e) => e.preventDefault());

        setTransform();

        return {
          getOffset: () => ({ x: offsetX, y: offsetY }),
          setOffset: (x, y) => {
            offsetX = x;
            offsetY = y;
            setTransform();
          },
        };
      }

      let selectedIsland = null;
      let selectionEnabled = false;

      function enableIslandSelection() {
        if (selectionEnabled) return;
        selectionEnabled = true;

        const world = document.getElementById('world');

        let downX = 0,
          downY = 0;
        let downIsland = null;
        let didDrag = false;

        const CLICK_TOLERANCE = 6;

        function islandUnderPointer(e) {
          const el = document.elementFromPoint(e.clientX, e.clientY);
          return el ? el.closest('svg.island') : null;
        }

        function deselectIsland() {
          if (!selectedIsland) return;
          selectedIsland.classList.remove('selected');
          selectedIsland = null;
          hideChatTab();

          // å¦‚æœå½“å‰åœ¨ Chat tabï¼Œå»ºè®®å›åˆ° World
          showTab(3);
        }

        world.addEventListener('pointerdown', (e) => {
          if (e.button !== 0) return; // åªå¤„ç†å·¦é”®
          downX = e.clientX;
          downY = e.clientY;
          didDrag = false;
          downIsland = islandUnderPointer(e);
        });

        world.addEventListener('pointermove', (e) => {
          if (e.buttons !== 1) return; // ä»…å·¦é”®æŒ‰ä½æ—¶
          const moved = Math.hypot(e.clientX - downX, e.clientY - downY);
          if (moved > CLICK_TOLERANCE) didDrag = true;
        });

        world.addEventListener('pointerup', async (e) => {
          if (e.button !== 0) return;

          // âœ… å¦‚æœæ˜¯æ‹–æ‹½ç»“æŸï¼šä¸åšä»»ä½•é€‰ä¸­/å–æ¶ˆæ“ä½œï¼ˆä¿ç•™å½“å‰é€‰ä¸­ï¼‰
          if (didDrag) return;

          const upIsland = islandUnderPointer(e);

          // ç‚¹åˆ°ç©ºç™½ï¼šå–æ¶ˆé€‰ä¸­ï¼ˆå¹¶éšè— Chatï¼‰
          if (!upIsland) {
            deselectIsland();
            return;
          }

          // å¿…é¡»æŒ‰ä¸‹å’ŒæŠ¬èµ·åœ¨åŒä¸€ä¸ªå²›ä¸Šæ‰ç®—â€œç‚¹å‡»å²›å±¿â€
          if (!downIsland || upIsland !== downIsland) return;

          // å†ç‚¹ä¸€æ¬¡åŒä¸€ä¸ªï¼šå–æ¶ˆ
          if (selectedIsland === upIsland) {
            deselectIsland();
            return;
          }

          // åˆ‡æ¢é€‰ä¸­
          if (selectedIsland) selectedIsland.classList.remove('selected');
          selectedIsland = upIsland;
          selectedIsland.classList.add('selected');

          showChatTabForIsland(selectedIsland.dataset.islandId || 'Chat');
          // showTab(4); // å¯é€‰ï¼šè‡ªåŠ¨åˆ‡åˆ° Chat

          await switchRoom(roomIdFromIslandId(selectedIsland.dataset.islandId));
        });

        // âœ… å…³é”®ï¼šç§»é™¤/ä¸è¦å†ç”¨ â€œclick ç‚¹ç©ºç™½å–æ¶ˆé€‰ä¸­â€
        // å› ä¸ºæ‹–æ‹½ä¹Ÿå¯èƒ½è§¦å‘ clickï¼Œå¯¼è‡´è¯¯å–æ¶ˆ
        // ï¼ˆä¸Šé¢ pointerup å·²ç»å¤„ç†äº†ç‚¹ç©ºç™½å–æ¶ˆï¼‰
      }

      function showChatTabForIsland(islandId) {
        const chatHeader = document.getElementById('tab-header4');
        chatHeader.textContent = islandId; // tab æ˜¾ç¤ºå²›å±¿åå­—
        chatHeader.style.display = 'block'; // æ˜¾ç¤º Chat tab
      }

      function hideChatTab() {
        const chatHeader = document.getElementById('tab-header4');
        chatHeader.style.display = 'none';
        chatHeader.textContent = 'Chat'; // å¯é€‰ï¼šæ¢å¤é»˜è®¤å­—æ ·
      }

      function roomIdFromIslandId(id) {
        return String(id)
          .trim()
          .replace(/[\/#\.\$\[\]]/g, '_');
      }

      function clearChatUI() {
        const canvas = chatCanvas();
        if (!canvas) return;

        // remove only chat objects, keep marquee box and other overlays
        canvas
          .querySelectorAll(
            '.symbol-label, .symbol, .dot, .typing-effect, .removable, .progress-ring',
          )
          .forEach((el) => el.remove());
      }

      async function switchRoom(roomId) {
        currentRoomId = roomId;
        clearChatUI(); // ä½ è‡ªå·±å®ç°ï¼šæŠŠå½“å‰èŠå¤©å®¤æ¸²æŸ“å‡ºæ¥çš„ emoji/symbol/dot æ¸…æ‰
        await loadObj(); // ä» rooms/{roomId}/objs é‡æ–°åŠ è½½
      }
    </script>
  </body>
</html>
