<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag and Connect Symbols</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f4f4f9;
            /* background-color: #262626; */
            /* background-color: #eef7f2; */
            /* background-color: #f9f1db; */
            font-family: Consolas;
            display: flex;
            height: 100vh; /* Full viewport height */
        }
        .symbol {
            position: absolute;
            width: 117px; /* Full width = 156 */
            height: 50.25px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
        }
        .symbol img {
            width: 100%;
            height: 100%;
        }

        .dot {
            position: absolute;
            width: 5px; /* Full width = 156 */
            height: 5px; /* Full height = 67 */
            cursor: grab;
            user-select: none;
        }

        /* Highlight connections */
        .framed {
            outline: 2px solid #00B0F0;
        }

        /* Basic styles for the button */
        .button {
            position: fixed; /* Enables top and left positioning */
            background-size: contain; /* Ensure the image covers the entire button */
            background-repeat: no-repeat;
            background-position: center;
            border: none;
            border-radius: 5px; /* Optional: Makes the button rounded */
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.2s;
        }

        /* Add hover effect */
        .button:hover {
            opacity: 0.5;
        }

        .logo {
            position: fixed; /* Allows precise positioning using top and left */
            width: 250px; /* Adjust size as needed */
            height: auto; /* Maintain aspect ratio */
            margin-bottom: 20px;
        }

        .wheel {
            position: fixed;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
        }

        /* Vertical bar styles */
        .vertical-bar {
            position: fixed;
            top: 0;
            right: 0;
            width: 280px;
            height: 100%;
            background-color: #00B0F0; /* Blue background */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 200px;
        }

        /* Tab styles */
        .tab {
            color: white;
            text-align: center;
            line-height: 100px;
            font-size: 40px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            width: 280px;
            height: 100px; /* Make taller for rectangular shape */
            padding: 0; /* No extra padding */
            cursor: pointer;
            margin: 0px 0; /* Spacing between buttons */
            border-radius: 0; /* Remove rounded corners */
            transition: background-color 1s ease-in-out, opacity 1s ease-in-out;
            opacity: 0.5; /* Start at a slightly faded state */
        }

        .tab:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transition: background-color 0.3s;
        }

        .tab-active {
            background-color: rgba(255, 255, 255, 0.6);
            opacity: 1; /* Fully visible */
        }

        /* Content container */
        .content {
            margin-left: auto; /* Push content to the left of the vertical bar */
            margin-right: 100px; /* Leave space for the vertical bar */
            flex: 1;
            padding: 20px;
            overflow-y: auto; /* Allows vertical scrolling */
            height: 100vh;
        }

        /* Content sections */
        .tab-content {
            display: none; /* Hide all content by default */
        }

        .tab-content.active {
            display: block; /* Show active tab content */
        }

        /* Color palette styles */
        .palette {
            position: fixed;
            display: flex;
            justify-content: center;
            margin: 20px auto;
            gap: 10px;
        }

        .color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ccc;
        }

        .color:hover {
            border: 2px solid black;
        }


        .progress-ring {
            position: absolute;
            width: 50px; /* Ensure this matches the SVG width */
            height: 50px; /* Ensure this matches the SVG height */
            transform: rotate(-90deg);
            visibility: hidden;
        }
  
        .progress-ring circle {
            fill: none;
            stroke: transparent;
            stroke-width: 5;
            stroke-dasharray: 157; /* Full circle length */
            stroke-dashoffset: 157; /* Start fully hidden */
            transition: stroke-dashoffset 0s, stroke 0s;
        }

        /* Style for the label */
        .symbol-label {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            cursor: pointer;
        }

        .symbol-label.active {
            border-width: 3px; /* Thicker border when clicked */
        }

        /* Style for the input box */
        .label-input {
            position: absolute;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace; /* Set font to match labels */
            border-radius: 5px;
        }

        /* Auto-resizing textarea */
        .label-textarea {
            position: absolute;
            width: 167px;
            min-height: 40px;
            max-width: 200px;
            border: 1px solid black;
            padding: 5px;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            border-radius: 5px;
            resize: none;
            overflow: hidden;
        }

        /* Style the submit button */
        .submit-button {
            position: absolute;
            background-color: white; /* Green */
            color: black;
            border: 1px solid black;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            width: 27px;
            height: 27px;
            line-height: 27px;
            text-align: center;
        }

        /* Hover effect */
        .submit-button:hover {
            opacity: 0.5;
        }


        .typing-effect p {
            position: absolute;
            font-size: 16px;
            font-family: Consolas, "Courier New", monospace;
            display: inline-block;
            white-space: pre-line;
            line-height: 1.5; /* Adjusts spacing for smooth movement */
            overflow: hidden;
        }
        
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #message-input {
            position: absolute;
            bottom: 80px;
            left: 400px;
            padding: 10px;
            width: 300px;
            font-size: 30px; /* Larger font size */
            background-color: transparent; /* Transparent background */
            border: none; /* No border */
            color: black; /* Text color */
        }

        /* Style the placeholder text (prompt) */
        #message-input::placeholder {
            font-style: italic; /* Italicize the placeholder text */
            color: gray; /* Gray color for the placeholder */
        }

        #cursor {
            display: inline-block;
            margin-left: 1px;
            animation: blink 0.8s infinite;
            font-weight: bold;
            animation: blink 0.8s infinite;
        }


        .image-container {
            display: flex;
            justify-content: center;
        }
        .image-container img {
            width: 10%; /* 50% of the parent container */
            height: auto; /* Maintain aspect ratio */
        }

        .image-row {
            display: flex;         /* Align images in a row */
            justify-content: center; /* Center images horizontally */
            align-items: center;    /* Align images vertically */
            gap: 10px;             /* Space between images */
        }

        .image-row img {
            width: 20%;   /* Set a uniform width */
            height: auto;  /* Set a uniform height */
            object-fit: cover; /* Crop images to fit without stretching */
        }

        #network {
            width: 82vw;
            height: 100vh;
            border: none;
            background: transparent;
            box-shadow: none;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
    <div class="vertical-bar">
        <img src="./icons/iti.svg" alt="Logo" class="logo" id="logo">
        <div class="tab" id="tab-header0" onclick="showTab(0)">Home</div>
        <div class="tab" id="tab-header1" onclick="showTab(1)">Craft</div>
        <div class="tab" id="tab-header2" onclick="showTab(2)">Library</div>
        <div class="tab" id="tab-header3" onclick="showTab(3)">Plaza</div>
        <div class="tab" id="tab-header4" onclick="showTab(4)">Chat</div>
    </div>

    <div class="content">
        <div class="tab-content" id="tab0">
            <p style="text-align: center"><h1>Divinatory Conlang on Canvas</h1></p>
            Welcome here! <br>
            Ever wondered how divination works? <br>
            The fortune tellers somehow comprehend the meaning behind random patterns, from Tarot suits to teacup dregs...<br> Maybe it is because they learned the meaning of these symbols and knew how to tell a story out of them. Anyway, it is about intuition and imagination. <br><br>
            This online platform plays with this idea, trying to make YOU the fortune teller, but in a more general sense: you communicate with others by <br> producing and interpreting abstract symbols. <br>Instead of teaching you an entire symbolic language, I will help you build a language by yourself. <br>
            However, note that your system's set of "atoms" is fixed, but how the "molecules" are structured is up to you.  <br><br>

            Here are the possible ways of combining the symbols:<br>

            <div class="image-row">
                <img src="./icons/sp.png"/>
            </div>
            <br>
            The symbols connected in "series" represent spatially <b>contiguous</b> relationships: above, below, adjacent to, outside, etc.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a traffic light = three lights lined in a row.<br>
                (2) a barn = a roof on top of a pile of grains.<br>
            </p>
            The symbols connected in "parallel" represent <b>composite</b> concepts.<br>
            <p style="text-align: center">
                Examples<br>
                (1) a white rock = the composite of whiteness and hardness.<br>
                (2) a bullet = the composite of smallness and advancing.<br>
            </p>

            <br>
            <div class="image-row">
                <img src="./icons/granary.png"/> <img src="./icons/bullet.png"/>
            </div>
            <br>
            As you can see, as long as it makes sense to you, it should work because it is all about <b>intuitiveness!</b><br><br>

            When you are making words, make sure the magnets connect the symbols. Only symbols connected count as a word. Treat them as "islands."<br>
            To check this, you can long-click on a symbol, and the entire connected island it belongs to will be highlighted.<br><br>
            Then, click on the <b>insight</b> button that looks like an eye, and it will propose some meanings from what it sees.<br>
            You can understand what each basic symbol means by repetitively clicking on the <b>insight</b> button and reading different meaningful aspects of the symbols.<br>
            While we only have the nine basic symbols from the start, the eye will see what you teach it to see over time.<br>
            Two windows will pop up that ask you to assign the word for your symbols and the reason behind this, though I haven't implemented the validation part yet.<br><br>
           
            In the next tab, poke around the interface and see if you can piece together your own expression for the words <b>"sky," "rain," "flower," and "computer."</b><br>
            Remember, when you are making the expressions, try to attend to the symbols' meaning (by clicking the <b>insight</b> button) <br>
            rather than purely by their visual resemblance to the concepts!
            <br><br><br><br>
            
        </div>
        <div class="tab-content" id="tab1">

            <!-- Color palette -->
            
            <div class="palette" id="palette">
                <div class="color" style="background-color: #5cb3cc;"></div>
                <div class="color" style="background-color: #D00000;"></div>
                <div class="color" style="background-color: #d6a01d;"></div>
                <div class="color" style="background-color: white;"></div>
                <div class="color" style="background-color: #3B3838;"></div>
            </div>
          <p></p>
        </div>
        <div class="tab-content" id="tab2">
          <div id="network"></div>
        </div>
        <div class="tab-content" id="tab3">
          <h1>Welcome to Tab 3</h1>
          <p>This is the content for Tab 3.</p>
        </div>
        <div class="tab-content" id="tab4">
              <!-- Input box at the bottom of the page -->
                <input type="text" id="message-input" placeholder="Say something..." />
          <p></p>
        </div>
    </div>

    <script type="module">
        const tabHeaders = [document.getElementById("tab-header0"), document.getElementById("tab-header1"), document.getElementById("tab-header2"), document.getElementById("tab-header3"), document.getElementById("tab-header4")];
        let tabHeadersActivated = [false, false, false, false, false];
        let activeTabInterval = null;
        // Switching between tabs
        window.showTab = function(tabIndex) {
            // Clear alpha animation
            clearInterval(activeTabInterval);
            tabHeaders[2].classList.remove('tab-active');

            // Hide all tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Show the selected tab content
            const activeContent = document.getElementById(`tab${tabIndex}`);
            activeContent.classList.add('active');

            for (let i = 0; i < 5; i++) {
                if (i === 3) {
                    continue;
                }
                if (i === tabIndex) {
                    tabHeaders[i].style.opacity = 1;
                    tabHeadersActivated[i] = true;
                } else {
                    tabHeaders[i].style.opacity = 0.5;
                    tabHeadersActivated[i] = false;
                }
            }
        }

        // Initialize the first tab as active
        showTab(0);
        const tab0 = document.getElementById("tab0");
        const tab1 = document.getElementById("tab1");
        const tab2 = document.getElementById("tab2");
        const tab3 = document.getElementById("tab3");
        const tab4 = document.getElementById("tab4");

        let activeSymbol = null;
        let activeEmoji = null;
        let selectedSymbols = new Set();
        let selectedEmoji = null;
        let isGenerating = false;
        let readyActive = null;
        let readyActiveSide = null;
        let readyTarget = null;
        let readyTargetSide = null;

        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setDoc, getDoc, updateDoc, doc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        

        const firebaseConfig = {
            apiKey: "AIzaSyDcnYVyHx8ZgE_kKquLctcA3Q5LuSagZUE",
            authDomain: "divinatoryconlang.firebaseapp.com",
            projectId: "divinatoryconlang",
            storageBucket: "divinatoryconlang.firebasestorage.app",
            messagingSenderId: "939674998709",
            appId: "1:939674998709:web:bbf228a108e046c8006bfc",
            measurementId: "G-GLFVN6M297"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        let currentCollection = "col1";
        // Reference to Firestore collection
        const objCollection = collection(db, currentCollection);

        // Function to Save Emoji
        async function saveObj(type, content, x, y) {
            const docRef = await addDoc(objCollection, {type, content, x, y});
            return docRef.id;
        }

        async function updateObjPosition(id, x, y) {
            const objDoc = doc(db, currentCollection, id);
            await updateDoc(objDoc, { x, y });
        }

        // Load emojis on page load
        window.onload = loadObj;

        function generateColor(uid) {
            let hash = 0;
            for (let i = 0; i < uid.length; i++) {
                hash = uid.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = `hsl(${hash % 360}, 70%, 60%)`; // Hue varies, but saturation & lightness are fixed
            return color;
        }

        // Initialize Firebase Authentication
        const auth = getAuth();
        let currentUser = null;

        // Function to sign in anonymously & store user ID
        async function signInAnonymouslyPersistent() {
            try {
                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;
                
                // Store user ID in local storage
                localStorage.setItem("anonymousUID", currentUser .uid);

                console.log("Signed in as a guest:", currentUser .uid);
            } catch (error) {
                console.error("Error with anonymous sign-in:", error);
            }
        }

        // Function to restore previous session or sign in a new user
        async function restoreAnonymousSession() {
            const savedUID = localStorage.getItem("anonymousUID");

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    console.log("User is signed in:", user.uid);
                } else {
                    if (savedUID) {
                        console.log("Restoring previous session with UID:", savedUID);
                    } else {
                        signInAnonymouslyPersistent();
                    }
                }
            });
        }

        // üîπ Call this function when the page loads
        restoreAnonymousSession();


        // Function to assign and store color if not already assigned
        async function assignUserColor() {
            const userRef = doc(db, "users", currentUser.uid); // Reference to user's Firestore document
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
                return userSnap.data().color; // Return existing color
            } else {
                const newColor = generateColor(currentUser.uid);
                await setDoc(userRef, { color: newColor });
                return newColor;
            }
        }

        // Function to Load Emojis
        async function loadObj() {
            const querySnapshot = await getDocs(objCollection);
            
            // Use a for...of loop to handle async/await properly
            for (const doc of querySnapshot.docs) {
                if (doc.data().type === "emoji") {
                    await createEmoji(doc.data().content, doc.data().x, doc.data().y, doc.id);
                }
                if (doc.data().type === "symbol") {
                    const symbol = await createSymbolCopy(null, null, doc.data().content.id, doc.data().x, doc.data().y, doc.data().content.color, doc.data().content.angle, doc.id);
                    if (doc.data().content.dotX !== null) {
                        symbol.isDynamic = true;
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        symbol.dot = dot;
                        dot.parent = symbol;
                        dot.style.left = `${doc.data().content.dotX}px`;
                        dot.style.top = `${doc.data().content.dotY}px`;
                        tab4.appendChild(dot);
                    }
                }
            }
        }

        // Function to delete a document
        async function deleteObj(collectionName, docId) {
            try {
                const docRef = doc(db, collectionName, docId);
                await deleteDoc(docRef);
                console.log(`Document with ID ${docId} deleted successfully.`);
            } catch (error) {
                console.error("Error deleting document:", error);
            }
        }

        class SymbolGraph {
            constructor() {
                this.map = new Map(); // Maps symbol to its adjacency list
            }

            addSymbol(symbol, connections) {
                this.map.set(symbol, connections); // connections = [[], [], (n, j), [], [], []]
            }

            getSymbolConnections(symbol) {
                return this.map.get(symbol) || null; // Return connections or null if not found
            }

            getSymbols() {
                return Array.from(this.map.keys()); // Return all symbols in the graph
            }

            matchSubgraph(storedGraph) {
                for (let [currSymbol] of this.map.entries()) {
                    let matchedSymbols = new Map();
                    if (this.doesMatch(storedGraph, currSymbol, matchedSymbols)) {
                        console.log("Match Found:", Array.from(matchedSymbols.values()));
                        return new Set(matchedSymbols.values());
                    }
                }
                console.log("No Match Found");
                return null;
            }

            doesMatch(storedGraph, currSymbol, matchedSymbols) {
                if (matchedSymbols.size === storedGraph.map.size) return true; // Full match found

                for (let [storedSymbol] of storedGraph.map.entries()) {
                    if (matchedSymbols.has(storedSymbol)) continue; // Already matched

                    if (this.isSymbolMatch(currSymbol, storedSymbol)) {
                        console.log(`Matching: ${currSymbol.elemIdTrue} ‚Üî ${storedSymbol.elemIdTrue}`);
                        matchedSymbols.set(storedSymbol, currSymbol);

                        let isValid = true;

                        // Check all six sides
                        for (let i = 0; i < 6; i++) {
                            let storedNeighbors = storedGraph.map.get(storedSymbol)[i] || [];
                            let currNeighbors = this.map.get(currSymbol)?.[i] || [];

                            if (storedNeighbors.length > currNeighbors.length) {
                                console.log(`Mismatch at side ${i}: Not enough neighbors`);
                                isValid = false;
                                break;
                            }

                            let foundAll = true;
                            for (let [storedNeighbor, storedSide] of storedNeighbors) {
                                let foundMatch = false;

                                for (let [currNeighbor, currSide] of currNeighbors) {
                                    if (
                                        currSide === storedSide &&
                                        this.isSymbolMatch(currNeighbor, storedNeighbor)
                                    ) {
                                        if (matchedSymbols.has(currNeighbor) || this.doesMatch(storedGraph, currNeighbor, matchedSymbols)) {
                                            foundMatch = true;
                                            break;
                                        }
                                    }
                                }

                                if (!foundMatch) {
                                    console.log(`Neighbor mismatch: ${storedNeighbor.elemIdTrue} not found`);
                                    foundAll = false;
                                    break;
                                }
                            }

                            if (!foundAll) {
                                isValid = false;
                                break;
                            }
                        }

                        if (isValid) return true;
                        matchedSymbols.delete(storedSymbol); // Backtrack
                    }
                }
                return false;
            }

            isSymbolMatch(currSymbol, storedSymbol) {
                return (
                    currSymbol &&
                    storedSymbol &&
                    currSymbol.elemIdTrue === storedSymbol.elemIdTrue &&
                    currSymbol.isDynamic === storedSymbol.isDynamic &&
                    currSymbol.angle === storedSymbol.angle
                );
            }
        }

        const currentGraph = new SymbolGraph();
        const library = new Map();
        const scale = 0.75;
        const SNAP_DISTANCE = 30 * scale; // Pixel distance for snapping

        let acc = 0;
        let moleculeString = "";
        let selectedColor = null;
        const positions = [2, 1, 0, 7, 3, 4, 5, 6]; // Angle 0 = to the right
        // Circle layout parameters
        const radius = 150; // Radius of the circle
        const centerX = 450; // Center of the canvas (half of canvas width)
        const centerY = 200; // Center of the canvas (half of canvas height)

        const symbolScale = 0.75;
        const symbolWidth = 156;
        const symbolHeight = 67;

        const calX = 1;
        const calY = 6.7 * symbolScale;
        const calInvY = 7 * symbolScale;
        const calCan1 = 4 * symbolScale;
        const calCan2 = 3.5 * symbolScale;


        // Long press variables
        let progress = 0;
        let interval;
        let ring = null;
        let circle = null;
        const pressDuration = 1000; // 1 second to complete the bar
        const totalSteps = pressDuration / 10;

        // Set the x and y coordinates dynamically using JavaScript
        const logo = document.getElementById('logo');
        logo.style.right = `10px`; // Set the x position
        logo.style.top = `30px`; // Set the y position

        const palette = document.getElementById('palette');
        palette.style.left = `685px`;
        palette.style.top = `55px`;

        // Symbol labels
        const symbolLabels = [[['empty', 'medium', 'place'], ['still', 'calm', 'fixed']],
            [['protect', 'constrain'], ['come', 'pull', 'retreat']],
            [['center', 'middle', 'inner', 'occupy', 'point', 'individual', 'barrier', 'obstacle', 'unit'], ['separate', 'source', 'spread', 'explode', 'radiate']],
            [['latent', 'hidden', 'unsupported', 'supple', 'bloated'], ['decay', 'leak', 'discard', 'shed', 'loosen', 'let go']],
            [['base', 'carry', 'load', 'deep'], ['go', 'push', 'advance']],
            [['gap', 'contain', 'enclosure', 'shell', 'surround'], ['join', 'combine', 'close', 'squeeze', 'attach']],
            [['heap', 'pile', 'hill', 'stub', 'incomplete', 'recess', 'cavity', 'blade', 'sharp', 'shallow', 'exposed'], ['depart', 'give', 'express']],
            [['full', 'substance', 'complete', 'large'], ['chaotic', 'turmoil', 'unrest', 'hustle', 'activity', 'bustle', 'dynamic', 'vibrancy']],
            [['monotonous', 'homogeneous', 'same', 'normal', 'substance'], ['complex', 'system', 'order', 'organic', 'intricate', 'variegated']]];

        const symbolTitles = ['Based on Trigram Kun ‚ò∑. Empty and still.',
                        'Based on Trigram Gen ‚ò∂. Constrain and fall.',
                        'Based on Trigram Kan ‚òµ. Occupy and radiate.',
                        'Based on Trigram Xun ‚ò¥. Latent and leak.',
                        'Based on Trigram Zhen ‚ò≥. Load and rise.',
                        'Based on Trigram Li ‚ò≤. Contain and attach.',
                        'Based on Trigram Dui ‚ò±. Express and expose.',
                        'Based on Trigram Qian ‚ò∞. Full and vibrant.',
                        'A uniquely √çt√≠ symbol. It is always balancing all elements, so it can be either monotonous or filled with variegated order.']
        // Symbol data (position on circle)
        const symbolData = [
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000;stroke-width:1.02897" d="M15.362 16.96v-1.28H49.92v2.56H15.362Z"></path><path d="M0 5.371v-1.28h34.56v2.56H0z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h38.08V4.48h2.56v13.76H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h23.68V4.48h2.56v11.2h23.68v2.56H0Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><a transform="translate(0 -12)"><path style="fill:#000" d="M0 31.52c0-1.28 0-1.28 16.31-1.28 8.438 0 12.956-.003 14.768.024 1.676.024.91-.928.319-1.77-6.312-9.011 4.424-20.08 13.641-14.065 5.795 3.782 5.914 12.549.223 16.464-2.752 1.894-2.823 1.899-25.021 1.903C0 32.8 0 32.8 0 31.52m43.461-2.46c6.384-3.947 3.578-13.7-3.941-13.7-8.426 0-10.362 11.492-2.437 14.458 1.796.672 4.604.338 6.378-.759"></path><path d="M-.007 31.517v-1.28h16.31s20.052 2.554 3.93 2.557l-20.24.003z" style="fill:#000"></path></a></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h38.08v2.56H9.28Z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M9.28 11.36V4.48h2.56v11.2h26.24V4.48h2.56v13.76H9.28z"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M49.915 19.513c0-1.28 0-1.28-16.31-1.28-8.438 0-12.955-.003-14.768.023-1.675.025-.909-.927-.318-1.77 6.312-9.01-4.424-20.08-13.642-14.065-5.795 3.782-5.913 12.55-.223 16.465 2.752 1.893 2.824 1.899 25.021 1.903 20.24.004 20.24.004 20.24-1.276M6.454 17.052c-6.384-3.947-3.578-13.7 3.941-13.7 8.426 0 10.363 11.493 2.437 14.459-1.796.672-4.604.338-6.378-.76"></path><path d="M49.922 19.51v-1.28h-16.31s-20.052 2.553-3.93 2.556l20.24.004z" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M21.856 20.468c-3.226-1.115-6.05-3.957-6.641-6.684-.226-1.04-.226-1.04-7.72-1.04-7.495 0-7.495 0-7.495-1.28s0-1.28 7.348-1.28c4.823 0 6.48 0 7.148-.385.35-.201.427-.508.547-.975 2.649-10.367 17.185-10.367 19.834 0 .348 1.36.348 1.36 7.695 1.36s7.348 0 7.348 1.28 0 1.28-7.495 1.28c-7.494 0-7.494 0-7.72 1.04-1.093 5.04-7.683 8.47-12.85 6.684m5.74-2.465c6.55-2.232 6.55-11.806 0-14.039-7.822-2.664-13.768 6.713-7.883 12.43 2.026 1.966 5.032 2.58 7.882 1.61"></path><path d="M35.224 10.185H49.92v2.56h-7.494m-34.928.003H.003v-2.56h14.695" style="fill:#000"></path></svg>`,
        `<svg width="100%" height="100%" viewBox="0 0 49.92 21.44" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M0 16.96v-1.28h49.92v2.56H0Zm8-11.2V4.48h33.92v2.56H8Z"></path></svg>`
        ];


        const dotData = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="5" fill="red"/></svg>`;
        const dotDataMini = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="2" cy="2" r="2" fill="red"/></svg>`;
        const dotOffsetXData = [0, 45, 0, 46, -45, 0, -46, 0, 0];
        const dotOffsetYData = [0, 0, 0, -8, 0, 0, -8, -8, 0];
        async function rotateSymbol(symbol, addAngle) {
            symbol.angle = (symbol.angle + addAngle) % 360;
            if (symbol.elemId === 1) {
                if (symbol.angle === 90) {
                    symbol.elemId = 4;
                    symbol.innerHTML = symbolData[4];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 4;
                    symbol.innerHTML = symbolData[4];
                }
            } else if (symbol.elemId === 3) {
                if (symbol.angle === 90) {
                    symbol.elemId = 6;
                    symbol.innerHTML = symbolData[6];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 6;
                    symbol.innerHTML = symbolData[6];
                }
            } else if (symbol.elemId === 4) {
                if (symbol.angle === 90) {
                    symbol.elemId = 1;
                    symbol.innerHTML = symbolData[1];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 1;
                    symbol.innerHTML = symbolData[1];
                }
            }else if (symbol.elemId === 6) {
                if (symbol.angle === 90) {
                    symbol.elemId = 3;
                    symbol.innerHTML = symbolData[3];
                }
                if (symbol.angle === 270) {
                    symbol.elemId = 3;
                    symbol.innerHTML = symbolData[3];
                }
            }
            // symbol.querySelector('svg').setAttribute('width', '100%');
            // symbol.querySelector('svg').setAttribute('height', '100%');
            symbol.style.transform = `rotate(${symbol.angle}deg)`;
            if(symbol.isDynamic) await updateDotPosition(symbol.dot);
        }

        const turnButton = document.createElement("div");
        turnButton.classList.add("button");
        turnButton.style.width = `149px`;
        turnButton.style.height = `142px`;
        turnButton.style.backgroundImage = "url('./icons/turn.png')";
        turnButton.style.left = `40px`;
        turnButton.style.top = `30px`;
        turnButton.addEventListener("click", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    await rotateSymbol(selectedSymbol, 90);
                }
            }
            
            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
            
        });
        tab1.appendChild(turnButton);

        const turnButton2 = turnButton.cloneNode(true);
        turnButton2.addEventListener("click", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.angle = (selectedSymbol.angle + 90) % 360;
                    console.log(selectedSymbol.angle);
                    if (selectedSymbol.elemId === 1) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 4;
                            selectedSymbol.innerHTML = symbolData[4];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 4;
                            selectedSymbol.innerHTML = symbolData[4];
                        }
                    } else if (selectedSymbol.elemId === 3) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 6;
                            selectedSymbol.innerHTML = symbolData[6];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 6;
                            selectedSymbol.innerHTML = symbolData[6];
                        }
                    } else if (selectedSymbol.elemId === 4) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 1;
                            selectedSymbol.innerHTML = symbolData[1];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 1;
                            selectedSymbol.innerHTML = symbolData[1];
                        }
                    }else if (selectedSymbol.elemId === 6) {
                        if (selectedSymbol.angle === 90) {
                            selectedSymbol.elemId = 3;
                            selectedSymbol.innerHTML = symbolData[3];
                        }
                        if (selectedSymbol.angle === 270) {
                            selectedSymbol.elemId = 3;
                            selectedSymbol.innerHTML = symbolData[3];
                        }
                    }
                    // selectedSymbol.querySelector('svg').setAttribute('width', '100%');
                    // selectedSymbol.querySelector('svg').setAttribute('height', '100%');
                    selectedSymbol.style.transform = `rotate(${selectedSymbol.angle}deg)`;
                    if(selectedSymbol.isDynamic) await updateDotPosition(selectedSymbol.dot);
                }
            }
            
            if (eyeButton2.isActivated) {
                eyeButton2.isActivated = false;
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        tab4.appendChild(turnButton2);

        const dotButton = document.createElement("div");
        dotButton.classList.add("button");
        dotButton.style.width = `143px`;
        dotButton.style.height = `94px`;
        dotButton.style.backgroundImage = "url('./icons/dot.png')";
        dotButton.style.left = `200px`;
        dotButton.style.top = `55px`;

        dotButton.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;
                        await updateDotPosition(dot);
                        tab1.appendChild(dot);

                    } else {

                        selectedSymbol.dot.remove();
                        selectedSymbol.dot = null;
                    }
                    
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });

        tab1.appendChild(dotButton);

        const dotButton2 = dotButton.cloneNode(true);
        dotButton2.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                // Increment the angle by 90 degrees
                for (const selectedSymbol of selectedSymbols) {
                    selectedSymbol.isDynamic = !selectedSymbol.isDynamic;
                    if (selectedSymbol.isDynamic) {
                        const dot = document.createElement('div');
                        dot.innerHTML = dotData;
                        dot.classList.add('dot');
                        selectedSymbol.dot = dot;
                        dot.parent = selectedSymbol;
                        await updateDotPosition(dot);
                        tab4.appendChild(dot);
                    } else {
                        if (tabHeadersActivated[4]) {
                            const objDoc = doc(db, currentCollection, selectedSymbol.dataset.id);
                            
                            await updateDoc(objDoc, {
                                "content.dotX": null,
                                "content.dotY": null
                            });
                        }
                        selectedSymbol.dot.remove();
                        selectedSymbol.dot = null;
                    }
                    
                }
            }

            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }

        });
        tab4.appendChild(dotButton2);

        async function updateDotPosition(dot) {
            const symbol = dot.parent;
            const rect = symbol.getBoundingClientRect();
            switch (symbol.angle) {
                case 0: 
                    dot.style.left = `${parseFloat(rect.left) + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5}px`;
                    dot.style.top = `${parseFloat(rect.top) + dotOffsetYData[symbol.elemId] * symbolScale - 12}px`;
                    break;
                case 90:
                    dot.style.left = `${parseFloat(rect.right) - dotOffsetYData[symbol.elemId] * symbolScale}px`;
                    dot.style.top = `${parseFloat(rect.top) + (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 10}px`;
                    break;
                case 180: 
                    dot.style.left = `${parseFloat(rect.right) - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 5}px`;
                    dot.style.top = `${parseFloat(rect.bottom) - dotOffsetYData[symbol.elemId] * symbolScale - 7}px`;
                    break;
                case 270:
                    dot.style.left = `${parseFloat(rect.left) + dotOffsetYData[symbol.elemId] * symbolScale - 10}px`;
                    dot.style.top = `${parseFloat(rect.bottom) - (symbolWidth / 2 + dotOffsetXData[symbol.elemId]) * symbolScale - 7}px`;
                    break;
            }
            if (tabHeadersActivated[4]) {
                const objDoc = doc(db, currentCollection, symbol.dataset.id);
                
                await updateDoc(objDoc, {
                    "content.dotX": parseFloat(dot.style.left),
                    "content.dotY": parseFloat(dot.style.top)
                });
            }
        }
        const eyeButton = document.createElement("div");
        eyeButton.isActivated = false;
        eyeButton.classList.add("button");
        eyeButton.style.width = `150px`;
        eyeButton.style.height = `106px`;
        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
        eyeButton.style.left = `510px`;
        eyeButton.style.top = `40px`;

        eyeButton.addEventListener("mouseup", (e) => {
            eyeButton.isActivated = !eyeButton.isActivated;
            if (eyeButton.isActivated) {
                eyeButton.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();
                    showInput(foundIds, elimBasic, representatives, hasDuplicateExpression);
                }
            } else {
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab1.appendChild(eyeButton);

        const eyeButton2 = eyeButton.cloneNode(true);

        eyeButton2.addEventListener("mouseup", (e) => {
            eyeButton2.isActivated = !eyeButton2.isActivated;
            if (eyeButton2.isActivated) {
                eyeButton2.style.backgroundImage = "url('./icons/eye_blue.png')";
                if (selectedSymbols.size !== 0) {
                    const [foundIds, elimBasic, representatives, hasDuplicateExpression] = showSimpleLabel();
                }
            } else {
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });
        tab4.appendChild(eyeButton2);

        const removeButton = document.createElement("div");
        removeButton.isActivated = false;
        removeButton.classList.add("button");
        removeButton.style.width = `168.75px`;
        removeButton.style.height = `119.25px`;
        removeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeButton.style.left = `340px`;
        removeButton.style.top = `40px`;

        removeButton.addEventListener("mouseup", (e) => {
            if (selectedSymbols.size != 0) {
                for (const selectedSymbol of selectedSymbols) {
                    if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                    selectedSymbol.remove();
                }
            }
            if (eyeButton.isActivated) {
                eyeButton.isActivated = false;
                eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab1.appendChild(removeButton);

        const removeButton2 = removeButton.cloneNode(true);

        removeButton2.addEventListener("mouseup", async (e) => {
            if (selectedSymbols.size != 0) {
                for (const selectedSymbol of selectedSymbols) {
                    await deleteObj(currentCollection, selectedSymbol.dataset.id);
                    if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                    selectedSymbol.remove();
                }
            }
            console.log(selectedEmoji);
            if (selectedEmoji) {
                selectedEmoji.remove();
                await deleteObj(currentCollection, selectedEmoji.dataset.id);
                console.log(selectedEmoji);
            }
            if (eyeButton2.isActivated) {
                eyeButton2.isActivated = false;
                eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                removeLabelInputs();
            }
        });

        tab4.appendChild(removeButton2);
        
        const removeNodeButton = document.createElement("div");
        removeNodeButton.isActivated = false;
        removeNodeButton.classList.add("button");
        removeNodeButton.style.width = `168.75px`;
        removeNodeButton.style.height = `119.25px`;
        removeNodeButton.style.backgroundImage = "url('./icons/astray.png')";
        removeNodeButton.style.left = `40px`;
        removeNodeButton.style.top = `30px`;
        tab2.appendChild(removeNodeButton);
        removeNodeButton.addEventListener("mouseup", (e) => {
            let selectedNodes = network.getSelectedNodes(); // Get selected node ID(s)

            if (selectedNodes.length === 0) {
                alert("No node selected!");
                return;
            }

            let nodeId = selectedNodes[0]; // Get the first selected node

            if (basicNodes.has(nodes.get(nodeId))) {
                return;
            }
            // Remove the node
            nodes.remove(nodeId);

            // Remove edges connected to the node
            let connectedEdges = edges.get({
                filter: (edge) => edge.from === nodeId || edge.to === nodeId
            });
            edges.remove(connectedEdges);
        });


        function dyeColor(symbol, color) {
            const svgElement = symbol.querySelector("svg");
            const paths = svgElement.querySelectorAll("path"); // Get the first shape inside the SVG
            paths.forEach((path) => {
                path.setAttribute("style", "fill:" + color); // Change the fill attribute
            });
        }

        // Handle color selection
        palette.addEventListener("click", (e) => {
        if (e.target.classList.contains("color")) {
            selectedColor = e.target.style.backgroundColor; // Set the selected color
            if (selectedSymbols.size != 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    dyeColor(selectedSymbol, selectedColor);
                });
            }
            console.log(`Selected color: ${selectedColor}`);
        }
        });

        const wheel = document.createElement("div"); // Your wheel sprite
        wheel.classList.add("wheel");
        wheel.style.left = `50px`; // Set the x position
        wheel.style.bottom = `40px`; // Set the y position
        wheel.style.width = `290.67px`;
        wheel.style.height = `292.33px`;
        wheel.style.backgroundImage = "url('./icons/wheel/wheel.png')";
        let wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
        let wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
        console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY} ${window.innerHeight} ${parseFloat(wheel.style.bottom)}`);
        const centerRadius = 36; // Define center circle radius

        wheel.addEventListener("mousedown", async (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                console.log("Clicked center!");
                wheel.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            } 

            // Calculate the angle in degrees (0¬∞ at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45¬∞)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel.addEventListener("mouseup", (event) => {
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });

        tab1.appendChild(wheel);

        const wheel2 = wheel.cloneNode(true);
        wheel2.addEventListener("mousedown", async (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Calculate the distance from the center
            const dx = mouseX - wheelCenterX;
            const dy = mouseY - wheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < centerRadius) {
                console.log("Clicked center!");
                wheel2.style.backgroundImage = `url(./icons/wheel/wheel8.png)`;
                await createSymbolCopy(mouseX, mouseY, 8);
                return; // Center circle detected
            } 

            // Calculate the angle in degrees (0¬∞ at the right, counterclockwise)
            let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 67.5;
            angle = angle % 360;
            if (angle < 0) angle += 360; // Convert negative angles

            // Determine sector (each is 45¬∞)
            let sectorIndex = Math.floor(angle / 45);
            if (sectorIndex < 4) sectorIndex = 3 - sectorIndex;
            wheel2.style.backgroundImage = `url(./icons/wheel/wheel${sectorIndex}.png)`;
            if (!isGenerating) {
                isGenerating = true;
                await createSymbolCopy(mouseX, mouseY, sectorIndex);
            }
        });

        wheel2.addEventListener("mouseup", (event) => {
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";
        });
        tab4.appendChild(wheel2);

        // Function to handle the message when Enter is pressed
        async function handleMessage() {
            const messageBox = document.getElementById('message-input');
            const userInput = messageBox.value;

            messageBox.value = '';

            try {
                const response = await fetch("https://divinatory-conlang.zhouyt-tony2018.workers.dev/", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    type: "emoji",
                    text: userInput
                })
                });

                const data = await response.json();
                await createEmoji(data.result);
            } catch (error) {
                console.error(error);
                alert("Emoji generation failed.");
            }
        }

        // Add event listener to the input box for the Enter key
        document.getElementById('message-input').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                handleMessage();
            }
        });

        function floatLabel(label) {
            const maxDistance = 20; // Maximum distance from the original position
            const originX = 0, originY = 0; // Store original position
            let x = 0, y = 0;

            setInterval(() => {
                let xDelta = getRandomFloat(-2, 2);
                let yDelta = getRandomFloat(-2, 2);

                // Calculate new position
                let newX = x + xDelta;
                let newY = y + yDelta;

                // Check if the new position is within the allowed distance
                let distance = Math.sqrt(newX ** 2 + newY ** 2);
                if (distance <= maxDistance) {
                    x = newX;
                    y = newY;
                    label.style.transform = `translate(${x}px, ${y}px)`;
                }
            }, 100);
        }


        async function createEmoji(emojiResponse, emojiX=null, emojiY=null, emojiId=null) {
            const emoji = document.createElement('div');
            emoji.classList.add('symbol-label');
            // Position the label near the symbol
            if (emojiX) {
                emoji.x = emojiX;
                emoji.y = emojiY;
            } else {
                emoji.x = getRandomFloat(window.innerWidth / 5, window.innerWidth * 4 / 5);
                emoji.y = getRandomFloat(window.innerHeight / 5, window.innerHeight * 4 / 5);
            }

            emoji.style.left = `${emoji.x}px`;
            emoji.style.top = `${emoji.y}px`;
            emoji.selected = false;
            
            // Add pressing event listener to the symbol
            emoji.addEventListener("mousedown", (e) => {
                if (selectedEmoji) {
                    selectedEmoji.style.cursor = "grab";
                    selectedEmoji.classList.remove("active");
                    selectedEmoji = null;
                }
                selectedSymbols.forEach(selectedSymbol => {
                    selectedSymbol.selected = false;
                    selectedSymbol.classList.remove("framed");
                    selectedSymbols.delete(selectedSymbol);
                    if (eyeButton.isActivated) {
                        eyeButton.isActivated = false;
                        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                    if (eyeButton2.isActivated) {
                        eyeButton2.isActivated = false;
                        eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                });

                activeEmoji = emoji; // becomes active when being clicked on
                emoji.offsetX = e.clientX - emoji.offsetLeft;
                emoji.offsetY = e.clientY - emoji.offsetTop;
                emoji.selected = !emoji.selected;
                emoji.style.cursor = "grabbing";

                if (!activeEmoji.classList.contains("active")) {
                    activeEmoji.classList.add("active");
                }

            });

            tab4.appendChild(emoji);
            emoji.textContent = emojiResponse; // Default text
            floatLabel(emoji);

            if (emojiId !== null) {
                emoji.dataset.id = emojiId;
            } else {
                emoji.dataset.id = await saveObj("emoji", emojiResponse, emoji.x, emoji.y);
            }

            return emoji;
        }

        window.addEventListener("resize", () => {
            wheelCenterX = parseFloat(wheel.style.left) + parseFloat(wheel.style.width) / 2;  // right x
            wheelCenterY = window.innerHeight - parseFloat(wheel.style.bottom) - parseFloat(wheel.style.height) / 2;
            console.log(`wheel center x: ${wheelCenterX}, wheel center y: ${wheelCenterY}`);
        });

        function removeLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label.removable');
            labels.forEach(label => label.remove());
            const inputs = document.querySelectorAll('.label-input.removable');
            inputs.forEach(input => input.remove());
            const textareas = document.querySelectorAll('.label-textarea.removable');
            textareas.forEach(textarea => textarea.remove());
            const buttons = document.querySelectorAll('.submit-button.removable');
            buttons.forEach(button => button.remove());
            const outputBoxes = document.querySelectorAll('.typing-effect.removable');
            outputBoxes.forEach(outputBox => outputBox.remove());
        }

        function hideLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.remove('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.remove('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.classList.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.remove('active'));
        }

        function showLabelInputs() {
            const labels = document.querySelectorAll('.symbol-label');
            labels.forEach(label => label.classList.add('active'));
            const inputs = document.querySelectorAll('input');
            inputs.forEach(input => input.classList.add('active'));
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => textarea.add.remove('active'));
            const buttons = document.querySelectorAll('.submit-button');
            buttons.forEach(button => button.classList.add('active'));
        }        


        document.addEventListener("mousemove", async (e) => {
            if (activeEmoji) {
                let x = e.clientX - activeEmoji.offsetX;
                let y = e.clientY - activeEmoji.offsetY;
                activeEmoji.style.left = `${x}px`;
                activeEmoji.style.top = `${y}px`;
                activeEmoji.selected = true;
            }

            if (activeSymbol) {
                let x = e.clientX - activeSymbol.offsetX;
                let y = e.clientY - activeSymbol.offsetY;
                activeSymbol.style.left = `${x}px`;
                activeSymbol.style.top = `${y}px`;
                activeSymbol.selected = true;
                endLongPress();
                // hideLabelInputs();
                if (activeSymbol.labels) {
                    activeSymbol.labels.forEach(label => {
                        label.style.left = `${x + label.offsetX}px`;
                        label.style.top = `${y + label.offsetY}px`;
                    });
                }
                if (activeSymbol.input) {
                    activeSymbol.input.style.left = `${x + activeSymbol.input.offsetX}px`;
                    activeSymbol.input.style.top = `${y + activeSymbol.input.offsetY}px`;
                }
                if (activeSymbol.textarea) {
                    activeSymbol.textarea.style.left = `${x + activeSymbol.textarea.offsetX}px`;
                    activeSymbol.textarea.style.top = `${y + activeSymbol.textarea.offsetY}px`;
                }
                if (activeSymbol.submitButton) {
                    activeSymbol.submitButton.style.left = `${x + activeSymbol.submitButton.offsetX}px`;
                    activeSymbol.submitButton.style.top = `${parseFloat(activeSymbol.textarea.style.top) + 8 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.pElement) {
                    activeSymbol.pElement.style.left = `${x + activeSymbol.pElement.offsetX}px`;
                    activeSymbol.pElement.style.top = `${parseFloat(activeSymbol.textarea.style.top) - 10 + activeSymbol.textarea.scrollHeight}px`;
                }
                if (activeSymbol.doneButton) {
                    activeSymbol.doneButton.style.left = `${x + activeSymbol.doneButton.offsetX}px`;
                    activeSymbol.doneButton.style.top = `${parseFloat(activeSymbol.doneButton.style.top) + 23 + activeSymbol.doneButton.answerHeight}px`;
                }

                if (!activeSymbol.moving) {
                    // Cut connections
                    for (let i = 0; i < currentGraph.getSymbolConnections(activeSymbol).length; i++) {
                        const entryLst = currentGraph.getSymbolConnections(activeSymbol)[i];
                        if (entryLst.length !== 0) {
                            // for (const entry in entryLst) {
                            for (let j = 0; j < entryLst.length; j++) {
                                const entry = entryLst[j];
                                const targetEntry = currentGraph.getSymbolConnections(entry[0])[entry[1]];
                                console.log(`targetEntry ${j}`);
                                console.log(targetEntry);
                                // Cut off from the other side
                                currentGraph.getSymbolConnections(entry[0])[entry[1]] = targetEntry.filter(sublist => sublist[0] !== activeSymbol);
                            }
                            currentGraph.getSymbolConnections(activeSymbol)[i] = [];
                        }
                    }
                    activeSymbol.moving = true;
                }
                if (!activeSymbol.classList.contains("framed")) {
                    activeSymbol.classList.add("framed");
                }

                checkConnections(activeSymbol);
                if (activeSymbol.isDynamic) await updateDotPosition(activeSymbol.dot);
                // console.log("mouse move " + activeSymbol.elemId);
            }
        });

        document.addEventListener("mouseup", async (e) => {
            endLongPress();
            wheel.style.backgroundImage = "url(./icons/wheel/wheel.png)";
            wheel2.style.backgroundImage = "url(./icons/wheel/wheel.png)";
            const clickedElemClass = e.target.className;
            console.log(`selected symbols ${selectedSymbols.size} clickedelemtype ${clickedElemClass}`);
            let rect;
            if (selectedSymbols.size !== 0 && clickedElemClass == 'content') {
                selectedSymbols.forEach(selectedSymbol => {
                    rect = selectedSymbol.getBoundingClientRect();
                    // console.log('x1:' + rect.left + ' y1:' + rect.top + ' x2:' + rect.right + ' y2:' + rect.bottom + ' mousex:' + e.clientX + ' mousey:' + e.clientY)
                    if (! (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom)) {
                        selectedSymbol.classList.remove("framed");
                        selectedSymbols.delete(selectedSymbol);
                        selectedSymbol.selected = false;
                        selectedSymbol = null;
                    }
                });
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }
            }
            if (selectedEmoji) {
                rect = selectedEmoji.getBoundingClientRect();
                if (! (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom)) { 
                    selectedEmoji.style.cursor = "grab";
                    selectedEmoji.classList.remove("active");
                    selectedEmoji.selected = false;
                    selectedEmoji = null;
                }
            }
            if (activeSymbol) {
                activeSymbol.stopped = true;
                activeSymbol.style.cursor = "grab";
                if (activeSymbol.selected) {  // released after moving or released without moving for selection
                    if (!activeSymbol.classList.contains("framed")) {
                        activeSymbol.classList.add("framed");
                    }
                    selectedSymbols.add(activeSymbol);
                    console.log(`moving ${activeSymbol.moving} readyActive ${readyActive}`)
                    if (readyActive !== null && activeSymbol.moving) {
                        console.log('load the link into graph');
                        currentGraph.getSymbolConnections(readyTarget)[readyTargetSide].push([readyActive, readyActiveSide]);
                        currentGraph.getSymbolConnections(readyActive)[readyActiveSide].push([readyTarget, readyTargetSide]);
                    }
                    // console.log("frame add " + activeSymbol.elemId);
                } else {  // released without moving for cancelling selection
                    console.log("frame remove " + activeSymbol.elemId);
                    if (eyeButton.isActivated) {
                        eyeButton.isActivated = false;
                        eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                        removeLabelInputs();
                    }
                    activeSymbol.classList.remove("framed");
                    selectedSymbols.delete(activeSymbol);
                }
                activeSymbol.moving = false;
                const symbolId = activeSymbol.dataset.id;
                const symbolX = parseFloat(activeSymbol.style.left);
                const symbolY = parseFloat(activeSymbol.style.top);
                activeSymbol = null;
                if (tabHeadersActivated[4]) await updateObjPosition(symbolId, symbolX, symbolY);
                
                isGenerating = false;
            }

            if (activeEmoji) {
                activeEmoji.style.cursor = "grab";
                if (activeEmoji.selected) {
                    if (!activeEmoji.classList.contains("active")) {
                        activeEmoji.classList.add("active");
                    }
                    selectedEmoji = activeEmoji;
                } else {
                    activeEmoji.classList.remove("active");
                    selectedEmoji = null;
                }
                const emojiId = await activeEmoji.dataset.id;
                console.log(`emoji id ${emojiId}`);
                const emojiX = parseFloat(activeEmoji.style.left);
                const emojiY = parseFloat(activeEmoji.style.top);
                activeEmoji = null;
                await updateObjPosition(emojiId, emojiX, emojiY);
            }

            // Throw away the symbol into the swirl
            rect = removeButton.getBoundingClientRect();
            if (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom) {
                if (selectedSymbols.size != 0) {
                    selectedSymbols.forEach(selectedSymbol => {
                        if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                        selectedSymbol.remove();
                    });
                }
            }
            // Throw away the symbol into the swirl
            rect = removeButton2.getBoundingClientRect();
            if (rect.left < e.clientX && e.clientX < rect.right && rect.top < e.clientY && e.clientY < rect.bottom) {
                if (selectedSymbols.size != 0) {
                    selectedSymbols.forEach(selectedSymbol => {
                        if (selectedSymbol.isDynamic) selectedSymbol.dot.remove();
                        selectedSymbol.remove();
                    });
                }
            }
        });

        function getRandomSubset(words, count) {
            return words.sort(() => Math.random() - 0.5).slice(0, count);
        }
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function areSetsEqual(set1, set2) {
            if (set1.size !== set2.size) return false; // Different sizes ‚Üí not equal
            for (let elem of set1) {
                if (!set2.has(elem)) return false; // If set2 is missing an element ‚Üí not equal
            }
            return true;
        }

        // Function to create labels for selected symbols
        function showSimpleLabel() {
            let labelData = [];

            selectedSymbols.forEach(selectedSymbol => {
                // Check if label already exists
                if (!selectedSymbol.querySelector('.symbol-label')) {
                    const words = symbolLabels[selectedSymbol.elemIdTrue][Number(selectedSymbol.isDynamic)].slice();
                    if (getDir(selectedSymbol) === 0 && !selectedSymbol.isDynamic) {
                        if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 3) words.push(...["right"]);
                        if (selectedSymbol.elemIdTrue === 4 || selectedSymbol.elemIdTrue === 6) words.push(...["left"]);
                        if (selectedSymbol.elemIdTrue === 1 || selectedSymbol.elemIdTrue === 4) words.push(...["barrier"]);
                    }
                    if (getDir(selectedSymbol) === 1) {
                        if (selectedSymbol.elemIdTrue === 1) {
                            if (selectedSymbol.isDynamic) {
                                words.push(...['gravity', 'fall', 'descend']);
                            } else {
                                words.push(...['top', 'roof', 'high', 'aloft']);
                            }
                        }
                        if (selectedSymbol.elemIdTrue === 3) {
                            if (!selectedSymbol.isDynamic) {
                                words.push(...['aerial', 'suspend', 'tall', 'float']);
                            }
                        }
                        if (selectedSymbol.elemIdTrue === 4) {
                            if (selectedSymbol.isDynamic) {
                                console.log('fly highhhhh');
                                words.push(...['ascend', 'rise', 'climb']);
                            } else {
                                words.push(...['low', 'ground', 'platform']);
                            }
                        }
                    }
                    let subset = getRandomSubset(words, 2);
                    let rect = selectedSymbol.getBoundingClientRect();
                    for (const word of subset) {
                        labelData.push([word, rect.left + rect.width / 2, rect.top + rect.height / 2, selectedSymbol]);
                    }
                }
            });

            const foundIds = new Set();
            const elimBasic = new Set();  // we don't want basic-level symbols to connect to symbols that are much advanced than them
            const representatives = new Map();
            let hasDuplicateExpression = false;
            for (const [storedWord, [storedId, storedGraph]] of library) {
                let foundMatching = currentGraph.matchSubgraph(storedGraph);
                hasDuplicateExpression = areSetsEqual(foundMatching, selectedSymbols);
                if (foundMatching != null) {
                    let avgX = 0, avgY = 0;
                    var lastSymbol;
                    for (const symbol of foundMatching) {
                        let rect = symbol.getBoundingClientRect();
                        avgX += rect.left + rect.width / 2;
                        avgY += rect.top + rect.height / 2;
                        lastSymbol = symbol;
                    }
                    representatives.set(lastSymbol, storedWord);
                    avgX /= foundMatching.size;
                    avgY /= foundMatching.size;
                    labelData.push([storedWord, avgX, avgY, lastSymbol]);
                    foundIds.add(storedId);
                    for (const symbol of foundMatching) {
                        elimBasic.add(symbol);
                    }
                }
            }

            labelData.forEach(labelDataSub => {
                const label = document.createElement('div');
                label.classList.add('symbol-label', 'removable');
                // Position the label near the symbol
                label.x = labelDataSub[1] + getRandomFloat(-100, 20);
                label.y = labelDataSub[2] + getRandomFloat(-30, 0);

                if (labelDataSub[3].labels === undefined) {
                    labelDataSub[3].labels = new Set([label]);
                } else {
                    labelDataSub[3].labels.add(label);
                }
                label.offsetX = label.x - parseFloat(labelDataSub[3].style.left);
                label.offsetY = label.y - parseFloat(labelDataSub[3].style.top);
                label.style.left = `${label.x}px`;
                label.style.top = `${label.y}px`;

                // Add event listener to remove label on click
                label.addEventListener('click', function () {
                    label.remove();
                });

                if (tabHeadersActivated[1]) tab1.appendChild(label);
                if (tabHeadersActivated[4]) tab4.appendChild(label);
                label.textContent = labelDataSub[0]; // Default text
                floatLabel(label);
            });
            return [foundIds, elimBasic, representatives, hasDuplicateExpression];
        }

        let rightMost;
        let topMost;

        // Function to create a text input near the symbol
        function showInput(foundIds, elimBasic, representatives, hasDuplicateExpression) {
            console.log(`foundIds starttt ${foundIds}`);
            rightMost = -document.documentElement.scrollWidth;
            topMost = 2 * document.documentElement.scrollHeight;
            const inputParent = selectedSymbols.values().next().value;
            selectedSymbols.forEach(selectedSymbol => {
                let rect = selectedSymbol.getBoundingClientRect();
                if (rect.right > rightMost) rightMost = rect.right;
                if (rect.top < topMost) topMost = rect.top;
            });

            const input = document.createElement('input');
            input.classList.add('label-input', 'removable');
            input.type = 'text';
            input.placeholder = "What word is this?";

            // Position the input near the symbol
            input.x = rightMost + 5;
            input.y = topMost - 2;
            input.offsetX = input.x - parseFloat(inputParent.style.left);
            input.offsetY = input.y - parseFloat(inputParent.style.top);
            input.style.left = `${input.x}px`;
            input.style.top = `${input.y}px`;

            inputParent.input = input;

            if (tabHeadersActivated[1]) tab1.appendChild(input);
            if (tabHeadersActivated[4]) tab4.appendChild(input);
            input.focus();

            const textarea = document.createElement('textarea');
            textarea.classList.add('label-textarea', 'removable');
            textarea.placeholder = 'Why?';
            
            // Position the textarea near the symbol
            textarea.x = rightMost + 5;
            textarea.y = topMost + 35;
            textarea.offsetX = textarea.x - parseFloat(inputParent.style.left);
            textarea.offsetY = textarea.y - parseFloat(inputParent.style.top);
            textarea.style.left = `${textarea.x}px`;
            textarea.style.top = `${textarea.y}px`;

            inputParent.textarea = textarea;

            if (tabHeadersActivated[1]) tab1.appendChild(textarea);
            if (tabHeadersActivated[4]) tab4.appendChild(textarea);
            textarea.focus();

            // Adjust height dynamically as user types
            textarea.addEventListener('input', function () {
                textarea.style.height = 'auto'; // Reset height first
                textarea.style.height = `${textarea.scrollHeight}px`; // Set new height based on content
                submitButton.style.top = `${parseFloat(textarea.style.top) + 8 + textarea.scrollHeight}px`;
            });

            // Create the submit button
            const submitButton = document.createElement("button");
            submitButton.classList.add("submit-button", 'removable');
            submitButton.innerHTML = "‚úî"; // Checkmark icon
            
            submitButton.x = rightMost + 5;
            submitButton.y = topMost + 43 + textarea.scrollHeight;
            submitButton.offsetX = submitButton.x - parseFloat(inputParent.style.left);
            submitButton.offsetY = submitButton.y - parseFloat(inputParent.style.top);
            submitButton.style.left = `${submitButton.x}px`; // Position to the right of the textbox
            submitButton.style.top = `${submitButton.y}px`;

            inputParent.submitButton = submitButton;

            if (tabHeadersActivated[1]) {
                // Append elements to the document
                tab1.appendChild(input);
                tab1.appendChild(textarea);
                tab1.appendChild(submitButton);
            }
            if (tabHeadersActivated[4]) {
                // Append elements to the document
                tab4.appendChild(input);
                tab4.appendChild(textarea);
                tab4.appendChild(submitButton);
            }

            let word;
            let definition;
            let justification;

            // Handle button click event
            submitButton.onclick = async function () {
                word = input.value;

                // Recalculate the molecule to incorporate the advanced vocabulary
                triggerLongPress(selectedSymbols.values().next().value, representatives);

                definition = moleculeString;
                justification = textarea.value;

                console.log(`word ${word} definition ${definition} justification ${justification}`); // Handle submission logic here
                //input.remove();
                //textarea.remove();

                submitButton.remove();
                input.readOnly = true;
                textarea.readOnly = true;

                if (!word || !definition || !justification) {
                    showFeedback('Please fill in all fields!', true);
                    return;
                }

                if (library.has(word)) {
                    showFeedback('You have already defined the word!', true);
                    return;
                }

                if (hasDuplicateExpression) {
                    showFeedback('You have already used this expression for defining another word!', true);
                    return;
                }

                try {
                    const response = await fetch("https://divinatory-conlang.zhouyt-tony2018.workers.dev/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        type: "conlang",
                        word,
                        definition,
                        justification
                    })
                    });

                    const data = await response.json();
                    showFeedback(data.result, false);
                } catch (error) {
                    console.error(error);
                    alert("Validation failed.");
                }
            };


            function showFeedback(feedback, manualFailed=false){
                console.log(`foundIds init ${foundIds}`);
                // Create the div element
                const outputBox = document.createElement("div");
                outputBox.classList.add("typing-effect", 'removable');

                // Create the p element
                const pElement = document.createElement("p");
                pElement.x = rightMost + 5;
                pElement.y = parseFloat(textarea.style.top) - 10 + textarea.scrollHeight;
                console.log(`scroll ${textarea.scrollHeight}`);

                pElement.offsetX = pElement.x - parseFloat(inputParent.style.left);
                pElement.offsetY = pElement.y - parseFloat(inputParent.style.top);
                pElement.style.left = `${pElement.x}px`; // Position to the right of the textbox
                pElement.style.top = `${pElement.y}px`;

                inputParent.pElement = pElement;

                // Create a span element to hold the text (so the cursor stays at the end)
                const textSpan = document.createElement("span");
                textSpan.id = "typingText";
                pElement.appendChild(textSpan);

                // Create a cursor span element
                const cursorSpan = document.createElement("span");
                cursorSpan.id = "cursor";
                cursorSpan.textContent = "|"; // Cursor symbol
                pElement.appendChild(cursorSpan);

                // Append the p element to the div element
                outputBox.appendChild(pElement);

                // Append the div element to the body of the document
                if (tabHeadersActivated[1]) tab1.appendChild(outputBox);
                if (tabHeadersActivated[4]) tab4.appendChild(outputBox);

                const text = feedback;
                let index = 0;
                const speed = 10; // Speed of typing in milliseconds
                const maxLineLen = 20;
                let lineIndex = 0;
                let passed;

                function type(onComplete) {
                    if (document.getElementById("typingText") !== null) {
                        if (index < text.length) {
                            if (lineIndex < Math.floor(document.getElementById("typingText").innerHTML.length / maxLineLen) && text.charAt(index) === ' ') {
                                document.getElementById("typingText").innerHTML += '\n';
                                console.log('erer')
                                console.log(Math.floor(document.getElementById("typingText").innerHTML.length / maxLineLen));
                                lineIndex++;
                            }
                            document.getElementById("typingText").innerHTML += text.charAt(index);
                            index++;
                            setTimeout(() => type(onComplete), speed);
                        } else {
                            if (text.includes("Yes")) {
                                passed = true;
                            } else {
                                passed = false;
                            }
                            if (onComplete) onComplete(passed);
                        }
                    }
                }

                function showDoneButton(passed) {
                    console.log(`foundIds ${foundIds}`);

                    const doneButton = document.createElement("button");
                    doneButton.classList.add("submit-button", "removable");
                    if (passed) {
                        doneButton.innerHTML = "‚úî"; // Checkmark icon
                    } else {
                        doneButton.innerHTML = "‚úò"; // Checkmark icon
                    }
                    
                    doneButton.x = rightMost + 5; // Position to the right of the textbox
                    doneButton.answerHeight = (lineIndex + 2) * 24;
                    doneButton.y = parseFloat(pElement.style.top) + doneButton.answerHeight;

                    doneButton.offsetX = doneButton.x - parseFloat(inputParent.style.left);
                    doneButton.offsetY = doneButton.y - parseFloat(inputParent.style.top);
                    doneButton.style.left = `${doneButton.x}px`; // Position to the right of the textbox
                    doneButton.style.top = `${doneButton.y}px`;

                    inputParent.doneButton = doneButton;
                    console.log(doneButton.style.left);
                    console.log(doneButton.style.top);

                    if (tabHeadersActivated[1]) tab1.appendChild(doneButton);
                    if (tabHeadersActivated[4]) tab4.appendChild(doneButton);

                    doneButton.onclick = async function () {
                        if (passed && !manualFailed) {
                            clearInterval(activeTabInterval);

                            tabHeaders[2].classList.add('tab-active');

                            activeTabInterval = setInterval(() => {
                                tabHeaders[2].classList.toggle('tab-active');
                            }, 1000); // Adjust timing as needed (1s cycle: 0.5s fade in, 0.5s fade out)

                            let storedGraph = new SymbolGraph();
                            for (const symbol of selectedSymbols) {
                                let connections = currentGraph.getSymbolConnections(symbol);
                                storedGraph.addSymbol(symbol, connections);
                            }
                            let id = await synthNode(selectedSymbols, word, justification, foundIds, elimBasic);
                            library.set(word, [id, storedGraph]);
                            console.log('library');
                            console.log(library);
                        }
                        if (eyeButton.isActivated) {
                            eyeButton.isActivated = false;
                            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                    }
                }

                type(showDoneButton);
            }
        }
        


        function startLongPress(left, top, width, height, symbol=null, node=null) {
            ring = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        // Append the circle to the SVG
            ring.appendChild(circle);
            if (tabHeadersActivated[1]) tab1.appendChild(ring);
            if (tabHeadersActivated[4]) tab4.appendChild(ring);
            
            const symbolCenterX = left + width / 2;
            const symbolCenterY = top + height / 2;

            // Create the SVG element with the desired attributes
            
            ring.style.left = symbolCenterX - 25;
            ring.style.top = symbolCenterY - 25;
            ring.setAttribute("class", "progress-ring");
            ring.setAttribute("width", "50");
            ring.setAttribute("height", "50");
            ring.setAttribute("viewBox", `${symbolCenterX - 27} ${symbolCenterY - 27} 54 54`);

            // Create the circle element

            circle.setAttribute("cx", symbolCenterX.toString());
            circle.setAttribute("cy", symbolCenterY.toString());

            if (symbol === null) {
                circle.setAttribute("r", width.toString());
            } else {
                circle.setAttribute("r", "25");
            }
            circle.setAttribute("stroke-width", "5");
    
            ring.style.visibility = "visible";

            circle.style.stroke = "#00B0F0";
            progress = 0;
            circle.style.strokeDashoffset = 157; // Reset
            interval = setInterval(() => {
                progress += 1;
                const offset = 157 * (1 - progress / totalSteps); // More precise calculation
                circle.style.strokeDashoffset = offset;
        
                if (progress >= totalSteps) {
                    clearInterval(interval);
                    if (symbol === null) {
                        triggerLongPressNode(node);
                    } else {
                        triggerLongPress(symbol);
                    }
                }
            }, 10);
        }
    
        function endLongPress() {
            if (ring !== null && circle !== null) {
                clearInterval(interval);
                ring.style.visibility = "hidden";
                circle.style.strokeDashoffset = 157;
                circle.style.stroke = "transparent";
                ring = null;
                circle = null;
            }
        }
    
        function triggerLongPress(symbol, representatives=null) {
            if (circle !== null) {
                circle.style.stroke = "#FFC000";
            }
            moleculeString = "";

            let results = getMolecule(symbol, new Set([]), representatives=representatives);
            selectedSymbols = results.visited;
            if (results.leftStr !== "") moleculeString += results.leftStr + " - "
            moleculeString += results.centerStrs.join(" & ");
            if (results.rightStr !== "") moleculeString += " - " + results.rightStr
            console.log(`resultssss left ${results.leftStr} center ${results.centerStrs} right ${results.rightStr}`);

            selectedSymbols.forEach(selectedSymbol => {
                selectedSymbol.selected = true;
                if (!selectedSymbol.classList.contains("framed")) {
                    console.log(`add ${selectedSymbol}`);
                    selectedSymbol.classList.add("framed");
                }
            });
            console.log(`molecule ${moleculeString}`);
        }

        // Create a new copy of the symbol being clicked
        async function createSymbolCopy(mouseX, mouseY, elemId = -1, symbolX=null, symbolY=null, symbolColor=null, symbolAngle=null, symbolId=null) {
            let offsetX = symbolWidth * symbolScale / 2;
            let offsetY = symbolHeight * symbolScale / 2;
            // Create the copy
            const symbol = document.createElement('div');
            symbol.ondragstart = (e) => e.preventDefault();
            symbol.selected = false;
            symbol.moving = false;
            symbol.stopped = false;
            symbol.angle = 0;
            symbol.isDynamic = false;
            symbol.classList.add('symbol');
            symbol.elemId = elemId;
            symbol.elemIdTrue = symbol.elemId;
            symbol.innerHTML = symbolData[symbol.elemId];

            if (symbolX === null) symbol.accId = acc;  // newly created 

            if (symbolX) {
                symbol.style.left = `${symbolX}px`;
                symbol.style.top = `${symbolY}px`;
            } else {
                symbol.style.left = `${mouseX - offsetX}px`;
                symbol.style.top = `${mouseY - offsetY}px`;
            }
            if (symbolColor) {
                dyeColor(symbol, symbolColor);
            } else if (tabHeadersActivated[4]) {
                symbolColor = await assignUserColor();
                console.log(symbol);
                console.log(symbolColor);
                dyeColor(symbol, symbolColor);
            }
            if (symbolAngle) {
                await rotateSymbol(symbol, symbolAngle);
            }
            symbol.dot = null;
    

            // Add pressing event listener to the symbol
            symbol.addEventListener("mousedown", (e) => {
                if (selectedEmoji) {
                    selectedEmoji.style.cursor = "grab";
                    selectedEmoji.classList.remove("active");
                    selectedEmoji = null;
                }

                activeSymbol = symbol; // becomes active when being clicked on
                selectedSymbols.forEach(selectedSymbol => {
                    if (selectedSymbol !== null && selectedSymbol !== symbol) { // hide all the frame of all symbols except for the current symbol
                        selectedSymbol.selected = false;
                        selectedSymbol.classList.remove("framed");
                        selectedSymbols.delete(selectedSymbol);
                        if (eyeButton.isActivated) {
                            eyeButton.isActivated = false;
                            eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                        if (eyeButton2.isActivated) {
                            eyeButton2.isActivated = false;
                            eyeButton2.style.backgroundImage = "url('./icons/eye_black.png')";
                            removeLabelInputs();
                        }
                    }
                });
                symbol.offsetX = e.clientX - symbol.offsetLeft;
                symbol.offsetY = e.clientY - symbol.offsetTop;
                symbol.selected = !symbol.selected;
                symbol.style.cursor = "grabbing";
                startLongPress(parseFloat(symbol.style.left), parseFloat(symbol.style.top), symbolWidth * symbolScale, symbolHeight * symbolScale, symbol);
                // console.log("mouse down " + activeSymbol.elemId);
            });


            /* if horizontal: left, right, top perpendicular, bottom perpendicular, top parallel, bottom parallel */
            /* if vertical: top, down, left perpendicular, right perpendicular, left parallel, right parallel */
            currentGraph.addSymbol(symbol, [[], [], [], [], [], []]);

            console.log(tabHeadersActivated);
            if (tabHeadersActivated[1]) tab1.appendChild(symbol);
            if (symbolX || tabHeadersActivated[4]) {
                tab4.appendChild(symbol);
            }

            if (selectedSymbols.size !== 0) {
                selectedSymbols.forEach(selectedSymbol => {
                    selectedSymbol.selected = false;
                    selectedSymbol.classList.remove("framed");
                    selectedSymbols.delete(selectedSymbol);
                });
                if (eyeButton.isActivated) {
                    eyeButton.isActivated = false;
                    eyeButton.style.backgroundImage = "url('./icons/eye_black.png')";
                    removeLabelInputs();
                }                
            }
            if (symbolX === null) {
                activeSymbol = symbol;
            }
            symbol.offsetX = offsetX;
            symbol.offsetY = offsetY;

            if (tabHeadersActivated[4] || symbolX!==null) {
                // Get div attributes
                const symbolPacket = {
                    id:elemId,
                    color:symbolColor,
                    angle:0,
                    dotX:null,
                    dotY:null
                };
                console.log(symbol);

                if (symbolId !== null) {
                    symbol.dataset.id = symbolId;
                } else {
                    symbol.dataset.id = await saveObj("symbol", symbolPacket, parseFloat(symbol.style.left), parseFloat(symbol.style.top));
                }
            }
            return symbol;
        }

        // Find all the symbols that are connected to one symbol
        function getMolecule(currentSymbol, visited, representatives=null) {
            visited.add(currentSymbol);

            console.log(`visit`);
            console.log(visited);
            console.log(currentSymbol);
            let leftStr = "";
            let centerStrs = [getMoleculeChar(currentSymbol)];
            console.log(`representatives`);
            console.log(representatives);
            if (representatives != null && representatives.has(currentSymbol)) {
                centerStrs.push(representatives.get(currentSymbol));
            }

            let rightStr = "";
            for (let i = 0; i < currentGraph.getSymbolConnections(currentSymbol).length; i++) {  // every magnet point
                for (const entry of currentGraph.getSymbolConnections(currentSymbol)[i]) {  // entry = [every other symbol connected to my magnet point, its magnet point]
                    if (!visited.has(entry[0])) {
                        let results = getMolecule(entry[0], visited, representatives=representatives);
                        visited = results.visited;
                        console.log(`entry[0] ${entry[0].elemId} entry[1] ${entry[1]}`);
                        if (entry[1] > 1 || i > 1) {
                            if (leftStr !== "" && results.leftStr !== "") {
                                leftStr = "(" + leftStr + ") & (" + results.leftStr + ")";
                            } else if (leftStr == "") {
                                leftStr = results.leftStr;
                            }
                            centerStrs.push(...results.centerStrs);
                            if (rightStr !== "" && results.rightStr !== "") {
                                rightStr = "(" + rightStr + ") & (" + results.rightStr + ")";
                            } else if (rightStr == "") {
                                rightStr = results.rightStr;
                            }
                            console.log(`me ${currentSymbol.elemId} entry[0] ${entry[0].elemId} centerStrs ${centerStrs.join(" & ")}`);
                        } else {
                            if (i === 0) {
                                if (results.leftStr !== "") leftStr += results.leftStr + " - "
                                leftStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") leftStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} left entry[0] ${leftStr} centerStrs ${centerStrs.join(" & ")}`);
                            } else if (i === 1) {
                                if (results.leftStr !== "") rightStr += results.leftStr + " - "
                                rightStr += results.centerStrs.join(" & ");
                                if (results.rightStr !== "") rightStr += " - " + results.rightStr
                                console.log(`me ${currentSymbol.elemId} right entry[0] ${rightStr} centerStrs ${centerStrs.join(" & ")}`);
                            }
                        }

                    }
                }
            }
            console.log(`me ${currentSymbol.elemId}`);
            console.log(`left ${leftStr} center ${centerStrs.join(" & ")} right ${rightStr}`)
            console.log(`visited ${visited.size}`);
            return {visited: visited, leftStr: leftStr, centerStrs: centerStrs, rightStr: rightStr};
        }

        function getMoleculeChar(symbol) {
            const table = ['ƒ°', 'ƒã', 'g', 'c', 'r', 'l', 'v', 'f', 'd', 't', 'b', 'p', 's', 'z', '·π°', '≈º', 'n', 'm'];
            let char = table[symbol.elemIdTrue * 2 + Number(symbol.isDynamic)];
            if (char === 'g' || char === 'c' || char === 'v' || char === 'd' || char === 't' || char === 's') {
                if (symbol.angle === 0 || symbol.angle === 180) {
                    char += ' horizontal';
                } else {
                    char += ' vertical';
                }
            }
            return char;
        }

        // Check for snapping connections
        function checkConnections(active) {
            let targetX;
            let targetY;
            readyActive = null;
            readyTarget = null;
            readyActiveSide = null;
            readyTargetSide = null;
            for (const target of currentGraph.getSymbols()) {
                if (target === active) continue; // Skip the active symbol itself
                const activeJunctions = getAbsJunctions(active);
                const targetJunctions = getAbsJunctions(target);

                targetJunctions.forEach((targetCoord, index) => {
                    switch (index) {
                        case 0: // connected at the left / top start
                            if (getDir(active) === getDir(target)) { // active right >=< target left
                                snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 0);
                            } else {
                                const [first, second, , fourth] = activeJunctions;  // valid coordinates for connecting
                                snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, 0, 0, 'Âßã');
                                if (getDir(active) === 0) {  // target 
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, 1, 0, 'Âßã');
                                } else {
                                    snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y + calY, 1, 0, 'heihei');
                                }
                                snapToSymbol(active, target, fourth.x, fourth.y, targetCoord.x, targetCoord.y, 3, 0, 'Âßã');
                            }
                            break;
                        case 1:  // connected at the right / bottom end
                            if (getDir(active) === getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, 0, 1, "snap to the right");
                            } else {
                                const [first, second, third] = activeJunctions.slice(0, 3);  // valid coordinates for connecting
                                if (getDir(active) === 1) {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y, 0, 1, 'Êú´');
                                } else {
                                    snapToSymbol(active, target, first.x, first.y, targetCoord.x, targetCoord.y - calY, 0, 1, 'meimei');
                                }
                                snapToSymbol(active, target, second.x, second.y, targetCoord.x, targetCoord.y, 1, 1, 'Êú´');
                                snapToSymbol(active, target, third.x, third.y, targetCoord.x, targetCoord.y, 2, 1, 'Êú´');
                            }
                            break;
                        case 2:  // perpendicular: inserted at the top / left center
                            if (getDir(active) !== getDir(target)) {
                                if (getDir(active) === 0) {  // horizontal active inserted on vertical target ‰∏ä
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 2, "Âçú");
                                } else {
                                    snapToSymbol(active, target, activeJunctions[1].x, activeJunctions[1].y, targetCoord.x, targetCoord.y, 1, 2, "‰∏ä");
                                }
                            }
                            break;
                        case 3:  // perpendicular: inserted at bottom / right center ‰∏ã
                            if (getDir(active) !== getDir(target)) {
                                snapToSymbol(active, target, activeJunctions[0].x, activeJunctions[0].y, targetCoord.x, targetCoord.y, 0, 3, "‰∏ã");
                            }
                            break;
                    }
                });

                if (getDir(active) === getDir(target)) {  // parallel
                    if (getDir(active) === 0) {
                        targetX = parseInt(target.style.left);
                        targetY = parseInt(target.style.top) - (symbolHeight - 7) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[4].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 5, 4);
                        }
                        targetY = parseInt(target.style.top) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[3].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 4, 5);
                        }
                    }
                    if (getDir(active) === 1) {
                        targetX = parseInt(target.style.left) - (symbolHeight - 7) * symbolScale;
                        targetY = parseInt(target.style.top);
                        if (currentGraph.getSymbolConnections(target)[0].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 5, 4);
                        }
                        targetX = parseInt(target.style.left) + (symbolHeight - 4) * symbolScale;
                        if (currentGraph.getSymbolConnections(target)[1].length === 0) {
                            snapToSymbol(active, target, parseInt(active.style.left), parseInt(active.style.top), targetX, targetY, 4, 5);
                        }
                    }
                }
            }
        }

        // Get the offset for the symbol when connected to another symbol (side 0 = left, 1 = right)
        function getRelJunctions(symbol) {
            let junctions; // [start, end, middle_1, middle_2]
            switch (symbol.elemId) {
                case 0:
                    junctions = [{x: 1, y: 13}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 1:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 2:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 14}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 3:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 4:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 5:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 50}, {x: symbolWidth / 2, y: 56}];
                    break;
                case 6:
                    junctions = [{x: 1, y: 57}, {x: symbolWidth - calX, y: 57}, {x: symbolWidth / 2, y: 56}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 7:
                    junctions = [{x: 1, y: 32}, {x: symbolWidth - calX, y: 32}, {x: symbolWidth / 2, y: 3}, {x: symbolWidth / 2, y: 64}];
                    break;
                case 8:
                    junctions = [{x: 1, y: 49}, {x: symbolWidth - calX, y: 49}, {x: symbolWidth / 2, y: 13}, {x: symbolWidth / 2, y: 56}];
                    break;
            }
            return junctions;
        }

        function getAbsJunctions(symbol) {
            const relJunctions = getRelJunctions(symbol);
            const rect = symbol.getBoundingClientRect();
            let absJunctions;
            if (symbol.angle === 0) {
                absJunctions = [{x: rect.left + relJunctions[0].x * symbolScale, y: rect.top + relJunctions[0].y * symbolScale},
                                {x: rect.left + relJunctions[1].x * symbolScale, y: rect.top + relJunctions[1].y * symbolScale},
                                {x: rect.left + relJunctions[2].x * symbolScale, y: rect.top + relJunctions[2].y * symbolScale},
                                {x: rect.left + relJunctions[3].x * symbolScale, y: rect.top + relJunctions[3].y * symbolScale}];
            }
            if (symbol.angle === 180) {
                absJunctions = [{x: rect.right - relJunctions[1].x * symbolScale, y: rect.bottom - relJunctions[1].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[0].x * symbolScale, y: rect.bottom - relJunctions[0].y * symbolScale - calInvY},
                                {x: rect.right - relJunctions[3].x * symbolScale, y: rect.bottom - relJunctions[3].y * symbolScale},
                                {x: rect.right - relJunctions[2].x * symbolScale, y: rect.bottom - relJunctions[2].y * symbolScale}];
            }
            if (symbol.angle === 90) {
                absJunctions = [{x: rect.right - relJunctions[0].y * symbolScale, y: rect.top + relJunctions[0].x * symbolScale},
                                {x: rect.right - relJunctions[1].y * symbolScale, y: rect.top + relJunctions[1].x * symbolScale},
                                {x: rect.right - relJunctions[3].y * symbolScale, y: rect.top + relJunctions[3].x * symbolScale},
                                {x: rect.right - relJunctions[2].y * symbolScale, y: rect.top + relJunctions[2].x * symbolScale}];
            }
            if (symbol.angle === 270) {
                absJunctions = [{x: rect.left + relJunctions[1].y * symbolScale + calInvY, y: rect.bottom - relJunctions[1].x * symbolScale},
                                {x: rect.left + relJunctions[0].y * symbolScale + calInvY, y: rect.bottom - relJunctions[0].x * symbolScale},
                                {x: rect.left + relJunctions[2].y * symbolScale, y: rect.bottom - relJunctions[2].x * symbolScale},
                                {x: rect.left + relJunctions[3].y * symbolScale, y: rect.bottom - relJunctions[3].x * symbolScale}];
            }
            if (symbol.elemId === 2) {
                if (symbol.angle === 0) {
                    absJunctions[2].x += calCan1;
                    absJunctions[3].x += calCan1;
                }
                if (symbol.angle === 270) {
                    absJunctions[2].y -= calCan1;
                    absJunctions[3].y -= calCan1;
                }
                if (symbol.angle === 90) {
                    absJunctions[2].y -= calCan2;
                    absJunctions[3].y -= calCan2;
                }
                if (symbol.angle === 180) {
                    absJunctions[2].x += calCan2;
                    absJunctions[3].x += calCan2;
                }
            }

            return absJunctions;
        }

        function getDist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function getDir(symbol) {
            if (symbol.angle === 0 || symbol.angle === 180) {
                return 0;  // horizontal
            }
            if (symbol.angle === 90 || symbol.angle === 270) {
                return 1;  // vertical
            }
        }


        // Snap active symbol to target
        function snapToSymbol(active, target, activeX, activeY, targetX, targetY, activeSide, targetSide, msg = "") {
            if (targetSide > 1 && currentGraph.getSymbolConnections(target)[targetSide].length > 0) {  // if trying to connect to 2, 3, 4, or 5, and there is already an element occupying
                console.log(`targetSide ${targetSide} length ${currentGraph.getSymbolConnections(target)[targetSide].length}`);
                return;
            }
            if (currentGraph.getSymbolConnections(target)[targetSide].length !== 0) {
                let hasOverlap = false;
                for (const entry of currentGraph.getSymbolConnections(target)[targetSide]) {
                    if (getDir(entry[0]) === getDir(active) && entry[1] === activeSide) {
                        hasOverlap = true;
                    }
                }
                if (hasOverlap) {
                    // console.log('hasOverlap');
                    return;
                }
            }
            if (getDist(activeX, activeY, targetX, targetY) < SNAP_DISTANCE) {
                const newX = parseInt(active.style.left) + targetX - activeX;
                const newY = parseInt(active.style.top) + targetY - activeY;
                if (msg !== "") {
                    console.log(`${msg} activeX: ${activeX} activeY: ${activeY} targetX: ${targetX} targetY: ${targetY}`);
                }
                active.style.left = `${newX}px`;
                active.style.top = `${newY}px`;
                // complete the linkage only when the mouse is released from the active symbol
                readyActive = active;
                readyTarget = target;
                readyActiveSide = activeSide;
                readyTargetSide = targetSide;
                console.log(`link detected active side ${readyActiveSide} target side ${readyTargetSide}`);
            }
        }

        // Add an event listener for clicks on the document
        document.addEventListener("click", (event) => {
            // Get the mouse coordinates
            const x = event.clientX; // X-coordinate relative to the viewport
            const y = event.clientY; // Y-coordinate relative to the viewport

            // Print the coordinates to the console
            console.log(`Mouse clicked at: X = ${x}, Y = ${y}`);
            console.log(currentGraph);
        });


        /* Library */
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;
        let nodeTextBoxes = {};
        let container = document.getElementById("network");
        let data = {nodes: nodes, edges: edges};
        let basicNodes = new Set();
        let options = {
            nodes: {
                shape: "circularImage",
                borderWidth: 3,
                color: {
                    border: "black",
                    background: "white",
                    highlight: {
                        border: "black",
                        background: "#f0f0f0" // Light gray on hover
                    },
                    hover: {
                        border: "black",
                        background: "#e0e0e0" // Slightly darker gray on hover
                    }
                },
                shapeProperties: { useBorderWithImage: true },
                size: 20
            },
            edges: {
                smooth: false
            },
            physics: { enabled: true }
        };
        async function initNodes() {
            for (let i = 0; i < symbolData.length; i++) {
                let svgString = symbolData[i];
                let newNode = {
                    id: await generateUniqueId(svgString),
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    title: symbolTitles[i]
                };
                console.log(newNode['id']);
                nodes.add(newNode);
                basicNodes.add(newNode);
            }
            network = new vis.Network(container, data, options);
            network.once('afterDrawing', function () {
                // Assuming 'container' is the DOM element where the network is rendered
                let containerWidth = container.offsetWidth;
                let containerHeight = container.offsetHeight;
                let scale = 1.5;
                console.log(containerWidth, containerHeight)
                network.moveTo({
                    offset: {
                        x: (0.5 * containerWidth) * scale,
                        y: (0.5 * containerHeight) * scale
                    },
                    scale: scale
            });});
        }
        initNodes();


        function capitalizeFirstLetter(val) {
            return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }

        function scaleSVG(svgString, targetSize = 40) {
            // Parse SVG string
            let parser = new DOMParser();
            let doc = parser.parseFromString(svgString, "image/svg+xml");
            let svg = doc.documentElement;

            let viewBox = svg.getAttribute("viewBox");
            let width = parseFloat(svg.getAttribute("width"));
            let height = parseFloat(svg.getAttribute("height"));

            if (viewBox) {
                let [x, y, w, h] = viewBox.split(" ").map(parseFloat);
                width = w;
                height = h;
            }

            if (!width || !height) return svgString; // Fallback: return original SVG

            // Calculate scale factor
            let scale = (targetSize * 0.6) / Math.max(width, height); 

            // Calculate translation to center the scaled content
            let translateX = (targetSize - width * scale) / 2;
            let translateY = (targetSize - height * scale) / 2;

            // Apply transform
            let transform = `translate(${translateX}, ${translateY}) scale(${scale})`;

            // Wrap everything inside a group <g> element to apply transformations
            let group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("transform", transform);
            while (svg.firstChild) {
                group.appendChild(svg.firstChild);
            }
            svg.innerHTML = ""; // Clear original SVG
            svg.appendChild(group);

            // Set viewBox to match the target circle size
            svg.setAttribute("width", targetSize);
            svg.setAttribute("height", targetSize);
            svg.setAttribute("viewBox", `0 0 ${targetSize} ${targetSize}`);

            return new XMLSerializer().serializeToString(svg);
        }

        // Synthesize a node from its components and connect the component nodes to the synthesized node
        async function synthNode(components, word, justification, foundIds, elimBasic) {
            let leftMost = 2 * document.documentElement.scrollWidth;
            let rightMost = -document.documentElement.scrollWidth;
            let topMost = 2 * document.documentElement.scrollHeight;
            let bottomMost = -document.documentElement.scrollHeight;
            let rect;
            let svgString = "";
            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                if (rect.left < leftMost) leftMost = rect.left;
                if (rect.right > rightMost) rightMost = rect.right;
                if (rect.top < topMost) topMost = rect.top;
                if (rect.bottom > bottomMost) bottomMost = rect.bottom;

                if (symbol.dot != null) {
                    rect = symbol.dot.getBoundingClientRect();
                    if (rect.left < leftMost) leftMost = rect.left;
                    if (rect.right > rightMost) rightMost = rect.right;
                    if (rect.top < topMost) topMost = rect.top;
                    if (rect.bottom > bottomMost) bottomMost = rect.bottom;
                }
            });
            console.log(`left ${leftMost} right ${rightMost} top ${topMost} bottom ${bottomMost}`);
            const ratio = 49.92 / (symbolWidth * symbolScale);

            components.forEach(symbol => {
                rect = symbol.getBoundingClientRect();
                let transX;
                let transY;
                switch(symbol.angle) {
                    case 0: transX = rect.left; transY = rect.top; break;
                    case 90: transX = rect.right; transY = rect.top; break;
                    case 180: transX = rect.right; transY = rect.bottom; break;
                    case 270: transX = rect.left; transY = rect.bottom; break;
                }
                svgString += `<g transform="translate(` + ((transX - leftMost) * ratio).toString() + `, ` + ((transY - topMost) * ratio).toString()
                            + `) rotate(` + symbol.angle.toString() + `)">` + symbol.querySelector("svg").innerHTML + `</g>\n`;
                
                if (symbol.dot != null) {
                    console.log("added dot!");
                    rect = symbol.dot.getBoundingClientRect();
                    svgString += `<g transform="translate(` + ((rect.left - leftMost) * ratio).toString() + `, ` + ((rect.top - topMost) * ratio).toString()
                    + `)">` + dotDataMini + `</g>\n`;
                }
            });


            const widthStr = ((rightMost - leftMost) * ratio).toString();
            const heightStr = ((bottomMost - topMost) * ratio).toString();
            svgString = `<svg width="` + widthStr + `" height="` + heightStr
                        + `" viewBox="0 0 ` + widthStr + ` ` + heightStr + `" xmlns="http://www.w3.org/2000/svg">\n`
                        + svgString
                        +  `</svg>`;

            let id = await generateUniqueId(svgString);
            let hasDuplicate = false;
            nodes.forEach(node => {
                if (node['id'] === id) {
                    hasDuplicate = true;
                }
            });

            if (!hasDuplicate) {
                let newNode = {
                    id: id,
                    shape: "circularImage",
                    image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(scaleSVG(svgString)),
                    title: capitalizeFirstLetter(word) + ". " + capitalizeFirstLetter(justification)
                };
                
                nodes.add(newNode); // Add node to dataset
                for (const symbol of selectedSymbols) {
                    if (!elimBasic.has(symbol)) addEdge(await generateUniqueId(symbolData[symbol.elemIdTrue]), id);
                }
                for (const foundId of foundIds) {
                    addEdge(foundId, id);
                }
            }
            return id;
        }

        function addEdge(sourceId, targetId) {
            // Get all existing edges
            const existingEdges = edges.get();

            // Check if the edge already exists between the two nodes, in either direction
            const edgeExists = existingEdges.some(edge => {
                return (edge.from === sourceId && edge.to === targetId) || (edge.from === targetId && edge.to === sourceId);
            });

            if (!edgeExists) {
                edges.add({
                    from: sourceId,
                    to: targetId,
                    arrows: { to: { enabled: true } },
                    color: { color: "black" }
                });
                console.log(`link ${sourceId} ${targetId}`);
            }
        }

        async function generateUniqueId(svgString) {
            console.log(`used string ${svgString}`);
            // Ensure consistent encoding
            const encoder = new TextEncoder();
            const data = encoder.encode(svgString.trim());  // Trim to avoid whitespace inconsistencies

            // Compute SHA-256 hash
            const hashBuffer = await crypto.subtle.digest("SHA-256", data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));

            // Convert hash to a base64 string (URL-safe)
            return "svg-" + btoa(String.fromCharCode(...hashArray))
                .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")  // Remove padding
                .substring(0, 16); // Trim for shorter ID
        }


    </script>
</body>
</html>